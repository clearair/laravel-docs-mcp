{"id":"526e8308d84195e4e6c62bbfc883781c-0","text":"\nShould I ditch the terms \"hydrate\" and \"dehydrate\"? Hydrate is normally used for hydrating frontend behavior from a frozen state. Well, we're just applying it to the backend. Serialize and unserialize are alternatives as are \"sleep\" and \"wakeup\".","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-1","text":"sleep\" and \"wakeup\".\n\n* more examples\n* best practices\n\t* https://github.com/michael-rubel/livewire-best-practices\n* performance best practices\n* security dangers\n\t* https://forum.archte.ch/livewire/t/advanced-livewire-a-better-way-of-working-with-models\n* More readable font\n* \"how livewire works\"\n* Laravel bootcamp style tutorial\n* small example app\n* \n\n## Outline","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-2","text":"e app\n* \n\n## Outline\n\nQuickstart\n* Installing Livewire\n* Creating your first component (create post, not counter)\n* Adding properties\n* Adding behavior\n* Rendering the component in the browser\n* Testing it out\n\nUpgrade Guide","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-3","text":"t out\n\nUpgrade Guide\n\nFundamentals:\n* Installation\n\t* Composer command\n\t* Publishing config\n\t* Disabling asset auto-injection\n\t* Configuring Livewire's update endpoint\n\t* Configuring Livewire's JavaScript endpoint\n\t* Publishing and hosting Livewire's JavaScript\n* Components\n\t* Creating a component\n\t* The render method\n\t\t* Returning Blade views\n\t\t* Returning template strings","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-4","text":"ing template strings\n\t       * artisan make --inline\n\t- Rendering a single component\n\t\t- Passing parameters\n\t\t- Receiving parameters\n\t- Rendering a component route\n\t\t* Configuring the layout\n\t\t* Route parameters\n\t\t* Route model binding\n* Properties\n\t* Introduction\n\t* Initializing properties in the mount method\n\t* Bulk assigning properties ($this->fill())\n\t* Resetting properties ($this->reset())","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-5","text":"ies ($this->reset())\n\t* Data binding (Basic introduction with link to other documentation page)\n\t* Supported property types\n\t\t* (Brief explanation of hydration/dehydration and why every possible type isn't supported)\n\t\t* Primitive types (strings, int, boolean, etc...)\n\t\t* Common PHP types (Collection, DateTime, etc...)","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-6","text":"n, DateTime, etc...)\n\t\t* Supporting custom types (explain how users can add support for types specific to their application)\n\t\t\t* Using Wireables\n\t\t\t* Using Synthesizers\n\t* Using $wire \n\t    * Accessing properties with $wire in Alpine inside your component\n\t    * Manipulating properties\n\t    * Using $wire.get and $wire.set\n\t* Security concerns\n\t\t* Don't trust properties\n\t\t\t* Authorizing properties","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-7","text":"thorizing properties\n\t\t\t* Using \"locked\" properties\n\t\t* Be aware that Livewire exposes property metadata like eloquent model class names\n\t* \"Computed\" properties (using ->getPostProperty() syntax)","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-8","text":"stProperty() syntax)\n\n* Actions\n\t* Security concerns\n\t* Parameters\n\t* Event modifiers\n\t\t* Keydown modifiers\n\t* Magic actions\n\t * Wireable actions\n * Data Binding\n\t* Live binding\n\t* Lazy binding\n\t* Debounced binding\n\t* Throttled binding\n\t* Binding nested data\n\t* Binding to eloquent models\n* Nesting components\n* Events\n\t* Basic example\n\t* Security concerns\n\t* Firing events\n\t* Listeners","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-9","text":" events\n\t* Listeners\n\t* Passing parameters\n\t* Scoping events\n\t\t* parent / name / self\n\t* JavaScript listeners\n\t* Dispatching browser events\n* Lifecycle hooks\n\t* Class hooks\n\t\t* mount\n\t\t* hydrate\n\t\t* boot\n\t\t* dehydrate\n\t\t* update\n* Testing\n\t* Basic test\n        * `artisan make: --test`\n\t* Making a test\n\t* Testing presence\n\t* Passing component data\n\t* Passing query string params","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-10","text":" query string params\n\t* Available commands\n\t* Available assertions\n* AlpineJS\n\t* ...\n* Eloquent Models\n\t* Setting as properties\n\t* Performance implications\n\t* Binding to attributes\n\t* Collections of models","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-11","text":"ollections of models\n\nForms:\n* Form submission\n* Form inputs\n* Input validation\n* File uploads\n\nFeatures:\n* Loading states\n* Pagination\n* Inline scripts\n* Flash messages\n* Query string\n* Redirecting\n* Polling\n* Authorization\n* Dirty states\n* File Downloads\n* Offline states\n* Computed properties\n\nDeep knowledge:\n* How Livewire works\n* Synthesizers","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-12","text":"works\n* Synthesizers\n\nJavaScript Global\n\t* Lifecycle hooks\nComponent abstractions\nArtisan Commands\nTroubleshooting\nSecurity (both internal and userland)\nExtending\n- Custom wireables\nPackage development\nDeployment\nPublishing stubs\nLaravel Echo\nReference\n\nV3:\n* Lazy loading\n* SPA Mode","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-13","text":"y loading\n* SPA Mode\n\n\n* Is this even the place I want to order from?\n* What kind of flowers does mom like?\n* How much money should I spend on them?\n* When should I have them delivered?\n* Do I need to call dad and make sure she will like them?","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-14","text":" she will like them?\n\n\nWhy is writing documentation so hard?\n\n### Words are hard\n\nYeah, but it's more than that. Agreed that words are hard, but I seem to be able to write a blog post no problem.\n\nIt's boring speak catered to the lowest common denominator of reader","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-15","text":"enominator of reader\n\nYeah like I feel like I don't have a voice at all. Like the jokes and meanderings and bold statements I usually like to write with don't belong here. Clarity at all costs belongs here.\n\n### Organizing content is hard\nThere's the \"chicken\" and \"egg\" problem: some content depends on another piece but that piece relies back on the original piece. Which one comes first?","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-16","text":"ich one comes first?\n\nThere's the granularity problem: how much do we want to break this up?\n\nThere's the ordering problem: \"do I go simple to complex? or most real-world to least real-world?\"\n\nThe repetition problem: do you repeat yourself in multiple pages? or isolate one feature to a single file? This one is answered: repeat yourself.","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-17","text":"ed: repeat yourself.\n\n### Code examples are hard\nHow much non-crucial context to include? (include < ?php include class? namespace? use? render?)\n\nHow to make it real-world but cater to exactly the right mechanisms? \"hello world\" and \"counter\" components are helpful but not real-life. But real-life isn't often simple enough.","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-18","text":"often simple enough.\n\nDo you stick with the same domain? \"CreatePost\" the whole time? Is it too jarring to hop around a ton, or is it too predictable, constrained and monotonous to stick with one example the entire time?\n\n### There's a ton of it\nThere's just so much of it, it feels overwhelming","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"526e8308d84195e4e6c62bbfc883781c-19","text":"t feels overwhelming\n\n\n\n\n\n\nHumor:\n* bathtubs\n* silly bands\n* penguins of madagascar\n* Ed Bassmaster\n* Spongebob\n","source":"/Users/fyyx/Documents/livewire/docs/__outline.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-0","text":"\nBecause Livewire components are dehydrated (serialized) into JSON, then hydrated (unserialized) back into PHP components between requests, their properties need to be JSON-serializable.","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-1","text":"e JSON-serializable.\n\nNatively, PHP serializes most primitive values into JSON easily. However, in order for Livewire components to support more sophisticated property types (like models, collections, carbon instances, and stringables), a more robust system is needed.","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-2","text":"st system is needed.\n\nTherefore, Livewire provides a point of extension called \"Synthesizers\" that allow users to support any custom property types they wish.\n\n> [!tip] Make sure you understand hydration first\n> Before using Synthesizers, it's helpful to fully understand Livewire's hydration system. You can learn more by reading the [hydration documentation](/docs/hydration).","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-3","text":"n](/docs/hydration).\n\n## Understanding Synthesizers\n\nBefore exploring the creation of custom Synthesizers, let's first look at the internal Synthesizer that Livewire uses to support [Laravel Stringables](https://laravel.com/docs/strings).\n\nSuppose your application contained the following `CreatePost` component:\n\n```php\nclass CreatePost extends Component\n{\n    public $title = '';\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-4","text":"c $title = '';\n}\n```\n\nBetween requests, Livewire might serialize this component's state into a JSON object like the following:\n\n```js\nstate: { title: '' },\n```\n\nNow, consider a more advanced example where the `$title` property value is a stringable instead of a plain string:\n\n```php\nclass CreatePost extends Component\n{\n    public $title = '';","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-5","text":" public $title = '';\n\n    public function mount()\n    {\n        $this->title = str($this->title);\n    }\n}\n```\n\nThe dehydrated JSON representing this component's state now contains a [metadata tuple](/docs/hydration#deeply-nested-tuples) instead of a plain empty string:\n\n```js\nstate: { title: ['', { s: 'str' }] },\n```","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-6","text":"{ s: 'str' }] },\n```\n\nLivewire can now use this tuple to hydrate the `$title` property back into a stringable on the next request.\n\nNow that you've seen the outside-in effects of Synthesizers, here is the actual source code for Livewire's internal stringable synth:\n\n```php\nuse Illuminate\\Support\\Stringable;\n\nclass StringableSynth extends Synth\n{\n    public static $key = 'str';","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-7","text":"static $key = 'str';\n\n    public static function match($target)\n    {\n        return $target instanceof Stringable;\n    }\n\n    public function dehydrate($target)\n    {\n        return [$target->__toString(), []];\n    }\n\n    public function hydrate($value)\n    {\n        return str($value);\n    }\n}\n```\n\nLet's break this down piece by piece.\n\nFirst is the `$key` property:","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-8","text":"the `$key` property:\n\n```php\npublic static $key = 'str';\n```\n\nEvery synth must contain a static `$key` property that Livewire uses to convert a [metadata tuple](/docs/hydration#deeply-nested-tuples) like `['', { s: 'str' }]` back into a stringable. As you may notice, each metadata tuple has an `s` key referencing this key.","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-9","text":"eferencing this key.\n\nInversely, when Livewire is dehydrating a property, it will use the synth's static `match()` function to identify if this particular Synthesizer is a good candidate to dehydrate the current property (`$target` being the current value of the property):\n\n```php\npublic static function match($target)\n{\n    return $target instanceof Stringable;\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-10","text":"of Stringable;\n}\n```\n\nIf `match()` returns true, the `dehydrate()` method will be used to take the property's PHP value as input and return the JSONable [metadata](/docs/hydration#deeply-nested-tuples) tuple:\n\n```php\npublic function dehydrate($target)\n{\n    return [$target->__toString(), []];\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-11","text":"String(), []];\n}\n```\n\nNow, at the beginning of the next request, after this Synthesizer has been matched by the `{ s: 'str' }` key in the tuple, the `hydrate()` method will be called and passed the raw JSON representation of the property with the expectation that it returns the full PHP-compatible value to be assigned to the property.","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-12","text":"ned to the property.\n\n```php\npublic function hydrate($value)\n{\n    return str($value);\n}\n```\n\n## Registering a custom Synthesizer\n\nTo demonstrate how you might author your own Synthesizer to support a custom property, we will use the following `UpdateProperty` component as an example:\n\n```php\nclass UpdateProperty extends Component\n{\n    public Address $address;","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-13","text":"ic Address $address;\n\n    public function mount()\n    {\n        $this->address = new Address();\n    }\n}\n```\n\nHere's the source for the `Address` class:\n\n```php\nnamespace App\\Dtos\\Address;\n\nclass Address\n{\n    public $street = '';\n    public $city = '';\n    public $state = '';\n    public $zip = '';\n}\n```\n\nTo support properties of type `Address`, we can use the following Synthesizer:","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-14","text":"llowing Synthesizer:\n\n```php\nuse App\\Dtos\\Address;\n\nclass AddressSynth extends Synth\n{\n    public static $key = 'address';\n\n    public static function match($target)\n    {\n        return $target instanceof Address;\n    }","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-15","text":"nceof Address;\n    }\n\n    public function dehydrate($target)\n    {\n        return [[\n            'street' => $target->street,\n            'city' => $target->city,\n            'state' => $target->state,\n            'zip' => $target->zip,\n        ], []];\n    }\n\n    public function hydrate($value)\n    {\n        $instance = new Address;","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-16","text":"tance = new Address;\n\n        $instance->street = $value['street'];\n        $instance->city = $value['city'];\n        $instance->state = $value['state'];\n        $instance->zip = $value['zip'];\n\n        return $instance;\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-17","text":"nstance;\n    }\n}\n```\n\nTo make it available globally in your application, you can use Livewire's `propertySynthesizer` method to register the synthesizer from your service provider boot method:","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-18","text":"rovider boot method:\n\n```php\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Bootstrap any application services.\n     */\n    public function boot(): void\n    {\n        Livewire::propertySynthesizer(AddressSynth::class);\n    }\n}\n```\n\n## Supporting data binding","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-19","text":"porting data binding\n\nUsing the `UpdateProperty` example from above, it is likely that you would want to support `wire:model` binding directly to properties of the `Address` object. Synthesizers allow you to support this using the `get()` and `set()` methods:\n\n```php\nuse App\\Dtos\\Address;\n\nclass AddressSynth extends Synth\n{\n    public static $key = 'address';","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-20","text":"ic $key = 'address';\n\n    public static function match($target)\n    {\n        return $target instanceof Address;\n    }\n\n    public function dehydrate($target)\n    {\n        return [[\n            'street' => $target->street,\n            'city' => $target->city,\n            'state' => $target->state,\n            'zip' => $target->zip,\n        ], []];\n    }","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-21","text":"       ], []];\n    }\n\n    public function hydrate($value)\n    {\n        $instance = new Address;\n\n        $instance->street = $value['street'];\n        $instance->city = $value['city'];\n        $instance->state = $value['state'];\n        $instance->zip = $value['zip'];\n\n        return $instance;\n    }","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"cfe7b083e09ab0acd9950a546efda3cd-22","text":"urn $instance;\n    }\n\n    public function get(&$target, $key) // [tl! highlight:8]\n    {\n        return $target->{$key};\n    }\n\n    public function set(&$target, $key, $value)\n    {\n        $target->{$key} = $value;\n    }\n}\n```\n","source":"/Users/fyyx/Documents/livewire/docs/synthesizers.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-0","text":"\nLoading indicators are an important part of crafting good user interfaces. They give users visual feedback when a request is being made to the server, so they know they are waiting for a process to complete.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-1","text":"ete.\n\n## Basic usage\n\nLivewire provides a simple yet extremely powerful syntax for controlling loading indicators: `wire:loading`. Adding `wire:loading` to any element will hide it by default (using `display: none` in CSS) and show it when a request is sent to the server.\n\nBelow is a basic example of a `CreatePost` component's form with `wire:loading` being used to toggle a loading message:","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-2","text":"e a loading message:\n\n```blade\n<form wire:submit=\"save\">\n    <!-- ... -->\n\n    <button type=\"submit\">Save</button>\n\n    <div wire:loading> <!-- [tl! highlight:2] -->\n        Saving post...\n    </div>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-3","text":"  </div>\n</form>\n```\n\nWhen a user presses \"Save\", the \"Saving post...\" message will appear below the button while the \"save\" action is being executed. The message will disappear when the response is received from the server and processed by Livewire.\n\n### Removing elements","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-4","text":"## Removing elements\n\nAlternatively, you can append `.remove` for the inverse effect, showing an element by default and hiding it during requests to the server:\n\n```blade\n<div wire:loading.remove>...</div>\n```\n\n## Toggling classes","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-5","text":"\n## Toggling classes\n\nIn addition to toggling the visibility of entire elements, it's often useful to change the styling of an existing element by toggling CSS classes on and off during requests to the server. This technique can be used for things like changing background colors, lowering opacity, triggering spinning animations, and more.","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-6","text":"nimations, and more.\n\nBelow is a simple example of using the [Tailwind](https://tailwindcss.com/) class `opacity-50` to make the \"Save\" button fainter while the form is being submitted:\n\n```blade\n<button wire:loading.class=\"opacity-50\">Save</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-7","text":"0\">Save</button>\n```\n\nLike toggling an element, you can perform the inverse class operation by appending `.remove` to the `wire:loading` directive. In the example below, the button's `bg-blue-500` class will be removed when the \"Save\" button is pressed:\n\n```blade\n<button class=\"bg-blue-500\" wire:loading.class.remove=\"bg-blue-500\">\n    Save\n</button>\n```\n\n## Toggling attributes","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-8","text":" Toggling attributes\n\nBy default, when a form is submitted, Livewire will automatically disable the submit button and add the `readonly` attribute to each input element while the form is being processed.","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-9","text":" is being processed.\n\nHowever, in addition to this default behavior, Livewire offers the `.attr` modifier to allow you to toggle other attributes on an element or toggle attributes on elements that are outside of forms:\n\n```blade\n<button\n    type=\"button\"\n    wire:click=\"remove\"\n    wire:loading.attr=\"disabled\"\n>\n    Remove\n</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-10","text":"Remove\n</button>\n```\n\nBecause the button above isn't a submit button, it won't be disabled by Livewire's default form handling behavior when pressed. Instead, we manually added `wire:loading.attr=\"disabled\"` to achieve this behavior.\n\n## Targeting specific actions\n\nBy default, `wire:loading` will be triggered whenever a component makes a request to the server.","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-11","text":"quest to the server.\n\nHowever, in components with multiple elements that can trigger server requests, you should scope your loading indicators down to individual actions.\n\nFor example, consider the following \"Save post\" form. In addition to a \"Save\" button that submits the form, there might also be a \"Remove\" button that executes a \"remove\" action on the component.","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-12","text":"on on the component.\n\nBy adding `wire:target` to the following `wire:loading` element, you can instruct Livewire to only show the loading message when the \"Remove\" button is clicked:\n\n```blade\n<form wire:submit=\"save\">\n    <!-- ... -->\n\n    <button type=\"submit\">Save</button>\n\n    <button type=\"button\" wire:click=\"remove\">Remove</button>","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-13","text":"ove\">Remove</button>\n\n    <div wire:loading wire:target=\"remove\">  <!-- [tl! highlight:2] -->\n        Removing post...\n    </div>\n</form>\n```\n\nWhen the above \"Remove\" button is pressed, the \"Removing post...\" message will be displayed to the user. However, the message will not be displayed when the \"Save\" button is pressed.\n\n### Targeting multiple actions","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-14","text":"ing multiple actions\n\nYou may find yourself in a situation where you would like `wire:loading` to react to some, but not all, actions on a page. In these cases you can pass multiple actions into `wire:target` separated by a comma. For example:\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"text\" wire:model.blur=\"title\">\n\n    <!-- ... -->\n\n    <button type=\"submit\">Save</button>","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-15","text":"ubmit\">Save</button>\n\n    <button type=\"button\" wire:click=\"remove\">Remove</button>\n\n    <div wire:loading wire:target=\"save, remove\">  <!-- [tl! highlight:2] -->\n        Updating post...\n    </div>\n</form>\n```\n\nThe loading indicator (\"Updating post...\") will now only be shown when the \"Remove\" or \"Save\" button are pressed, and not when the `$title` field is being sent to the server.","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-16","text":" sent to the server.\n\n### Targeting action parameters\n\nIn situations where the same action is triggered with different parameters from multiple places on a page, you can further scope `wire:target` to a specific action by passing in additional parameters. For example, consider the following scenario where a \"Remove\" button exists for each post on the page:","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-17","text":"ch post on the page:\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <div wire:key=\"{{ $post->id }}\">\n            <h2>{{ $post->title }}</h2>\n\n            <button wire:click=\"remove({{ $post->id }})\">Remove</button>","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-18","text":"}})\">Remove</button>\n\n            <div wire:loading wire:target=\"remove({{ $post->id }})\">  <!-- [tl! highlight:2] -->\n                Removing post...\n            </div>\n        </div>\n    @endforeach\n</div>\n```\n\nWithout passing `{{ $post->id }}` to `wire:target=\"remove\"`, the \"Removing post...\" message would show when any of the buttons on the page are clicked.","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-19","text":"he page are clicked.\n\nHowever, because we are passing in unique parameters to each instance of `wire:target`, Livewire will only show the loading message when the matching parameters are passed to the \"remove\" action.","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-20","text":"the \"remove\" action.\n\n> [!warning] Multiple action parameters aren't supported\n> At this time, Livewire only supports targeting a loading indicator by a single method/parameter pair. For example `wire:target=\"remove(1)\"` is supported, however `wire:target=\"remove(1), add(1)\"` is not.\n\n### Targeting property updates","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-21","text":"ing property updates\n\nLivewire also allows you to target specific component property updates by passing the property's name to the `wire:target` directive.\n\nConsider the following example where a form input named `username` uses `wire:model.live` for real-time validation as a user types:","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-22","text":"ion as a user types:\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"text\" wire:model.live=\"username\">\n    @error('username') <span>{{ $message }}</span> @enderror\n\n    <div wire:loading wire:target=\"username\"> <!-- [tl! highlight:2] -->\n        Checking availability of username...\n    </div>\n\n    <!-- ... -->\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-23","text":" ... -->\n</form>\n```\n\nThe \"Checking availability...\" message will show when the server is updated with the new username as the user types into the input field.\n\n### Excluding specific loading targets\n\nSometimes you may wish to display a loading indicator for every Livewire request _except_ a specific property or action. In these cases you can use the `wire:target.except` modifier like so:","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-24","text":"t` modifier like so:\n\n```blade\n<div wire:loading wire:target.except=\"download\">...</div>\n```\n\nThe above loading indicator will now be shown for every Livewire update request on the component _except_ the \"download\" action.\n\n## Customizing CSS display property","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-25","text":"CSS display property\n\nWhen `wire:loading` is added to an element, Livewire updates the CSS `display` property of the element to show and hide the element. By default, Livewire uses `none` to hide and `inline-block` to show.\n\nIf you are toggling an element that uses a display value other than `inline-block`, like `flex` in the following example, you can append `.flex` to `wire:loading`:","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-26","text":"` to `wire:loading`:\n\n```blade\n<div class=\"flex\" wire:loading.flex>...</div>\n```\n\nBelow is the complete list of available display values:\n\n```blade\n<div wire:loading.inline-flex>...</div>\n<div wire:loading.inline>...</div>\n<div wire:loading.block>...</div>\n<div wire:loading.table>...</div>\n<div wire:loading.flex>...</div>\n<div wire:loading.grid>...</div>\n```\n\n## Delaying a loading indicator","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-27","text":" a loading indicator\n\nOn fast connections, updates often happen so quickly that loading indicators only flash briefly on the screen before being removed. In these cases, the indicator is more of a distraction than a helpful affordance.\n\nFor this reason, Livewire provides a `.delay` modifier to delay the showing of an indicator. For example, if you add `wire:loading.delay` to an element like so:","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-28","text":" an element like so:\n\n```blade\n<div wire:loading.delay>...</div>\n```\n\nThe above element will only appear if the request takes over 200 milliseconds. The user will never see the indicator if the request completes before then.\n\nTo customize the amount of time to delay the loading indicator, you can use one of Livewire's helpful interval aliases:","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-29","text":"ul interval aliases:\n\n```blade\n<div wire:loading.delay.shortest>...</div> <!-- 50ms -->\n<div wire:loading.delay.shorter>...</div>  <!-- 100ms -->\n<div wire:loading.delay.short>...</div>    <!-- 150ms -->\n<div wire:loading.delay>...</div>          <!-- 200ms -->\n<div wire:loading.delay.long>...</div>     <!-- 300ms -->\n<div wire:loading.delay.longer>...</div>   <!-- 500ms -->","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"78220e6dddeabb8037d14d084b19fd33-30","text":"iv>   <!-- 500ms -->\n<div wire:loading.delay.longest>...</div>  <!-- 1000ms -->\n```\n","source":"/Users/fyyx/Documents/livewire/docs/wire-loading.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-0","text":"\nLike many other component-based frameworks, Livewire components are nestable — meaning one component can render multiple components within itself.\n\nHowever, because Livewire's nesting system is built differently than other frameworks, there are certain implications and constraints that are important to be aware of.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-1","text":"tant to be aware of.\n\n> [!tip] Make sure you understand hydration first\n> Before learning more about Livewire's nesting system, it's helpful to fully understand how Livewire hydrates components. You can learn more by reading the [hydration documentation](/docs/hydration).\n\n## Every component is an island","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-2","text":"mponent is an island\n\nIn Livewire, every component on a page tracks its state and makes updates independently of other components.\n\nFor example, consider the following `Posts` and nested `ShowPost` components:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\n\nclass Posts extends Component\n{\n    public $postLimit = 2;","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-3","text":"blic $postLimit = 2;\n\n    public function render()\n    {\n        return view('livewire.posts', [\n            'posts' => Auth::user()->posts()\n                ->limit($this->postLimit)->get(),\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    Post Limit: <input type=\"number\" wire:model.live=\"postLimit\">","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-4","text":"el.live=\"postLimit\">\n\n    @foreach ($posts as $post)\n        <livewire:show-post :$post :key=\"$post->id\">\n    @endforeach\n</div>\n```\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPost extends Component\n{\n    public Post $post;","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-5","text":"  public Post $post;\n\n    public function render()\n    {\n        return view('livewire.show-post');\n    }\n}\n```\n\n```blade\n<div>\n    <h1>{{ $post->title }}</h1>\n\n    <p>{{ $post->content }}</p>\n\n    <button wire:click=\"$refresh\">Refresh post</button>\n</div>\n```\n\nHere's what the HTML for the entire component tree might look like on initial page load:","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-6","text":"n initial page load:\n\n```html\n<div wire:id=\"123\" wire:snapshot=\"...\">\n    Post Limit: <input type=\"number\" wire:model.live=\"postLimit\">\n\n    <div wire:id=\"456\" wire:snapshot=\"...\">\n        <h1>The first post</h1>\n\n        <p>Post content</p>\n\n        <button wire:click=\"$refresh\">Refresh post</button>\n    </div>\n\n    <div wire:id=\"789\" wire:snapshot=\"...\">\n        <h1>The second post</h1>","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-7","text":"The second post</h1>\n\n        <p>Post content</p>\n\n        <button wire:click=\"$refresh\">Refresh post</button>\n    </div>\n</div>\n```\n\nNotice that the parent component contains both its rendered template and the rendered templates of all the components nested within it.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-8","text":"ts nested within it.\n\nBecause each component is independent, they each have their own IDs and snapshots (`wire:id` and `wire:snapshot`) embedded in their HTML for Livewire's JavaScript core to extract and track.\n\nLet's consider a few different update scenarios to see the differences in how Livewire handles different levels of nesting.\n\n### Updating a child","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-9","text":"### Updating a child\n\nIf you were to click the \"Refresh post\" button in one of the child `show-post` components, here is what would be sent to the server:\n\n```js\n{\n    memo: { name: 'show-post', id: '456' },\n\n    state: { ... },\n}\n```\n\nHere's the HTML that would get sent back:\n\n```html\n<div wire:id=\"456\">\n    <h1>The first post</h1>\n\n    <p>Post content</p>","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-10","text":" <p>Post content</p>\n\n    <button wire:click=\"$refresh\">Refresh post</button>\n</div>\n```\n\nThe important thing to note here is that when an update is triggered on a child component, only that component's data is sent to the server, and only that component is re-rendered.\n\nNow let's look at the less intuitive scenario: updating a parent component.\n\n### Updating the parent","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-11","text":" Updating the parent\n\nAs a reminder, here's the Blade template of the parent `Posts` component:\n\n```blade\n<div>\n    Post Limit: <input type=\"number\" wire:model.live=\"postLimit\">\n\n    @foreach ($posts as $post)\n        <livewire:show-post :$post :key=\"$post->id\">\n    @endforeach\n</div>\n```\n\nIf a user changes the \"Post Limit\" value from `2` to `1`, an update will be solely triggered on the parent.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-12","text":"gered on the parent.\n\nHere's an example of what the request payload might look like:\n\n```js\n{\n    updates: { postLimit: 1 },\n\n    snapshot: {\n        memo: { name: 'posts', id: '123' },\n\n        state: { postLimit: 2, ... },\n    },\n}\n```\n\nAs you can see, only the snapshot for the parent `Posts` component is sent along to the server.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-13","text":"along to the server.\n\nAn important question you might be asking yourself is: what happens when the parent component re-renders and encounters the child `show-post` components? How will it re-render the children if their snapshots haven't been included in the request payload?\n\nThe answer is: they won't be re-rendered.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-14","text":"on't be re-rendered.\n\nWhen Livewire renders the `Posts` component, it will render placeholders for any child components it encounters.\n\nHere is an example of what the rendered HTML for the `Posts` component might be after the above update:\n\n```html\n<div wire:id=\"123\">\n    Post Limit: <input type=\"number\" wire:model.live=\"postLimit\">\n\n    <div wire:id=\"456\"></div>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-15","text":"6\"></div>\n</div>\n```\n\nAs you can see, only one child has been rendered because `postLimit` was updated to `1`. However, you will also notice that instead of the full child component, there is only an empty `<div></div>` with the matching `wire:id` attribute.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-16","text":"`wire:id` attribute.\n\nWhen this HTML is received on the frontend, Livewire will _morph_ the old HTML for this component into this new HTML, but intelligently skip any child component placeholders.\n\nThe effect is that, after _morphing_, the final DOM content of the parent `Posts` component will be the following:","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-17","text":"ll be the following:\n\n```html\n<div wire:id=\"123\">\n    Post Limit: <input type=\"number\" wire:model.live=\"postLimit\">\n\n    <div wire:id=\"456\">\n        <h1>The first post</h1>\n\n        <p>Post content</p>\n\n        <button wire:click=\"$refresh\">Refresh post</button>\n    </div>\n</div>\n```\n\n## Performance implications","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-18","text":"ormance implications\n\nLivewire's \"island\" architecture can have both positive and negative implications for your application.\n\nAn advantage of this architecture is it allows you to isolate expensive portions of your application. For example, you can quarantine a slow database query to its own independent component, and its performance overhead won't impact the rest of the page.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-19","text":"he rest of the page.\n\nHowever, the biggest drawback of this approach is that because components are entirely separate, inter-component communication/dependencies becomes more difficult.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-20","text":"omes more difficult.\n\nFor example, if you had a property passed down from the above parent `Posts` component to the nested `ShowPost` component, it wouldn't be \"reactive\". Because each component is an island, if a request to the parent component changed the value of the property being passed into `ShowPost`, it wouldn't update inside `ShowPost`.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-21","text":"e inside `ShowPost`.\n\nLivewire has overcome a number of these hurdles and provides dedicated APIs for these scenarios like: [Reactive properties](/docs/nesting#reactive-props), [Modelable components](/docs/nesting#binding-to-child-data-using-wiremodel), and [the `$parent` object](/docs/nesting#directly-accessing-the-parent-from-the-child).","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-22","text":"ent-from-the-child).\n\nArmed with this knowledge of how nested Livewire components operate, you will be able to make more informed decisions about when and how to nest components within your application.","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"9547f834a0368c4cf6b1a8aa804b439c-23","text":"in your application.\n\n\n\n","source":"/Users/fyyx/Documents/livewire/docs/understanding-nesting.md"}
{"id":"21162b451464a060a2ababa1c86a8418-0","text":"\nUsing Livewire feels like attaching a server-side PHP class directly to a web browser. Things like calling server-side functions directly from button presses support this illusion. But in reality, it is just that: an illusion.","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-1","text":"t that: an illusion.\n\nIn the background, Livewire actually behaves much more like a standard web application. It renders static HTML to the browser, listens for browser events, then makes AJAX requests to invoke server-side code.","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-2","text":"ke server-side code.\n\nBecause each AJAX request Livewire makes to the server is \"stateless\" (meaning there isn't a long running backend process keeping the state of a component alive), Livewire must re-create the last-known state of a component before making any updates.","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-3","text":" making any updates.\n\nIt does this by taking \"snapshots\" of the PHP component after each server-side update so that the component can be re-created or _resumed_ on the next request.\n\nThroughout this documentation, we will refer to the process of taking the snapshot as \"dehydration\" and the process of re-creating a component from a snapshot as \"hydration\".\n\n## Dehydrating","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-4","text":"on\".\n\n## Dehydrating\n\nWhen Livewire _dehydrates_ a server-side component, it does two things:\n\n* Renders the component's template to HTML\n* Creates a JSON snapshot of the component\n\n### Rendering HTML\n\nAfter a component is mounted or an update has been made, Livewire calls a component's `render()` method to convert the Blade template to raw HTML.","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-5","text":"emplate to raw HTML.\n\nTake the following `Counter` component for example:\n\n```php\nclass Counter extends Component\n{\n    public $count = 1;\n\n    public function increment()\n    {\n        $this->count++;\n    }\n\n    public function render()\n    {\n        return <<<'HTML'\n        <div>\n            Count: {{ $count }}","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-6","text":" Count: {{ $count }}\n\n            <button wire:click=\"increment\">+</button>\n        </div>\n        HTML;\n    }\n}\n```\n\nAfter each mount or update, Livewire would render the above `Counter` component to the following HTML:\n\n```html\n<div>\n    Count: 1\n\n    <button wire:click=\"increment\">+</button>\n</div>\n```\n\n### The snapshot","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-7","text":"``\n\n### The snapshot\n\nIn order to re-create the `Counter` component on the server during the next request, a JSON snapshot is created, attempting to capture as much of the state of the component as possible:\n\n```js\n{\n    state: {\n        count: 1,\n    },\n\n    memo: {\n        name: 'counter',\n\n        id: '1526456',\n    },\n}\n```\n\nNotice two different portions of the snapshot: `memo`, and `state`.","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-8","text":"`memo`, and `state`.\n\nThe `memo` portion is used to store the information needed to identify and re-create the component, while the `state` portion stores the values of all the component's public properties.","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-9","text":"s public properties.\n\n> [!info]\n> The above snapshot is a condensed version of an actual snapshot in Livewire. In live applications, the snapshot contains much more information, such as validation errors, a list of child components, locales, and much more. For a more detailed look at a snapshot object you may reference the [snapshot schema documentation](/docs/javascript#the-snapshot-object).","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-10","text":"he-snapshot-object).\n\n### Embedding the snapshot in the HTML\n\nWhen a component is first rendered, Livewire stores the snapshot as JSON inside an HTML attribute called `wire:snapshot`. This way, Livewire's JavaScript core can extract the JSON and turn it into a run-time object:\n\n```html\n<div wire:id=\"...\" wire:snapshot=\"{ state: {...}, memo: {...} }\">\n    Count: 1","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-11","text":"..} }\">\n    Count: 1\n\n    <button wire:click=\"increment\">+</button>\n</div>\n```\n\n## Hydrating\n\nWhen a component update is triggered, for example, the \"+\" button is pressed in the `Counter` component, a payload like the following is sent to the server:\n\n```js\n{\n    calls: [\n        { method: 'increment', params: [] },\n    ],\n\n    snapshot: {\n        state: {\n            count: 1,\n        },","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-12","text":"count: 1,\n        },\n\n        memo: {\n            name: 'counter',\n\n            id: '1526456',\n        },\n    }\n}\n```\n\nBefore Livewire can call the `increment` method, it must first create a new `Counter` instance and seed it with the snapshot's state.\n\nHere is some PHP pseudo-code that achieves this result:\n\n```php\n$state = request('snapshot.state');\n$memo = request('snapshot.memo');","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-13","text":"st('snapshot.memo');\n\n$instance = Livewire::new($memo['name'], $memo['id']);\n\nforeach ($state as $property => $value) {\n    $instance[$property] = $value;\n}\n```\n\nIf you follow the above script, you will see that after creating a `Counter` object, its public properties are set based on the state provided from the snapshot.\n\n## Advanced hydration","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-14","text":"# Advanced hydration\n\nThe above `Counter` example works well to demonstrate the concept of hydration; however, it only demonstrates how Livewire handles hydrating simple values like integers (`1`).\n\nAs you may know, Livewire supports many more sophisticated property types beyond integers.\n\nLet's take a look at a slightly more complex example - a `Todos` component:","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-15","text":"a `Todos` component:\n\n```php\nclass Todos extends Component\n{\n    public $todos;\n\n    public function mount() {\n        $this->todos = collect([\n            'first',\n            'second',\n            'third',\n        ]);\n    }\n}\n```\n\nAs you can see, we are setting the `$todos` property to a [Laravel collection](https://laravel.com/docs/collections#main-content) with three strings as its content.","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-16","text":"ings as its content.\n\nJSON alone has no way of representing Laravel collections, so instead, Livewire has created its own pattern of associating metadata with pure data inside a snapshot.\n\nHere is the snapshot's state object for this `Todos` component:","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-17","text":"s `Todos` component:\n\n```js\nstate: {\n    todos: [\n        [ 'first', 'second', 'third' ],\n        { s: 'clctn', class: 'Illuminate\\\\Support\\\\Collection' },\n    ],\n},\n```\n\nThis may be confusing to you if you were expecting something more straightforward like:\n\n```js\nstate: {\n    todos: [ 'first', 'second', 'third' ],\n},\n```","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-18","text":"', 'third' ],\n},\n```\n\nHowever, if Livewire were hydrating a component based on this data, it would have no way of knowing it's a collection and not a plain array.\n\nTherefore, Livewire supports an alternate state syntax in the form of a tuple (an array of two items):\n\n```js\ntodos: [\n    [ 'first', 'second', 'third' ],\n    { s: 'clctn', class: 'Illuminate\\\\Support\\\\Collection' },\n],\n```","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-19","text":"ollection' },\n],\n```\n\nWhen Livewire encounters a tuple when hydrating a component's state, it uses information stored in the second element of the tuple to more intelligently hydrate the state stored in the first.\n\nTo demonstrate more clearly, here is simplified code showing how Livewire might re-create a collection property based on the above snapshot:","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-20","text":" the above snapshot:\n\n```php\n[ $state, $metadata ] = request('snapshot.state.todos');\n\n$collection = new $metadata['class']($state);\n```\n\nAs you can see, Livewire uses the metadata associated with the state to derive the full collection class.\n\n### Deeply nested tuples\n\nOne distinct advantage of this approach is the ability to dehydrate and hydrate deeply nested properties.","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-21","text":"y nested properties.\n\nFor example, consider the above `Todos` example, except now with a [Laravel Stringable](https://laravel.com/docs/helpers#method-str) instead of a plain string as the third item in the collection:\n\n```php\nclass Todos extends Component\n{\n    public $todos;","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-22","text":"{\n    public $todos;\n\n    public function mount() {\n        $this->todos = collect([\n            'first',\n            'second',\n            str('third'),\n        ]);\n    }\n}\n```\n\nThe dehydrated snapshot for this component's state would now look like this:","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-23","text":" now look like this:\n\n```js\ntodos: [\n    [\n        'first',\n        'second',\n        [ 'third', { s: 'str' } ],\n    ],\n    { s: 'clctn', class: 'Illuminate\\\\Support\\\\Collection' },\n],\n```","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-24","text":"ollection' },\n],\n```\n\nAs you can see, the third item in the collection has been dehydrated into a metadata tuple. The first element in the tuple being the plain string value, and the second being a flag denoting to Livewire that this string is a _stringable_.\n\n### Supporting custom property types","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"21162b451464a060a2ababa1c86a8418-25","text":"ustom property types\n\nInternally, Livewire has hydration support for the most common PHP and Laravel types. However, if you wish to support un-supported types, you can do so using [Synthesizers](/docs/synthesizers) — Livewire's internal mechanism for hydrating/dehydrating non-primitive property types.\n\n","source":"/Users/fyyx/Documents/livewire/docs/hydration.md"}
{"id":"efc168bf918eb8fe07a9e5d56d68c62f-0","text":"\n`wire:text` is a directive that dynamically updates an element's text content based on a component property or expression. Unlike using Blade's `{{ }}` syntax, `wire:text` updates the content without requiring a network roundtrip to re-render the component.\n\nIf you are familiar with Alpine's `x-text` directive, the two are essentially the same.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/wire-text.md"}
{"id":"efc168bf918eb8fe07a9e5d56d68c62f-1","text":"ame.\n\n## Basic usage\n\nHere's an example of using `wire:text` to optimistically show updates to a Livewire property without waiting for a network roundtrip.\n\n```php\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPost extends Component\n{\n    public Post $post;\n\n    public $likes;\n\n    public function mount()\n    {\n        $this->likes = $this->post->like_count;\n    }","source":"/Users/fyyx/Documents/livewire/docs/wire-text.md"}
{"id":"efc168bf918eb8fe07a9e5d56d68c62f-2","text":"t->like_count;\n    }\n\n    public function like()\n    {\n        $this->post->like();\n\n        $this->likes = $this->post->fresh()->like_count;\n    }\n}\n```\n\n```blade\n<div>\n    <button x-on:click=\"$wire.likes++\" wire:click=\"like\">❤️ Like</button>\n\n    Likes: <span wire:text=\"likes\"></span>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-text.md"}
{"id":"efc168bf918eb8fe07a9e5d56d68c62f-3","text":"\"></span>\n</div>\n```\n\nWhen the button is clicked, `$wire.likes++` immediately updates the displayed count through `wire:text`, while `wire:click=\"like\"` persists the change to the database in the background.\n\nThis pattern makes `wire:text` perfect for building optimistic UIs in Livewire.\n","source":"/Users/fyyx/Documents/livewire/docs/wire-text.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-0","text":"Because forms are the backbone of most web applications, Livewire provides loads of helpful utilities for building them. From handling simple input elements to complex things like real-time validation or file uploading, Livewire has simple, well-documented tools to make your life easier and delight your users.\n\nLet's dive in.\n\n## Submitting a form","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-1","text":"## Submitting a form\n\nLet's start by looking at a very simple form in a `CreatePost` component. This form will have two simple text inputs and a submit button, as well as some code on the backend to manage the form's state and submission:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    public $title = '';","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-2","text":" public $title = '';\n\n    public $content = '';\n\n    public function save()\n    {\n        Post::create(\n            $this->only(['title', 'content'])\n        );\n\n        session()->flash('status', 'Post successfully updated.');\n\n        return $this->redirect('/posts');\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-3","text":"-post');\n    }\n}\n```\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"text\" wire:model=\"title\">\n\n    <input type=\"text\" wire:model=\"content\">\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\nAs you can see, we are \"binding\" the public `$title` and `$content` properties in the form above using `wire:model`. This is one of the most commonly used and powerful features of Livewire.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-4","text":"eatures of Livewire.\n\nIn addition to binding `$title` and `$content`, we are using `wire:submit` to capture the `submit` event when the \"Save\" button is clicked and invoking the `save()` action. This action will persist the form input to the database.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-5","text":"put to the database.\n\nAfter the new post is created in the database, we redirect the user to the `ShowPosts` component page and show them a \"flash\" message that the new post was created.\n\n### Adding validation\n\nTo avoid storing incomplete or dangerous user input, most forms need some sort of input validation.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-6","text":"of input validation.\n\nLivewire makes validating your forms as simple as adding `#[Validate]` attributes above the properties you want to be validated.\n\nOnce a property has a `#[Validate]` attribute attached to it, the validation rule will be applied to the property's value any time it's updated server-side.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-7","text":"updated server-side.\n\nLet's add some basic validation rules to the `$title` and `$content` properties in our `CreatePost` component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Attributes\\Validate; // [tl! highlight]\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    #[Validate('required')] // [tl! highlight]\n    public $title = '';","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-8","text":" public $title = '';\n\n    #[Validate('required')] // [tl! highlight]\n    public $content = '';\n\n    public function save()\n    {\n        $this->validate(); // [tl! highlight]\n\n        Post::create(\n            $this->only(['title', 'content'])\n        );\n\n        return $this->redirect('/posts');\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-9","text":"-post');\n    }\n}\n```\n\nWe'll also modify our Blade template to show any validation errors on the page.\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"text\" wire:model=\"title\">\n    <div>\n        @error('title') <span class=\"error\">{{ $message }}</span> @enderror <!-- [tl! highlight] -->\n    </div>","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-10","text":"ight] -->\n    </div>\n\n    <input type=\"text\" wire:model=\"content\">\n    <div>\n        @error('content') <span class=\"error\">{{ $message }}</span> @enderror <!-- [tl! highlight] -->\n    </div>\n\n    <button type=\"submit\">Save</button>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-11","text":"/button>\n</form>\n```\n\nNow, if the user tries to submit the form without filling in any of the fields, they will see validation messages telling them which fields are required before saving the post.\n\nLivewire has a lot more validation features to offer. For more information, visit our [dedicated documentation page on Validation](/docs/validation).\n\n### Extracting a form object","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-12","text":"acting a form object\n\nIf you are working with a large form and prefer to extract all of its properties, validation logic, etc., into a separate class, Livewire offers form objects.\n\nForm objects allow you to re-use form logic across components and provide a nice way to keep your component class cleaner by grouping all form-related code into a separate class.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-13","text":"to a separate class.\n\nYou can either create a form class by hand or use the convenient artisan command:\n\n```shell\nphp artisan livewire:form PostForm\n```\n\nThe above command will create a file called `app/Livewire/Forms/PostForm.php`.\n\nLet's rewrite the `CreatePost` component to use a `PostForm` class:\n\n```php\n<?php\n\nnamespace App\\Livewire\\Forms;\n\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Form;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-14","text":";\nuse Livewire\\Form;\n\nclass PostForm extends Form\n{\n    #[Validate('required|min:5')]\n    public $title = '';\n\n    #[Validate('required|min:5')]\n    public $content = '';\n}\n```\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Livewire\\Forms\\PostForm;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    public PostForm $form; // [tl! highlight]","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-15","text":"; // [tl! highlight]\n\n    public function save()\n    {\n        $this->validate();\n\n        Post::create(\n            $this->form->only(['title', 'content']) // [tl! highlight]\n        );\n\n        return $this->redirect('/posts');\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-16","text":"-post');\n    }\n}\n```\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"text\" wire:model=\"form.title\">\n    <div>\n        @error('form.title') <span class=\"error\">{{ $message }}</span> @enderror\n    </div>\n\n    <input type=\"text\" wire:model=\"form.content\">\n    <div>\n        @error('form.content') <span class=\"error\">{{ $message }}</span> @enderror\n    </div>","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-17","text":"@enderror\n    </div>\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\nIf you'd like, you can also extract the post creation logic into the form object like so:\n\n```php\n<?php\n\nnamespace App\\Livewire\\Forms;\n\nuse Livewire\\Attributes\\Validate;\nuse App\\Models\\Post;\nuse Livewire\\Form;\n\nclass PostForm extends Form\n{\n    #[Validate('required|min:5')]\n    public $title = '';","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-18","text":" public $title = '';\n\n    #[Validate('required|min:5')]\n    public $content = '';\n\n    public function store() // [tl! highlight:5]\n    {\n        $this->validate();\n\n        Post::create($this->only(['title', 'content']));\n    }\n}\n```\n\nNow you can call `$this->form->store()` from the component:\n\n```php\nclass CreatePost extends Component\n{\n    public PostForm $form;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-19","text":"blic PostForm $form;\n\n    public function save()\n    {\n        $this->form->store(); // [tl! highlight]\n\n        return $this->redirect('/posts');\n    }\n\n    // ...\n}\n```\n\nIf you want to use this form object for both a create and update form, you can easily adapt it to handle both use cases.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-20","text":"ndle both use cases.\n\nHere's what it would look like to use this same form object for an `UpdatePost` component and fill it with initial data:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Livewire\\Forms\\PostForm;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass UpdatePost extends Component\n{\n    public PostForm $form;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-21","text":"blic PostForm $form;\n\n    public function mount(Post $post)\n    {\n        $this->form->setPost($post);\n    }\n\n    public function save()\n    {\n        $this->form->update();\n\n        return $this->redirect('/posts');\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```\n\n```php\n<?php\n\nnamespace App\\Livewire\\Forms;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-22","text":" App\\Livewire\\Forms;\n\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Form;\nuse App\\Models\\Post;\n\nclass PostForm extends Form\n{\n    public ?Post $post;\n\n    #[Validate('required|min:5')]\n    public $title = '';\n\n    #[Validate('required|min:5')]\n    public $content = '';\n\n    public function setPost(Post $post)\n    {\n        $this->post = $post;\n\n        $this->title = $post->title;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-23","text":"itle = $post->title;\n\n        $this->content = $post->content;\n    }\n\n    public function store()\n    {\n        $this->validate();\n\n        Post::create($this->only(['title', 'content']));\n    }\n\n    public function update()\n    {\n        $this->validate();\n\n        $this->post->update(\n            $this->only(['title', 'content'])\n        );\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-24","text":"      );\n    }\n}\n```\n\nAs you can see, we've added a `setPost()` method to the `PostForm` object to optionally allow for filling the form with existing data as well as storing the post on the form object for later use. We've also added an `update()` method for updating the existing post.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-25","text":"g the existing post.\n\nForm objects are not required when working with Livewire, but they do offer a nice abstraction for keeping your components free of repetitive boilerplate.\n\n### Resetting form fields\n\nIf you are using a form object, you may want to reset the form after it has been submitted. This can be done by calling the `reset()` method:\n\n```php\n<?php\n\nnamespace App\\Livewire\\Forms;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-26","text":" App\\Livewire\\Forms;\n\nuse Livewire\\Attributes\\Validate;\nuse App\\Models\\Post;\nuse Livewire\\Form;\n\nclass PostForm extends Form\n{\n    #[Validate('required|min:5')]\n    public $title = '';\n\n    #[Validate('required|min:5')]\n    public $content = '';\n\n    // ...\n\n    public function store()\n    {\n        $this->validate();\n\n        Post::create($this->only(['title', 'content']));","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-27","text":"itle', 'content']));\n\n        $this->reset(); // [tl! highlight]\n    }\n}\n```\n\nYou can also reset specific properties by passing the property names into the `reset()` method:\n\n```php\n$this->reset('title');\n\n// Or multiple at once...\n\n$this->reset(['title', 'content']);\n```\n\n### Pulling form fields","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-28","text":" Pulling form fields\n\nAlternatively, you can use the `pull()` method to both retrieve a form's properties and reset them in one operation.\n\n```php\n<?php\n\nnamespace App\\Livewire\\Forms;\n\nuse Livewire\\Attributes\\Validate;\nuse App\\Models\\Post;\nuse Livewire\\Form;\n\nclass PostForm extends Form\n{\n    #[Validate('required|min:5')]\n    public $title = '';","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-29","text":" public $title = '';\n\n    #[Validate('required|min:5')]\n    public $content = '';\n\n    // ...\n\n    public function store()\n    {\n        $this->validate();\n\n        Post::create(\n            $this->pull() // [tl! highlight]\n        );\n    }\n}\n```\n\nYou can also pull specific properties by passing the property names into the `pull()` method:","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-30","text":"the `pull()` method:\n\n```php\n// Return a value before resetting...\n$this->pull('title');\n\n // Return a key-value array of properties before resetting...\n$this->pull(['title', 'content']);\n```\n\n### Using Rule objects","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-31","text":"# Using Rule objects\n\nIf you have more sophisticated validation scenarios where Laravel's `Rule` objects are necessary, you can alternatively define a `rules()` method to declare your validation rules like so:\n\n```php\n<?php\n\nnamespace App\\Livewire\\Forms;\n\nuse Illuminate\\Validation\\Rule;\nuse App\\Models\\Post;\nuse Livewire\\Form;\n\nclass PostForm extends Form\n{\n    public ?Post $post;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-32","text":" public ?Post $post;\n\n    public $title = '';\n\n    public $content = '';\n\n    protected function rules()\n    {\n        return [\n            'title' => [\n                'required',\n                Rule::unique('posts')->ignore($this->post), // [tl! highlight]\n            ],\n            'content' => 'required|min:5',\n        ];\n    }\n\n    // ...","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-33","text":"];\n    }\n\n    // ...\n\n    public function update()\n    {\n        $this->validate();\n\n        $this->post->update($this->only(['title', 'content']));\n\n        $this->reset();\n    }\n}\n```\n\nWhen using a `rules()` method instead of `#[Validate]`, Livewire will only run the validation rules when you call `$this->validate()`, rather than every time a property is updated.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-34","text":"property is updated.\n\nIf you are using real-time validation or any other scenario where you'd like Livewire to validate specific fields after every request, you can use `#[Validate]` without any provided rules like so:\n\n```php\n<?php\n\nnamespace App\\Livewire\\Forms;\n\nuse Livewire\\Attributes\\Validate;\nuse Illuminate\\Validation\\Rule;\nuse App\\Models\\Post;\nuse Livewire\\Form;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-35","text":";\nuse Livewire\\Form;\n\nclass PostForm extends Form\n{\n    public ?Post $post;\n\n    #[Validate] // [tl! highlight]\n    public $title = '';\n\n    public $content = '';","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-36","text":"ublic $content = '';\n\n    protected function rules()\n    {\n        return [\n            'title' => [\n                'required',\n                Rule::unique('posts')->ignore($this->post),\n            ],\n            'content' => 'required|min:5',\n        ];\n    }\n\n    // ...\n\n    public function update()\n    {\n        $this->validate();","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-37","text":"  $this->validate();\n\n        $this->post->update($this->only(['title', 'content']));\n\n        $this->reset();\n    }\n}\n```\n\nNow if the `$title` property is updated before the form is submitted—like when using [`wire:model.blur`](/docs/wire-model#updating-on-blur-event)—the validation for `$title` will be run.\n\n### Showing a loading indicator","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-38","text":" a loading indicator\n\nBy default, Livewire will automatically disable submit buttons and mark inputs as `readonly` while a form is being submitted, preventing the user from submitting the form again while the first submission is being handled.\n\nHowever, it can be difficult for users to detect this \"loading\" state without extra affordances in your application's UI.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-39","text":"ur application's UI.\n\nHere's an example of adding a small loading spinner to the \"Save\" button via `wire:loading` so that a user understands that the form is being submitted:\n\n```blade\n<button type=\"submit\">\n    Save\n\n    <div wire:loading>\n        <svg>...</svg> <!-- SVG loading spinner -->\n    </div>\n</button>\n```\n\nNow, when a user presses \"Save\", a small, inline spinner will show up.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-40","text":"pinner will show up.\n\nLivewire's `wire:loading` feature has a lot more to offer. Visit the [Loading documentation to learn more.](/docs/wire-loading)\n\n## Live-updating fields\n\nBy default, Livewire only sends a network request when the form is submitted (or any other [action](/docs/actions) is called), not while the form is being filled out.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-41","text":"is being filled out.\n\nTake the `CreatePost` component, for example. If you want to make sure the \"title\" input field is synchronized with the `$title` property on the backend as the user types, you may add the `.live` modifier to `wire:model` like so:\n\n```blade\n<input type=\"text\" wire:model.live=\"title\">\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-42","text":"el.live=\"title\">\n```\n\nNow, as a user types into this field, network requests will be sent to the server to update `$title`. This is useful for things like a real-time search, where a dataset is filtered as a user types into a search box.\n\n## Only updating fields on _blur_","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-43","text":"ing fields on _blur_\n\nFor most cases, `wire:model.live` is fine for real-time form field updating; however, it can be overly network resource-intensive on text inputs.\n\nIf instead of sending network requests as a user types, you want to instead only send the request when a user \"tabs\" out of the text input (also referred to as \"blurring\" an input), you can use the `.blur` modifier instead:","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-44","text":"r` modifier instead:\n\n```blade\n<input type=\"text\" wire:model.blur=\"title\" >\n```\n\nNow the component class on the server won't be updated until the user presses tab or clicks away from the text input.\n\n## Real-time validation","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-45","text":"Real-time validation\n\nSometimes, you may want to show validation errors as the user fills out the form. This way, they are alerted early that something is wrong instead of having to wait until the entire form is filled out.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-46","text":" form is filled out.\n","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-47","text":"form is filled out.\n\nLivewire handles this sort of thing automatically. By using `.live` or `.blur` on `wire:model`, Livewire will send network requests as the user fills out the form. Each of those network requests will run the appropriate validation rules before updating each property","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-48","text":"dating each property. If validation fails, the property won't be updated on the server and a validation message will be shown to the user:","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-49","text":"e shown to the user:\n\n```blade\n<input type=\"text\" wire:model.blur=\"title\">\n\n<div>\n    @error('title') <span class=\"error\">{{ $message }}</span> @enderror\n</div>\n```\n\n```php\n#[Validate('required|min:5')]\npublic $title = '';\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-50","text":"lic $title = '';\n```\n\nNow, if the user only types three characters into the \"title\" input, then clicks on the next input in the form, a validation message will be shown to them indicating there is a five character minimum for that field.\n\nFor more information, check out the [validation documentation page](/docs/validation).\n\n## Real-time form saving","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-51","text":"eal-time form saving\n\nIf you want to automatically save a form as the user fills it out rather than wait until the user clicks \"submit\", you can do so using Livewire's `updated()` hook:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass UpdatePost extends Component\n{\n    public Post $post;","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-52","text":"  public Post $post;\n\n    #[Validate('required')]\n    public $title = '';\n\n    #[Validate('required')]\n    public $content = '';\n\n    public function mount(Post $post)\n    {\n        $this->post = $post;\n        $this->title = $post->title;\n        $this->content = $post->content;\n    }","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-53","text":"post->content;\n    }\n\n    public function updated($name, $value) // [tl! highlight:5]\n    {\n        $this->post->update([\n            $name => $value,\n        ]);\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-54","text":"-post');\n    }\n}\n```\n\n```blade\n<form wire:submit>\n    <input type=\"text\" wire:model.blur=\"title\">\n    <div>\n        @error('title') <span class=\"error\">{{ $message }}</span> @enderror\n    </div>\n\n    <input type=\"text\" wire:model.blur=\"content\">\n    <div>\n        @error('content') <span class=\"error\">{{ $message }}</span> @enderror\n    </div>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-55","text":"  </div>\n</form>\n```\n\nIn the above example, when a user completes a field (by clicking or tabbing to the next field), a network request is sent to update that property on the component. Immediately after the property is updated on the class, the `updated()` hook is called for that specific property name and its new value.\n\nWe can use this hook to update only that specific field in the database.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-56","text":"eld in the database.\n\nAdditionally, because we have the `#[Validate]` attributes attached to those properties, the validation rules will be run before the property is updated and the `updated()` hook is called.\n\nTo learn more about the \"updated\" lifecycle hook and other hooks, [visit the lifecycle hooks documentation](/docs/lifecycle-hooks).\n\n## Showing dirty indicators","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-57","text":"ing dirty indicators\n\nIn the real-time saving scenario discussed above, it may be helpful to indicate to users when a field hasn't been persisted to the database yet.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-58","text":"to the database yet.\n\nFor example, if a user visits an `UpdatePost` page and starts modifying the title of the post in a text input, it may be unclear to them when the title is actually being updated in the database, especially if there is no \"Save\" button at the bottom of the form.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-59","text":" bottom of the form.\n\nLivewire provides the `wire:dirty` directive to allow you to toggle elements or modify classes when an input's value diverges from the server-side component:\n\n```blade\n<input type=\"text\" wire:model.blur=\"title\" wire:dirty.class=\"border-yellow\">\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-60","text":"\"border-yellow\">\n```\n\nIn the above example, when a user types into the input field, a yellow border will appear around the field. When the user tabs away, the network request is sent and the border will disappear; signaling to them that the input has been persisted and is no longer \"dirty\".","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-61","text":"s no longer \"dirty\".\n\nIf you want to toggle an entire element's visibility, you can do so by using `wire:dirty` in conjunction with `wire:target`. `wire:target` is used to specify which piece of data you want to watch for \"dirtiness\". In this case, the \"title\" field:\n\n```blade\n<input type=\"text\" wire:model=\"title\">\n\n<div wire:dirty wire:target=\"title\">Unsaved...</div>\n```\n\n## Debouncing input","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-62","text":"\n## Debouncing input\n\nWhen using `.live` on a text input, you may want more fine-grained control over how often a network request is sent. By default, a debounce of \"250ms\" is applied to the input; however, you can customize this using the `.debounce` modifier:\n\n```blade\n<input type=\"text\" wire:model.live.debounce.150ms=\"title\" >\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-63","text":".150ms=\"title\" >\n```\n\nNow that `.debounce.150ms` has been added to the field, a shorter debounce of \"150ms\" will be used when handling input updates for this field. In other words, as a user types, a network request will only be sent if the user stops typing for at least 150 milliseconds.\n\n## Throttling input","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-64","text":"\n## Throttling input\n\nAs stated previously, when an input debounce is applied to a field, a network request will not be sent until the user has stopped typing for a certain amount of time. This means if the user continues typing a long message, a network request won't be sent until the user is finished.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-65","text":"he user is finished.\n\nSometimes this isn't the desired behavior, and you would rather send a request as the user types, not when they've finished or taken a break.\n\nIn these cases, you can instead use `.throttle` to signify a time interval to send network requests:\n\n```blade\n<input type=\"text\" wire:model.live.throttle.150ms=\"title\" >\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-66","text":".150ms=\"title\" >\n```\n\nIn the above example, as a user is typing continuously in the \"title\" field, a network request will be sent every 150 milliseconds until the user is finished.\n\n## Extracting input fields to Blade components","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-67","text":" to Blade components\n\nEven in a small component such as the `CreatePost` example we've been discussing, we end up duplicating lots of form field boilerplate like validation messages and labels.\n\nIt can be helpful to extract repetitive UI elements such as these into dedicated [Blade components](https://laravel.com/docs/blade#components) to be shared across your application.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-68","text":"ss your application.\n\nFor example, below is the original Blade template from the `CreatePost` component. We will be extracting the following two text inputs into dedicated Blade components:\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"text\" wire:model=\"title\"> <!-- [tl! highlight:3] -->\n    <div>\n        @error('title') <span class=\"error\">{{ $message }}</span> @enderror\n    </div>","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-69","text":"@enderror\n    </div>\n\n    <input type=\"text\" wire:model=\"content\"> <!-- [tl! highlight:3] -->\n    <div>\n        @error('content') <span class=\"error\">{{ $message }}</span> @enderror\n    </div>\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\nHere's what the template will look like after extracting a re-usable Blade component called `<x-input-text>`:","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-70","text":"ed `<x-input-text>`:\n\n```blade\n<form wire:submit=\"save\">\n    <x-input-text name=\"title\" wire:model=\"title\" /> <!-- [tl! highlight] -->\n\n    <x-input-text name=\"content\" wire:model=\"content\" /> <!-- [tl! highlight] -->\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\nNext, here's the source for the `x-input-text` component:\n\n```blade\n<!-- resources/views/components/input-text.blade.php -->","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-71","text":"t-text.blade.php -->\n\n@props(['name'])\n\n<input type=\"text\" name=\"{{ $name }}\" {{ $attributes }}>\n\n<div>\n    @error($name) <span class=\"error\">{{ $message }}</span> @enderror\n</div>\n```\n\nAs you can see, we took the repetitive HTML and placed it inside a dedicated Blade component.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-72","text":"ted Blade component.\n\nFor the most part, the Blade component contains only the extracted HTML from the original component. However, we have added two things:\n\n* The `@props` directive\n* The `{{ $attributes }}` statement on the input\n\nLet's discuss each of these additions:","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-73","text":" of these additions:\n\nBy specifying `name` as a \"prop\" using `@props(['name'])` we are telling Blade: if an attribute called \"name\" is set on this component, take its value and make it available inside this component as `$name`.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-74","text":"omponent as `$name`.\n\nFor other attributes that don't have an explicit purpose, we used the `{{ $attributes }}` statement. This is used for \"attribute forwarding\", or in other words, taking any HTML attributes written on the Blade component and forwarding them onto an element within the component.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-75","text":"ithin the component.\n\nThis ensures `wire:model=\"title\"` and any other extra attributes such as `disabled`, `class=\"...\"`, or `required` still get forwarded to the actual `<input>` element.\n\n### Custom form controls\n\nIn the previous example, we \"wrapped\" an input element into a re-usable Blade component we can use as if it was a native HTML input element.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-76","text":" HTML input element.\n\nThis pattern is very useful; however, there might be some cases where you want to create an entire input component from scratch (without an underlying native input element), but still be able to bind its value to Livewire properties using `wire:model`.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-77","text":" using `wire:model`.\n\nFor example, let's imagine you wanted to create an `<x-input-counter />` component that was a simple \"counter\" input written in Alpine.\n\nBefore we create a Blade component, let's first look at a simple, pure-Alpine, \"counter\" component for reference:\n\n```blade\n<div x-data=\"{ count: 0 }\">\n    <button x-on:click=\"count--\">-</button>\n\n    <span x-text=\"count\"></span>","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-78","text":"text=\"count\"></span>\n\n    <button x-on:click=\"count++\">+</button>\n</div>\n```\n\nAs you can see, the component above shows a number alongside two buttons to increment and decrement that number.\n\nNow, let's imagine we want to extract this component into a Blade component called `<x-input-counter />` that we would use within a component like so:\n\n```blade\n<x-input-counter wire:model=\"quantity\" />\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-79","text":"el=\"quantity\" />\n```\n\nCreating this component is mostly simple. We take the HTML of the counter and place it inside a Blade component template like `resources/views/components/input-counter.blade.php`.\n\nHowever, making it work with `wire:model=\"quantity\"` so that you can easily bind data from your Livewire component to the \"count\" inside this Alpine component needs one extra step.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-80","text":"eeds one extra step.\n\nHere's the source for the component:\n\n```blade\n<!-- resources/view/components/input-counter.blade.php -->\n\n<div x-data=\"{ count: 0 }\" x-modelable=\"count\" {{ $attributes}}>\n    <button x-on:click=\"count--\">-</button>\n\n    <span x-text=\"count\"></span>\n\n    <button x-on:click=\"count++\">+</button>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-81","text":"</button>\n</div>\n```\n\nAs you can see, the only different bit about this HTML is the `x-modelable=\"count\"` and `{{ $attributes }}`.\n\n`x-modelable` is a utility in Alpine that tells Alpine to make a certain piece of data available for binding from outside. [The Alpine documentation has more information on this directive.](https://alpinejs.dev/directives/modelable)","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-82","text":"irectives/modelable)\n\n`{{ $attributes }}`, as we explored earlier, forwards any attributes passed into the Blade component from outside. In this case, the `wire:model` directive will be forwarded.\n\nBecause of `{{ $attributes }}`, when the HTML is rendered in the browser, `wire:model=\"quantity\"` will be rendered alongside `x-modelable=\"count\"` on the root `<div>` of the Alpine component like so:","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-83","text":"e component like so:\n\n```blade\n<div x-data=\"{ count: 0 }\" x-modelable=\"count\" wire:model=\"quantity\">\n```\n\n`x-modelable=\"count\"` tells Alpine to look for any `x-model` or `wire:model` statements and use \"count\" as the data to bind them to.","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-84","text":"ata to bind them to.\n\nBecause `x-modelable` works for both `wire:model` and `x-model`, you can also use this Blade component interchangeably with Livewire and Alpine. Here’s an example of using this Blade component in a purely Alpine context:\n\n```blade\n<x-input-counter x-model=\"quantity\" />\n```","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"db1182c1e7613d1c3800f3c18a110bb8-85","text":"el=\"quantity\" />\n```\n\nCreating custom input elements in your application is extremely powerful but requires a deeper understanding of the utilities Livewire and Alpine provide and how they interact with each other.\n","source":"/Users/fyyx/Documents/livewire/docs/forms.md"}
{"id":"226915038b3034709213b638b7680deb-0","text":"## Global Component Hooks\n\nIn cases where you want to add features or behavior to every single component in your application, you can use Livewire \"Component Hooks\".\n\nComponent Hooks allow you to define a single class with the ability to hook in to a Livewire component's lifecycle externally (not on the component class itself, and not in a trait).","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-1","text":"and not in a trait).\n\nBefore we look at an actual example of using them, here's a generic Component Hook class showing every available method you can use inside them:\n\n```php\nuse Livewire\\ComponentHook;","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-2","text":"ewire\\ComponentHook;\n\nclass MyComponentHook extends ComponentHook\n{\n    public static function provide()\n    {\n        // Runs once at application boot.\n        // Can be used to register any services you may need.\n    }","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-3","text":" you may need.\n    }\n\n    public function mount($params, $parent)\n    {\n        // Called when a component is \"mounted\"\n        // \n        // $params: Array of parameters passed into the component\n        // $parent: The parent component object if this is a nested component\n    }","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-4","text":"sted component\n    }\n\n    public function hydrate($memo)\n    {\n        // Called when a component is \"hydrated\"\n        //\n        // $memo: An associative array of the \"dehydrated\" metadata for this component\n    }\n\n    public function boot()\n    {\n        // Called when the component boots\n    }","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-5","text":"omponent boots\n    }\n\n    public function update($property, $path, $value)\n    {\n        // Called before the component updates...\n\n        return function () {\n            // Called after the component property has updated...\n        };\n    }\n\n    public function call($method, $params, $returnEarly)\n    {\n        // Called before a method on the component is called...","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-6","text":"mponent is called...\n\n        return function ($returnValue) {\n            // Called after a method is called\n        };\n    }\n\n    public function render($view, $data)\n    {\n        // Called after \"render\" is called but before the Blade has been rendered...\n        return function ($html) {\n            // Called after the component's view has been rendered\n        };\n    }","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-7","text":"red\n        };\n    }\n\n    public function dehydrate($context)\n    {\n        // Called when a component \"dehydrates\"\n    }\n\n    public function exception($e, $stopPropagation)\n    {\n        // Called if an exception is thrown within a component...\n    }\n}\n```\n\nYou can register a Component Hook from a service provider like your `App\\Providers\\AppServiceProvider` like so:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-8","text":"ke so:\n\n```php\n<?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse Livewire\\Livewire;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Bootstrap any application services.\n     */\n    public function boot(): void\n    {\n        Livewire::componentHook(MyComponentHook::class);\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-9","text":" }\n\n    // ...\n}\n```\n\nNow that you've seen the broad overview of Component Hooks, here's a more practical example of using them to provide useful functionality for your application.","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-10","text":"or your application.\n\nLet's say you wanted to support the ability to return a CSV from any Livewire action, and it would automatically trigger a file download. For example, you could return a Csv from a method called `save` inside a `CreatePost` component:\n\n```php\nuse Livewire\\Component;\n\nclass CreateUser extends Component\n{\n    public $username = '';\n\n    public $email = '';","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-11","text":" public $email = '';\n\n    public function something()\n    {\n        return new Csv();\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-12","text":" }\n\n    // ...\n}\n```\n\n\n```php\n<?php\n\nnamespace App;\n\nuse Livewire\\ComponentHook;\n\nclass SupportCsvDownloads extends ComponentHook\n{\n    public function call($method, $params, $returnEarly)\n    {\n        // Called before a method on the component is called...","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"226915038b3034709213b638b7680deb-13","text":"mponent is called...\n\n        return function ($returnValue) {\n            if ($returnValue instanceof Csv) {\n                // do something\n            }\n        };\n    }\n}\n```\n\nYou can \n","source":"/Users/fyyx/Documents/livewire/docs/component-hooks.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-0","text":"Livewire allows you to store component properties in the URL's query string. For example, you may want a `$search` property in your component to be included in the URL: `https://example.com/users?search=bob`. This is particularly useful for things like filtering, sorting, and pagination, as it allows users to share and bookmark specific states of a page.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-1","text":"age.\n\n## Basic usage\n\nBelow is a `ShowUsers` component that allows you to search users by their name via a simple text input:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Attributes\\Url;\nuse Livewire\\Component;\nuse App\\Models\\User;\n\nclass ShowUsers extends Component\n{\n    public $search = '';","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-2","text":"public $search = '';\n\n    public function render()\n    {\n        return view('livewire.show-users', [\n            'users' => User::search($this->search)->get(),\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    <input type=\"text\" wire:model.live=\"search\">","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-3","text":"model.live=\"search\">\n\n    <ul>\n        @foreach ($users as $user)\n            <li wire:key=\"{{ $user->id }}\">{{ $user->name }}</li>\n        @endforeach\n    </ul>\n</div>\n```\n\nAs you can see, because the text input uses `wire:model.live=\"search\"`, as a user types into the field, network requests will be sent to update the `$search` property and show a filtered set of users on the page.","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-4","text":"f users on the page.\n\nHowever, if the visitor refreshes the page, the search value and results will be lost.\n\nTo preserve the search value across page loads so that a visitor can refresh the page or share the URL, we can store the search value in the URL's query string by adding the `#[Url]` attribute above the `$search` property like so:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-5","text":"espace App\\Livewire;\n\nuse Livewire\\Attributes\\Url;\nuse Livewire\\Component;\nuse App\\Models\\User;\n\nclass ShowUsers extends Component\n{\n    #[Url] // [tl! highlight]\n    public $search = '';\n\n    public function render()\n    {\n        return view('livewire.show-users', [\n            'posts' => User::search($this->search)->get(),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-6","text":"     ]);\n    }\n}\n```\n\nNow, if a user types \"bob\" into the search field, the URL bar in the browser will show:\n\n```\nhttps://example.com/users?search=bob\n```\n\nIf they now load this URL from a new browser window, \"bob\" will be filled in the search field, and the user results will be filtered accordingly.\n\n## Initializing properties from the URL","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-7","text":"perties from the URL\n\nAs you saw in the previous example, when a property uses `#[Url]`, not only does it store its updated value in the query string of the URL, it also references any existing query string values on page load.\n\nFor example, if a user visits the URL `https://example.com/users?search=bob`, Livewire will set the initial value of `$search` to \"bob\".","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-8","text":" `$search` to \"bob\".\n\n```php\nuse Livewire\\Attributes\\Url;\nuse Livewire\\Component;\n\nclass ShowUsers extends Component\n{\n    #[Url]\n    public $search = ''; // Will be set to \"bob\"...\n\n    // ...\n}\n```\n\n### Nullable properties","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-9","text":" Nullable properties\n\nBy default, if a page is loaded with an empty query string entry like `?search=`, Livewire will treat that value as an empty string. In many cases, this is expected, however there are times when you want `?search=` to be treated as `null`.\n\nIn these cases, you can use a nullable typehint like so:\n\n```php\nuse Livewire\\Attributes\\Url;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-10","text":" Livewire\\Component;\n\nclass ShowUsers extends Component\n{\n    #[Url]\n    public ?string $search; // [tl! highlight]\n\n    // ...\n}\n```\n\nBecause `?` is present in the above typehint, Livewire will see `?search=` and set `$search` to `null` instead of an empty string.","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-11","text":" of an empty string.\n\nThis works the other way around as well, if you set `$this->search = null` in your application, it will be represented in the query string as `?search=`.\n\n## Using an alias","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-12","text":".\n\n## Using an alias\n\nLivewire gives you full control over what name displays in the URL's query string. For example, you may have a `$search` property but want to either obfuscate the actual property name or shorten it to `q`.\n\nYou can specify a query string alias by providing the `as` parameter to the `#[Url]` attribute:\n\n```php\nuse Livewire\\Attributes\\Url;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-13","text":" Livewire\\Component;\n\nclass ShowUsers extends Component\n{\n    #[Url(as: 'q')]\n    public $search = '';\n\n    // ...\n}\n```\n\nNow, when a user types \"bob\" into the search field, the URL will show: `https://example.com/users?q=bob` instead of `?search=bob`.\n\n## Excluding certain values","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-14","text":"uding certain values\n\nBy default, Livewire will only put an entry in the query string when it's value has changed from what it was at initialization. Most of the time, this is the desired behavior, however, there are certain scenarios where you may want more control over which value Livewire excludes from the query string. In these cases you can use the `except` parameter.","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-15","text":" `except` parameter.\n\nFor example, in the component below, the initial value of `$search` is modified in `mount()`. To ensure the browser will only ever exclude `search` from the query string if the `search` value is an empty string, the `except` parameter has been added to `#[Url]`:\n\n```php\nuse Livewire\\Attributes\\Url;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-16","text":" Livewire\\Component;\n\nclass ShowUsers extends Component\n{\n    #[Url(except: '')]\n    public $search = '';\n\n    public function mount() {\n        $this->search = auth()->user()->username;\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-17","text":" }\n\n    // ...\n}\n```\n\nWithout `except` in the above example, Livewire would remove the `search` entry from the query string any time the value of `search` is equal to the initial value of `auth()->user()->username`. Instead, because `except: ''` has been used, Livewire will preserve all query string values except when `search` is an empty string.\n\n## Display on page load","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-18","text":"Display on page load\n\nBy default, Livewire will only display a value in the query string after the value has been changed on the page. For example, if the default value for `$search` is an empty string: `\"\"`, when the actual search input is empty, no value will appear in the URL.","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-19","text":"l appear in the URL.\n\nIf you want the `?search` entry to always be included in the query string, even when the value is empty, you can provide the `keep` parameter to the `#[Url]` attribute:\n\n```php\nuse Livewire\\Attributes\\Url;\nuse Livewire\\Component;\n\nclass ShowUsers extends Component\n{\n    #[Url(keep: true)]\n    public $search = '';\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-20","text":"';\n\n    // ...\n}\n```\n\nNow, when the page loads, the URL will be changed to the following: `https://example.com/users?search=`\n\n## Storing in history","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-21","text":"# Storing in history\n","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-22","text":" Storing in history\n\nBy default, Livewire uses [`history.replaceState()`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) to modify the URL instead of [`history.pushState()`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-23","text":"I/History/pushState). This means that when Livewire updates the query string, it modifies the current entry in the browser's history state instead of adding a new one.","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-24","text":"of adding a new one.\n\nBecause Livewire \"replaces\" the current history, pressing the \"back\" button in the browser will go to the previous page rather than the previous `?search=` value.\n\nTo force Livewire to use `history.pushState` when updating the URL, you can provide the `history` parameter to the `#[Url]` attribute:\n\n```php\nuse Livewire\\Attributes\\Url;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-25","text":" Livewire\\Component;\n\nclass ShowUsers extends Component\n{\n    #[Url(history: true)]\n    public $search = '';\n\n    // ...\n}\n```\n\nIn the example above, when a user changes the search value from \"bob\" to \"frank\" and then clicks the browser's back button, the search value (and the URL) will be set back to \"bob\" instead of navigating to the previously visited page.\n\n## Using the queryString method","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-26","text":"e queryString method\n\nThe query string can also be defined as a method on the component. This can be useful if some properties have dynamic options.\n\n```php\nuse Livewire\\Component;\n\nclass ShowUsers extends Component\n{\n    // ...\n\n    protected function queryString()\n    {\n        return [\n            'search' => [\n                'as' => 'q',\n            ],\n        ];\n    }\n}\n```\n\n## Trait hooks","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"6f19d4a76d998b65e88d1c6514745703-27","text":"\n```\n\n## Trait hooks\n\nLivewire offers [hooks](/docs/lifecycle-hooks) for query strings as well.\n\n```php\ntrait WithSorting\n{\n    // ...\n\n    protected function queryStringWithSorting()\n    {\n        return [\n            'sortBy' => ['as' => 'sort'],\n            'sortDirection' => ['as' => 'direction'],\n        ];\n    }\n}\n```\n","source":"/Users/fyyx/Documents/livewire/docs/url.md"}
{"id":"390c729a84626ceac9c570f4bab3897f-0","text":"* Start with extracting a Blade component first, then only do a Livewire component if you need to\n* ","source":"/Users/fyyx/Documents/livewire/docs/best-practices.md"}
{"id":"9e4cd0532548306803c805b797d98efd-0","text":"---\nGetting Started:\n    Quickstart: { uri: /docs/quickstart, file: /quickstart.md }\n    Installation: { uri: /docs/installation, file: /installation.md }\n    Upgrade Guide: { uri: /docs/upgrading, file: /upgrading.md }\nEssentials:\n    Components: { uri: /docs/components, file: /components.md }\n    Properties: { uri: /docs/properties, file: /properties.md }","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-1","text":"le: /properties.md }\n    Actions: { uri: /docs/actions, file: /actions.md }\n    Forms: { uri: /docs/forms, file: /forms.md }\n    Events: { uri: /docs/events, file: /events.md }\n    Lifecycle Hooks: { uri: /docs/lifecycle-hooks, file: /lifecycle-hooks.md }\n    Nesting Components: { uri: /docs/nesting, file: /nesting.md }\n    Testing: { uri: /docs/testing, file: /testing.md }\nFeatures:","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-2","text":"sting.md }\nFeatures:\n    Alpine: { uri: /docs/alpine, file: /alpine.md }\n    Navigate: { uri: /docs/navigate, file: /navigate.md }\n    Lazy Loading: { uri: /docs/lazy, file: /lazy.md }\n    Validation: { uri: /docs/validation, file: /validation.md }\n    File Uploads: { uri: /docs/uploads, file: /uploads.md }\n    Pagination: { uri: /docs/pagination, file: /pagination.md }","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-3","text":"le: /pagination.md }\n    URL Query Parameters: { uri: /docs/url, file: /url.md }\n    Computed Properties: { uri: /docs/computed-properties, file: /computed-properties.md }\n    Session Properties: { uri: /docs/session-properties, file: /session-properties.md }\n    Redirecting: { uri: /docs/redirecting, file: /redirecting.md }\n    File Downloads: { uri: /docs/downloads, file: /downloads.md }","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-4","text":"ile: /downloads.md }\n    Locked Properties: { uri: /docs/locked, file: /locked.md }\n    Request Bundling: { uri: /docs/bundling, file: /bundling.md }\n    Offline States: { uri: /docs/offline, file: /offline.md }\n    Teleport: { uri: /docs/teleport, file: /teleport.md }\nHTML Directives:\n    wire:click: { uri: /docs/wire-click, file: /wire-click.md }","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-5","text":"le: /wire-click.md }\n    wire:submit: { uri: /docs/wire-submit, file: /wire-submit.md }\n    wire:model: { uri: /docs/wire-model, file: /wire-model.md }\n    wire:loading: { uri: /docs/wire-loading, file: /wire-loading.md }\n    wire:navigate: { uri: /docs/wire-navigate, file: /wire-navigate.md }\n    wire:current: { uri: /docs/wire-current, file: /wire-current.md }","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-6","text":": /wire-current.md }\n    wire:cloak: { uri: /docs/wire-cloak, file: /wire-cloak.md }\n    wire:dirty: { uri: /docs/wire-dirty, file: /wire-dirty.md }\n    wire:confirm: { uri: /docs/wire-confirm, file: /wire-confirm.md }\n    wire:transition: { uri: /docs/wire-transition, file: /wire-transition.md }\n    wire:init: { uri: /docs/wire-init, file: /wire-init.md }","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-7","text":"ile: /wire-init.md }\n    wire:poll: { uri: /docs/wire-poll, file: /wire-poll.md }\n    wire:offline: { uri: /docs/wire-offline, file: /wire-offline.md }\n    wire:ignore: { uri: /docs/wire-ignore, file: /wire-ignore.md }\n    wire:replace: { uri: /docs/wire-replace, file: /wire-replace.md }\n    wire:show: { uri: /docs/wire-show, file: /wire-show.md }","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-8","text":"ile: /wire-show.md }\n    wire:stream: { uri: /docs/wire-stream, file: /wire-stream.md }\n    wire:text: { uri: /docs/wire-text, file: /wire-text.md }\nConcepts:\n    Morphing: { uri: /docs/morphing, file: /morph.md }\n    Hydration: { uri: /docs/hydration, file: /hydration.md }\n    Nesting: { uri: /docs/understanding-nesting, file: /understanding-nesting.md }\nAdvanced:","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-9","text":"sting.md }\nAdvanced:\n    Troubleshooting: { uri: /docs/troubleshooting, file: /troubleshooting.md }\n    Security: { uri: /docs/security, file: /security.md }\n    JavaScript: { uri: /docs/javascript, file: /javascript.md }\n    Synthesizers: { uri: /docs/synthesizers, file: /synthesizers.md }\n    Contribution Guide: { uri: /docs/contribution-guide, file: /contribution-guide.md }\nPackages:","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"9e4cd0532548306803c805b797d98efd-10","text":"guide.md }\nPackages:\n    Volt: { uri: /docs/volt, file: /volt.md }\n---\n","source":"/Users/fyyx/Documents/livewire/docs/__nav.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-0","text":"Computed properties are a way to create \"derived\" properties in Livewire. Like accessors on an Eloquent model, computed properties allow you to access values and cache them for future access during the request.\n\nComputed properties are particularly useful in combination with component's public properties.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-1","text":"ies.\n\n## Basic usage\n\nTo create a computed property, you can add the `#[Computed]` attribute above any method in your Livewire component. Once the attribute has been added to the method, you can access it like any other property.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-2","text":" any other property.\n\n> [!warning] Make sure you import attribute classes\n> Make sure you import any attribute classes. For example, the below `#[Computed]` attribute requires the following import `use Livewire\\Attributes\\Computed;`.\n\nFor example, here's a `ShowUser` component that uses a computed property named `user()` to access a `User` Eloquent model based on a property named `$userId`:","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-3","text":"rty named `$userId`:\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Attributes\\Computed;\nuse Livewire\\Component;\nuse App\\Models\\User;\n\nclass ShowUser extends Component\n{\n    public $userId;\n\n    #[Computed]\n    public function user()\n    {\n        return User::find($this->userId);\n    }\n\n    public function follow()\n    {\n        Auth::user()->follow($this->user);\n    }","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-4","text":"($this->user);\n    }\n\n    public function render()\n    {\n        return view('livewire.show-user');\n    }\n}\n```\n\n```blade\n<div>\n    <h1>{{ $this->user->name }}</h1>\n\n    <span>{{ $this->user->email }}</span>\n\n    <button wire:click=\"follow\">Follow</button>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-5","text":"</button>\n</div>\n```\n\nBecause the `#[Computed]` attribute has been added to the `user()` method, the value is accessible in other methods in the component and within the Blade template.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-6","text":" the Blade template.\n\n> [!info] Must use `$this` in your template\n> Unlike normal properties, computed properties aren't directly available inside your component's template. Instead, you must access them on the `$this` object. For example, a computed property named `posts()` must be accessed via `$this->posts` inside your template.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-7","text":"nside your template.\n\n> [!warning] Computed properties are not supported on `Livewire\\Form` objects.\n> Trying to use a Computed property within a [Form](https://livewire.laravel.com/docs/forms) will result in an error when you attempt to access the property in blade using $form->property syntax.\n\n## Performance advantage","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-8","text":"erformance advantage\n\nYou may be asking yourself: why use computed properties at all? Why not just call the method directly?","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-9","text":"the method directly?\n\nAccessing a method as a computed property offers a performance advantage over calling a method. Internally, when a computed property is executed for the first time, Livewire caches the returned value. This way, any subsequent accesses in the request will return the cached value instead of executing multiple times.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-10","text":"ting multiple times.\n\nThis allows you to freely access a derived value and not worry about the performance implications.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-11","text":"rmance implications.\n\n> [!warning] Computed properties are only cached for a single request","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-12","text":"for a single request\n> It's a common misconception that Livewire caches computed properties for the entire lifespan of your Livewire component on a page. However, this isn't the case. Instead, Livewire only caches the result for the duration of a single component request","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-13","text":"le component request. This means that if your computed property method contains an expensive database query, it will be executed every time your Livewire component performs an update.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-14","text":" performs an update.\n\n### Busting the cache\n\nConsider the following problematic scenario:\n1) You access a computed property that depends on a certain property or database state\n2) The underlying property or database state changes\n3) The cached value for the property becomes stale and needs to be re-computed\n\nTo clear, or \"bust\", the stored cache, you can use PHP's `unset()` function.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-15","text":" `unset()` function.\n\nBelow is an example of an action called `createPost()` that, by creating a new post in the application, makes the `posts()` computed stale — meaning the computed property `posts()` needs to be re-computed to include the newly added post:\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Attributes\\Computed;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-16","text":" Livewire\\Component;\n\nclass ShowPosts extends Component\n{\n    public function createPost()\n    {\n        if ($this->posts->count() > 10) {\n            throw new \\Exception('Maximum post count exceeded');\n        }\n\n        Auth::user()->posts()->create(...);\n\n        unset($this->posts); // [tl! highlight]\n    }","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-17","text":"tl! highlight]\n    }\n\n    #[Computed]\n    public function posts()\n    {\n        return Auth::user()->posts;\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-18","text":" }\n\n    // ...\n}\n```\n\nIn the above component, the computed property is cached before a new post is created because the `createPost()` method accesses `$this->posts` before the new post is created. To ensure that `$this->posts` contains the most up-to-date contents when accessed inside the view, the cache is invalidated using `unset($this->posts)`.\n\n### Caching between requests","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-19","text":"ing between requests\n\nSometimes you would like to cache the value of a computed property for the lifespan of a Livewire component, rather than it being cleared after every request. In these cases, you can use [Laravel's caching utilities](https://laravel.com/docs/cache#retrieve-store).","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-20","text":"che#retrieve-store).\n\nBelow is an example of a computed property named `user()`, where instead of executing the Eloquent query directly, we wrap the query in `Cache::remember()` to ensure that any future requests retrieve it from Laravel's cache instead of re-executing the query:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-21","text":"query:\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Cache;\nuse Livewire\\Attributes\\Computed;\nuse Livewire\\Component;\nuse App\\Models\\User;\n\nclass ShowUser extends Component\n{\n    public $userId;\n\n    #[Computed]\n    public function user()\n    {\n        $key = 'user'.$this->getId();\n        $seconds = 3600; // 1 hour...","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-22","text":"= 3600; // 1 hour...\n\n        return Cache::remember($key, $seconds, function () {\n            return User::find($this->userId);\n        });\n    }\n\n    // ...\n}\n```\n\nBecause each unique instance of a Livewire component has a unique ID, we can use `$this->getId()` to generate a unique cache key that will only be applied to future requests for this same component instance.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-23","text":" component instance.\n\nBut, as you may have noticed, most of this code is predictable and can easily be abstracted. Because of this, Livewire's `#[Computed]` attribute provides a helpful `persist` parameter. By applying `#[Computed(persist: true)]` to a method, you can achieve the same result without any extra code:\n\n```php\nuse Livewire\\Attributes\\Computed;\nuse App\\Models\\User;","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-24","text":"use App\\Models\\User;\n\n#[Computed(persist: true)]\npublic function user()\n{\n    return User::find($this->userId);\n}\n```\n\nIn the example above, when `$this->user` is accessed from your component, it will continue to be cached for the duration of the Livewire component on the page. This means the actual Eloquent query will only be executed once.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-25","text":"ly be executed once.\n\nLivewire caches persisted values for 3600 seconds (one hour). You can override this default by passing an additional `seconds` parameter to the `#[Computed]` attribute:\n\n```php\n#[Computed(persist: true, seconds: 7200)]\n```","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-26","text":" seconds: 7200)]\n```\n\n> [!tip] Calling `unset()` will bust this cache","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-27","text":"will bust this cache\n> As previously discussed, you can clear a computed property's cache using PHP's `unset()` method. This also applies to computed properties using the `persist: true` parameter. When calling `unset()` on a cached computed property, Livewire will clear not only the computed property cache, but also the underlying cached value in Laravel's cache.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-28","text":" in Laravel's cache.\n\n## Caching across all components\n\nInstead of caching the value of a computed property for the duration of a single component's lifecycle, you can cache the value of a computed across all components in your application using the `cache: true` parameter provided by the `#[Computed]` attribute:\n\n```php\nuse Livewire\\Attributes\\Computed;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-29","text":"use App\\Models\\Post;\n\n#[Computed(cache: true)]\npublic function posts()\n{\n    return Post::all();\n}\n```\n\nIn the above example, until the cache expires or is busted, every instance of this component in your application will share the same cached value for `$this->posts`.\n\nIf you need to manually clear the cache for a computed property, you may set a custom cache key using the `key` parameter:","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-30","text":"the `key` parameter:\n\n```php\nuse Livewire\\Attributes\\Computed;\nuse App\\Models\\Post;\n\n#[Computed(cache: true, key: 'homepage-posts')]\npublic function posts()\n{\n    return Post::all();\n}\n```\n\n## When to use computed properties?\n\nIn addition to offering performance advantages, there are a few other scenarios where computed properties are helpful.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-31","text":"perties are helpful.\n\nSpecifically, when passing data into your component's Blade template, there are a few occasions where a computed property is a better alternative. Below is an example of a simple component's `render()` method passing a collection of `posts` to a Blade template:","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-32","text":"to a Blade template:\n\n```php\npublic function render()\n{\n    return view('livewire.show-posts', [\n        'posts' => Post::all(),\n    ]);\n}\n```\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <!-- ... -->\n    @endforeach\n</div>\n```\n\nAlthough this is sufficient for many use cases, here are three scenarios where a computed property would be a better alternative:","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-33","text":" better alternative:\n\n### Conditionally accessing values\n\nIf you are conditionally accessing a value that is computationally expensive to retrieve in your Blade template, you can reduce performance overhead using a computed property.\n\nConsider the following template without a computed property:","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-34","text":"a computed property:\n\n```blade\n<div>\n    @if (Auth::user()->can_see_posts)\n        @foreach ($posts as $post)\n            <!-- ... -->\n        @endforeach\n    @endif\n</div>\n```\n\nIf a user is restricted from viewing posts, the database query to retrieve the posts has already been made, yet the posts are never used in the template.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-35","text":"sed in the template.\n\nHere's a version of the above scenario using a computed property instead:\n\n```php\nuse Livewire\\Attributes\\Computed;\nuse App\\Models\\Post;\n\n#[Computed]\npublic function posts()\n{\n    return Post::all();\n}\n\npublic function render()\n{\n    return view('livewire.show-posts');\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-36","text":".show-posts');\n}\n```\n\n```blade\n<div>\n    @if (Auth::user()->can_see_posts)\n        @foreach ($this->posts as $post)\n            <!-- ... -->\n        @endforeach\n    @endif\n</div>\n```\n\nNow, because we are providing the posts to the template using a computed property, we only execute the database query when the data is needed.\n\n### Using inline templates","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-37","text":"ing inline templates\n\nAnother scenario when computed properties are helpful is using [inline templates](/docs/components#inline-components) in your component.\n\nBelow is an example of an inline component where, because we are returning a template string directly inside `render()`, we never have an opportunity to pass data into the view:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-38","text":" view:\n\n```php\n<?php\n\nuse Livewire\\Attributes\\Computed;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    #[Computed]\n    public function posts()\n    {\n        return Post::all();\n    }","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-39","text":"n Post::all();\n    }\n\n    public function render()\n    {\n        return <<<HTML\n        <div>\n            @foreach ($this->posts as $post)\n                <!-- ... -->\n            @endforeach\n        </div>\n        HTML;\n    }\n}\n```\n\nIn the above example, without a computed property, we would have no way to explicitly pass data into the Blade template.\n\n### Omitting the render method","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-40","text":"ng the render method\n\nIn Livewire, another way to cut down on boilerplate in your components is by omitting the `render()` method entirely. When omitted, Livewire will use its own `render()` method returning the corresponding Blade view by convention.\n\nIn these case, you obviously don't have a `render()` method from which you can pass data into a Blade view.","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-41","text":"a into a Blade view.\n\nRather than re-introducing the `render()` method into your component, you can instead provide that data to the view via computed properties:\n\n```php\n<?php\n\nuse Livewire\\Attributes\\Computed;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    #[Computed]\n    public function posts()\n    {\n        return Post::all();\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"f992bf6eb06ac26b94bc907ba2569bb6-42","text":"::all();\n    }\n}\n```\n\n```blade\n<div>\n    @foreach ($this->posts as $post)\n        <!-- ... -->\n    @endforeach\n</div>\n```\n","source":"/Users/fyyx/Documents/livewire/docs/computed-properties.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-0","text":"Here at Livewire HQ, we try to remove problems from your pathway before you hit them. However, sometimes, there are some problems that we can't solve without introducing new ones, and other times, there are problems we can't anticipate.\n\nHere are some common errors and scenarios you may encounter in your Livewire apps.\n\n## Component mismatches","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-1","text":"Component mismatches\n\nWhen interacting with Livewire components on your page, you may encounter odd behavior or error messages like the following:\n\n```\nError: Component already initialized\n```\n\n```\nError: Snapshot missing on Livewire component with id: ...\n```","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-2","text":"ent with id: ...\n```\n\nThere are lots of reasons why you may encounter these messages, but the most common one is forgetting to add `wire:key` to elements and components inside a `@foreach` loop.\n\n### Adding `wire:key`\n\nAny time you have a loop in your Blade templates using something like `@foreach`, you need to add `wire:key` to the opening tag of the first element within the loop:","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-3","text":"ent within the loop:\n\n```blade\n@foreach($posts as $post)\n    <div wire:key=\"{{ $post->id }}\"> <!-- [tl! highlight] -->\n        ...\n    </div>\n@endforeach\n```\n\nThis ensures that Livewire can keep track of different elements in the loop when the loop changes.\n\nThe same applies to Livewire components within a loop:","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-4","text":"nents within a loop:\n\n```blade\n@foreach($posts as $post)\n    <livewire:show-post :$post :key=\"$post->id\" /> <!-- [tl! highlight] -->\n@endforeach\n```\n\nHowever, here's a tricky scenario you might not have assumed:\n\nWhen you have a Livewire component deeply nested inside a `@foreach` loop, you STILL need to add a key to it. For example:","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-5","text":" to it. For example:\n\n```blade\n@foreach($posts as $post)\n    <div wire:key=\"{{ $post->id }}\">\n        ...\n        <livewire:show-post :$post :key=\"$post->id\" /> <!-- [tl! highlight] -->\n        ...\n    </div>\n@endforeach\n```\n\nWithout the key on the nested Livewire component, Livewire will be unable to match the looped components up between network requests.\n\n#### Prefixing keys","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-6","text":"\n#### Prefixing keys\n\nAnother tricky scenario you may run into is having duplicate keys within the same component. This often results from using model IDs as keys, which can sometimes collide.","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-7","text":"n sometimes collide.\n\nHere's an example where we need to add a `post-` and an `author-` prefix to designate each set of keys as unique. Otherwise, if you have a `$post` and `$author` model with the same ID, you would have an ID collision:\n\n```blade\n<div>\n    @foreach($posts as $post)\n        <div wire:key=\"post-{{ $post->id }}\">...</div> <!-- [tl! highlight] -->\n    @endforeach","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-8","text":" -->\n    @endforeach\n\n    @foreach($authors as $author)\n        <div wire:key=\"author-{{ $author->id }}\">...</div> <!-- [tl! highlight] -->\n    @endforeach\n</div>\n```\n\n## Multiple instances of Alpine\n\nWhen installing Livewire, you may run into error messages like the following:\n\n```\nError: Detected multiple instances of Alpine running\n```\n\n```\nAlpine Expression Error: $wire is not defined\n```","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-9","text":"e is not defined\n```\n\nIf this is the case, you likely have two versions of Alpine running on the same page. Livewire includes its own bundle of Alpine under the hood, so you must remove any other versions of Alpine on Livewire pages in your application.","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-10","text":"in your application.\n\nOne common scenario in which this happens is adding Livewire to an existing application that already includes Alpine. For example, if you installed the Laravel Breeze starter kit and then added Livewire later, you would run into this.\n\nThe fix for this is simple: remove the extra Alpine instance.\n\n### Removing Laravel Breeze's Alpine","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-11","text":"avel Breeze's Alpine\n\nIf you are installing Livewire inside an existing Laravel Breeze (Blade + Alpine version), you need to remove the following lines from `resources/js/app.js`:\n\n```js\nimport './bootstrap';\n\nimport Alpine from 'alpinejs'; // [tl! remove:4]\n\nwindow.Alpine = Alpine;\n\nAlpine.start();\n```\n\n### Removing a CDN version of Alpine","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-12","text":"DN version of Alpine\n\nBecause Livewire version 2 and below didn't include Alpine by default, you may have included an Alpine CDN as a script tag in the head of your layout. In Livewire v3, you can remove this CDN altogether, and Livewire will automatically provide Alpine for you:","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-13","text":"vide Alpine for you:\n\n```html\n    ...\n    <script defer src=\"https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js\"></script> <!-- [tl! remove] -->\n</head>\n```\n\nNote: you can also remove any additional Alpine plugins, as Livewire includes all Alpine plugins except `@alpinejs/ui`.\n\n## Missing `@alpinejs/ui`","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-14","text":"ssing `@alpinejs/ui`\n\nLivewire's bundled version of Alpine includes all Alpine plugins EXCEPT `@alpinejs/ui`. If you are using headless components from [Alpine Components](https://alpinejs.dev/components), which relies on this plugin, you may encounter errors like the following:\n\n```\nUncaught Alpine: no element provided to x-anchor\n```","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-15","text":"ided to x-anchor\n```\n\nTo fix this, you can simply include the `@alpinejs/ui` plugin as a CDN in your layout file like so:\n\n```html\n    ...\n    <script defer src=\"https://unpkg.com/@alpinejs/ui@3.13.7-beta.0/dist/cdn.min.js\"></script> <!-- [tl! add] -->\n</head>\n```","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"af31967102820bf30dc0b06c78d56ca9-16","text":"add] -->\n</head>\n```\n\nNote: be sure to include the latest version of this plugin, which you can find on [any component's documentation page](https://alpinejs.dev/component/headless-dialog/docs).\n","source":"/Users/fyyx/Documents/livewire/docs/troubleshooting.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-0","text":"\n[AlpineJS](https://alpinejs.dev/) is a lightweight JavaScript library that makes it easy to add client-side interactivity to your web pages. It was originally built to complement tools like Livewire where a more JavaScript-centric utility is helpful for sprinkling interactivity around your app.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-1","text":"ity around your app.\n\nLivewire ships with Alpine out of the box so there is no need to install it into your project separately.\n\nThe best place to learn about using AlpineJS is [the Alpine documentation](https://alpinejs.dev).\n\n## A Basic Alpine component","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-2","text":"sic Alpine component\n\nTo lay a foundation for the rest of this documentation, here is one of the most simple and informative examples of an Alpine component. A small \"counter\" that shows a number on the page and allows the user to increment that number by clicking a button:","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-3","text":"y clicking a button:\n\n```html\n<!-- Declare a JavaScript object of data... -->\n<div x-data=\"{ count: 0 }\">\n    <!-- Render the current \"count\" value inside an element... -->\n    <h2 x-text=\"count\"></h2>\n\n    <!-- Increment the \"count\" value by \"1\" when a click event is dispatched... -->\n    <button x-on:click=\"count++\">+</button>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-4","text":"</button>\n</div>\n```\n\nThe Alpine component above can be used inside any Livewire component in your application without a hitch. Livewire takes care of maintaining Alpine's state across Livewire component updates. In essence, you should feel free to use Alpine components inside Livewire as if you were using Alpine in any other non-Livewire context.\n\n## Using Alpine inside Livewire","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-5","text":"pine inside Livewire\n\nLet's explore a more real-life example of using an Alpine component inside a Livewire component.\n\nBelow is a simple Livewire component showing the details of a post model from the database. By default, only the title of the post is shown:\n\n```html\n<div>\n    <h1>{{ $post->title }}</h1>","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-6","text":"$post->title }}</h1>\n\n    <div x-data=\"{ expanded: false }\">\n        <button type=\"button\" x-on:click=\"expanded = ! expanded\">\n            <span x-show=\"! expanded\">Show post content...</span>\n            <span x-show=\"expanded\">Hide post content...</span>\n        </button>\n\n        <div x-show=\"expanded\">\n            {{ $post->content }}\n        </div>\n    </div>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-7","text":"   </div>\n</div>\n```\n\nBy using Alpine, we can hide the content of the post until the user presses the \"Show post content...\" button. At that point, Alpine's `expanded` property will be set to `true` and the content will be shown on the page because `x-show=\"expanded\"` is used to give Alpine control over the visibility of the post's content.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-8","text":" the post's content.\n\nThis is an example of where Alpine shines: adding interactivity into your application without triggering Livewire server-roundtrips.\n\n## Controlling Livewire from Alpine using `$wire`","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-9","text":"Alpine using `$wire`\n\nOne of the most powerful features available to you as a Livewire developer is `$wire`. The `$wire` object is a magic object available to all your Alpine components that are used inside of Livewire.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-10","text":" inside of Livewire.\n\nYou can think of `$wire` as a gateway from JavaScript into PHP. It allows you to access and modify Livewire component properties, call Livewire component methods, and do much more; all from inside AlpineJS.\n\n### Accessing Livewire properties","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-11","text":" Livewire properties\n\nHere is an example of a simple \"character count\" utility in a form for creating a post. This will instantly show a user how many characters are contained inside their post's content as they type:\n\n```html\n<form wire:submit=\"save\">\n    <!-- ... -->\n\n    <input wire:model=\"content\" type=\"text\">","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-12","text":"ontent\" type=\"text\">\n\n    <small>\n        Character count: <span x-text=\"$wire.content.length\"></span> <!-- [tl! highlight] -->\n    </small>\n\n    <button type=\"submit\">Save</button>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-13","text":"/button>\n</form>\n```\n","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-14","text":"button>\n</form>\n```\n\nAs you can see `x-text` in the above example is being used to allow Alpine to control the text content of the `<span>` element. `x-text` accepts any JavaScript expression inside of it and automatically reacts when any dependencies are updated","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-15","text":"ndencies are updated. Because we are using `$wire.content` to access the value of `$content`, Alpine will automatically update the text content every time `$wire.content` is updated from Livewire; in this case by `wire:model=\"content\"`.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-16","text":"re:model=\"content\"`.\n\n### Mutating Livewire properties\n\nHere is an example of using `$wire` inside Alpine to clear the \"title\" field of a form for creating a post.\n\n```html\n<form wire:submit=\"save\">\n    <input wire:model=\"title\" type=\"text\">\n\n    <button type=\"button\" x-on:click=\"$wire.title = ''\">Clear</button> <!-- [tl! highlight] -->\n\n    <!-- ... -->","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-17","text":"->\n\n    <!-- ... -->\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\nAs a user is filling out the above Livewire form, they can press \"Clear\" and the title field will be cleared without sending a network request from Livewire. The interaction will be \"instant\".\n\nHere's a brief explanation of what's going on to make that happen:","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-18","text":"to make that happen:\n\n* `x-on:click` tells Alpine to listen for a click on the button element\n* When clicked, Alpine runs the provided JS expression: `$wire.title = ''`\n* Because `$wire` is a magic object representing the Livewire component, all properties from your component can be accessed or mutated straight from JavaScript","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-19","text":"ight from JavaScript\n* `$wire.title = ''` sets the value of `$title` in your Livewire component to an empty string\n* Any Livewire utilities like `wire:model` will instantly react to this change, all without sending a server-roundtrip\n* On the next Livewire network request, the `$title` property will be updated to an empty string on the backend","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-20","text":"tring on the backend\n\n### Calling Livewire methods\n\nAlpine can also easily call any Livewire methods/actions by simply calling them directly on `$wire`.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-21","text":"directly on `$wire`.\n\nHere is an example of using Alpine to listen for a \"blur\" event on an input and triggering a form save. The \"blur\" event is dispatched by the browser when a user presses \"tab\" to remove focus from the current element and focus on the next one on the page:","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-22","text":"ext one on the page:\n\n```html\n<form wire:submit=\"save\">\n    <input wire:model=\"title\" type=\"text\" x-on:blur=\"$wire.save()\">  <!-- [tl! highlight] -->\n\n    <!-- ... -->\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\nTypically, you would just use `wire:model.blur=\"title\"` in this situation, however, it's helpful for demonstration purposes how you can achieve this using Alpine.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-23","text":"e this using Alpine.\n\n#### Passing parameters\n\nYou can also pass parameters to Livewire methods by simply passing them to the `$wire` method call.\n\nConsider a component with a `deletePost()` method like so:\n\n```php\npublic function deletePost($postId)\n{\n    $post = Post::find($postId);\n\n    // Authorize user can delete...\n    auth()->user()->can('update', $post);\n\n    $post->delete();\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-24","text":"ost->delete();\n}\n```\n\nNow, you can pass a `$postId` parameter to the `deletePost()` method from Alpine like so:\n\n```html\n<button type=\"button\" x-on:click=\"$wire.deletePost(1)\">\n```\n\nIn general, something like a `$postId` would be generated in Blade. Here's an example of using Blade to determine which `$postId` Alpine passes into `deletePost()`:","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-25","text":"into `deletePost()`:\n\n```html\n@foreach ($posts as $post)\n    <button type=\"button\" x-on:click=\"$wire.deletePost({{ $post->id }})\">\n        Delete \"{{ $post->title }}\"\n    </button>\n@endforeach\n```\n\nIf there are three posts on the page, the above Blade template will render to something like the following in the browser:","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-26","text":"wing in the browser:\n\n```html\n<button type=\"button\" x-on:click=\"$wire.deletePost(1)\">\n    Delete \"The power of walking\"\n</button>\n\n<button type=\"button\" x-on:click=\"$wire.deletePost(2)\">\n    Delete \"How to record a song\"\n</button>\n\n<button type=\"button\" x-on:click=\"$wire.deletePost(3)\">\n    Delete \"Teach what you learn\"\n</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-27","text":"learn\"\n</button>\n```\n\nAs you can see, we've used Blade to render different post IDs into the Alpine `x-on:click` expressions.\n\n#### Blade parameter \"gotchas\"","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-28","text":" parameter \"gotchas\"\n\nThis is an extremely powerful technique, but can be confusing when reading your Blade templates. It can be hard to know which parts are Blade and which parts are Alpine at first glance. Therefore, it's helpful to inspect the HTML rendered on the page to make sure what you are expecting to be rendered is accurate.\n\nHere's an example that commonly confuses people:","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-29","text":"nly confuses people:\n\nLet's say, instead of an ID, your Post model uses UUIDs for indexes (IDs are integers, and UUIDs are long strings of characters).\n\nIf we render the following just like we did with an ID there will be an issue:\n\n```html\n<!-- Warning: this is an example of problematic code... -->\n<button\n    type=\"button\"\n    x-on:click=\"$wire.deletePost({{ $post->uuid }})\"\n>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-30","text":"ost->uuid }})\"\n>\n```\n\nThe above Blade template will render the following in your HTML:\n\n```html\n<!-- Warning: this is an example of problematic code... -->\n<button\n    type=\"button\"\n    x-on:click=\"$wire.deletePost(93c7b04c-c9a4-4524-aa7d-39196011b81a)\"\n>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-31","text":"39196011b81a)\"\n>\n```\n\nNotice the lack of quotes around the UUID string? When Alpine goes to evaluate this expression, JavaScript will throw an error: \"Uncaught SyntaxError: Invalid or unexpected token\".\n\nTo fix this, we need to add quotations around the Blade expression like so:\n\n```html\n<button\n    type=\"button\"\n    x-on:click=\"$wire.deletePost('{{ $post->uuid }}')\"\n>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-32","text":"st->uuid }}')\"\n>\n```\n\nNow the above template will render properly and everything will work as expected:\n\n```html\n<button\n    type=\"button\"\n    x-on:click=\"$wire.deletePost('93c7b04c-c9a4-4524-aa7d-39196011b81a')\"\n>\n```\n\n### Refreshing a component\n\nYou can easily refresh a Livewire component (trigger network roundtrip to re-render a component's Blade view) using `$wire.$refresh()`:","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-33","text":" `$wire.$refresh()`:\n\n```html\n<button type=\"button\" x-on:click=\"$wire.$refresh()\">\n```\n\n## Sharing state using `$wire.entangle`\n\nIn most cases, `$wire` is all you need for interacting with Livewire state from Alpine. However, Livewire provides an additional `$wire.entangle()` utility that can be used to keep values from Livewire in-sync with values in Alpine.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-34","text":"th values in Alpine.\n\nTo demonstrate, consider this dropdown example with its `showDropdown` property entangled between Livewire and Alpine using `$wire.entangle()`. By using entanglement, we are now able to control the state of the dropdown from both Alpine and Livewire:","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-35","text":"Alpine and Livewire:\n\n\n```php\nuse Livewire\\Component;\n\nclass PostDropdown extends Component\n{\n    public $showDropdown = false;\n\n    public function archive()\n    {\n        // ...\n\n        $this->showDropdown = false;\n    }\n\n    public function delete()\n    {\n        // ...\n\n        $this->showDropdown = false;\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-36","text":"= false;\n    }\n}\n```\n\n```blade\n<div x-data=\"{ open: $wire.entangle('showDropdown') }\">\n    <button x-on:click=\"open = true\">Show More...</button>\n\n    <ul x-show=\"open\" x-on:click.outside=\"open = false\">\n        <li><button wire:click=\"archive\">Archive</button></li>\n\n        <li><button wire:click=\"delete\">Delete</button></li>\n    </ul>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-37","text":"    </ul>\n</div>\n```\n\nA user can now toggle the dropdown immediately with Alpine, but when they click a Livewire action like \"Archive\", the dropdown will be told to close from Livewire. Both Alpine and Livewire are welcome to manipulate their respective properties, and the other will automatically update.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-38","text":"utomatically update.\n\nBy default, updating the state is deferred (changes on the client, but not immediately on the server) until the next Livewire request. If you need to update the state server-side as soon as the user clicks, chain the `.live` modifier like so:\n\n```blade\n<div x-data=\"{ open: $wire.entangle('showDropdown').live }\">\n    ...\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-39","text":">\n    ...\n</div>\n```\n\n> [!tip] You might not need `$wire.entangle`","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-40","text":"eed `$wire.entangle`\n> In most cases, you can achieve what you want by using `$wire` to directly access Livewire properties from Alpine rather than entangling them. Entangling two properties rather than relying on one can cause predictability and performance issues when using deeply nested objects that change frequently","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-41","text":"at change frequently. For this reason, `$wire.entangle` has been de-emphasized in Livewire's documentation starting with version 3.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-42","text":"ting with version 3.\n\n> [!warning] Refrain from using the @@entangle directive\n> In Livewire version 2, it was recommended to use Blade's `@@entangle` directive. That is no longer the case in v3. `$wire.entangle()` is preferred as it is a more robust utility and avoids certain [issues when removing DOM elements](https://github.com/livewire/livewire/pull/6833#issuecomment-1902260844).","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-43","text":"comment-1902260844).\n\n## Manually bundling Alpine in your JavaScript build\n\nBy default, Livewire and Alpine's JavaScript is injected onto each Livewire page automatically.\n\nThis is ideal for simpler setups, however, you may want to include your own Alpine components, stores, and plugins into your project.\n\nTo include Livewire and Alpine via your own JavaScript bundle on a page is straightforward.","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-44","text":" is straightforward.\n\nFirst, you must include the `@livewireScriptConfig` directive in your layout file like so:\n\n```blade\n<html>\n<head>\n    <!-- ... -->\n    @livewireStyles\n    @vite(['resources/js/app.js'])\n</head>\n<body>\n    {{ $slot }}\n\n    @livewireScriptConfig <!-- [tl! highlight] -->\n</body>\n</html>\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-45","text":"\n</body>\n</html>\n```\n\nThis allows Livewire to provide your bundle with certain configuration it needs for your app to run properly.\n\nNow you can import Livewire and Alpine in your `resources/js/app.js` file like so:\n\n```js\nimport { Livewire, Alpine } from '../../vendor/livewire/livewire/dist/livewire.esm';\n\n// Register any Alpine directives, components, or plugins here...\n\nLivewire.start()\n```","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-46","text":"Livewire.start()\n```\n\nHere is an example of registering a custom Alpine directive called \"x-clipboard\" in your application:\n\n```js\nimport { Livewire, Alpine } from '../../vendor/livewire/livewire/dist/livewire.esm';\n\nAlpine.directive('clipboard', (el) => {\n    let text = el.textContent\n\n    el.addEventListener('click', () => {\n        navigator.clipboard.writeText(text)\n    })\n})","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"298d89daa167710882e7c5fa5b629d2f-47","text":"Text(text)\n    })\n})\n\nLivewire.start()\n```\n\nNow the `x-clipboard` directive will be available to all your Alpine components in your Livewire application.\n","source":"/Users/fyyx/Documents/livewire/docs/alpine.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-0","text":"\nLivewire makes it easy to bind a component property's value with form inputs using `wire:model`.\n\nHere is a simple example of using `wire:model` to bind the `$title` and `$content` properties with form inputs in a \"Create Post\" component:\n\n```php\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    public $title = '';\n\n    public $content = '';","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-1","text":"ublic $content = '';\n\n    public function save()\n    {\n\t\t$post = Post::create([\n\t\t\t'title' => $this->title\n\t\t\t'content' => $this->content\n\t\t]);\n\n        // ...\n    }\n}\n```\n\n```blade\n<form wire:submit=\"save\">\n    <label>\n        <span>Title</span>\n\n        <input type=\"text\" wire:model=\"title\"> <!-- [tl! highlight] -->\n    </label>\n\n    <label>\n        <span>Content</span>","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-2","text":"<span>Content</span>\n\n        <textarea wire:model=\"content\"></textarea> <!-- [tl! highlight] -->\n    </label>\n\n\t<button type=\"submit\">Save</button>\n</form>\n```\n\nBecause both inputs use `wire:model`, their values will be synchronized with the server's properties when the \"Save\" button is pressed.","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-3","text":"\" button is pressed.\n\n> [!warning] \"Why isn't my component live updating as I type?\"","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-4","text":"updating as I type?\"\n> If you tried this in your browser and are confused why the title isn't automatically updating, it's because Livewire only updates a component when an \"action\" is submitted—like pressing a submit button—not when a user types into a field. This cuts down on network requests and improves performance","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-5","text":"improves performance. To enable \"live\" updating as a user types, you can use `wire:model.live` instead. [Learn more about data binding](/docs/properties#data-binding).","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-6","text":"rties#data-binding).\n\n## Customizing update timing\n\nBy default, Livewire will only send a network request when an action is performed (like `wire:click` or `wire:submit`), NOT when a `wire:model` input is updated.\n\nThis drastically improves the performance of Livewire by reducing network requests and provides a smoother experience for your users.","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-7","text":"ence for your users.\n\nHowever, there are occasions where you may want to update the server more frequently for things like real-time validation.\n\n### Live updating\n\nTo send property updates to the server as a user types into an input-field, you can append the `.live` modifier to `wire:model`:\n\n```html\n<input type=\"text\" wire:model.live=\"title\">\n```\n\n#### Customizing the debounce","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-8","text":"omizing the debounce\n\nBy default, when using `wire:model.live`, Livewire adds a 150 millisecond debounce to server updates. This means if a user is continually typing, Livewire will wait until the user stops typing for 150 milliseconds before sending a request.\n\nYou can customize this timing by appending `.debounce.Xms` to the input. Here is an example of changing the debounce to 250 milliseconds:","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-9","text":"to 250 milliseconds:\n\n```html\n<input type=\"text\" wire:model.live.debounce.250ms=\"title\">\n```\n\n### Updating on \"blur\" event\n\nBy appending the `.blur` modifier, Livewire will only send network requests with property updates when a user clicks away from an input, or presses the tab key to move to the next input.","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-10","text":"e to the next input.\n\nAdding `.blur` is helpful for scenarios where you want to update the server more frequently, but not as a user types. For example, real-time validation is a common instance where `.blur` is helpful.\n\n```html\n<input type=\"text\" wire:model.blur=\"title\">\n```\n\n### Updating on \"change\" event","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-11","text":"ng on \"change\" event\n\nThere are times when the behavior of `.blur` isn't exactly what you want and instead `.change` is.","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-12","text":"nstead `.change` is.\n\nFor example, if you want to run validation every time a select input is changed, by adding `.change`, Livewire will send a network request and validate the property as soon as a user selects a new option. As opposed to `.blur` which will only update the server after the user tabs away from the select input.","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-13","text":"om the select input.\n\n```html\n<select wire:model.change=\"title\">\n    <!-- ... -->\n</select>\n```\n\nAny changes made to the text input will be automatically synchronized with the `$title` property in your Livewire component.\n\n## All available modifiers","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-14","text":" available modifiers\n\n Modifier          | Description\n-------------------|-------------------------------------------------------------------------\n `.live`           | Send updates as a user types\n `.blur`           | Only send updates on the `blur` event\n `.change`         | Only send updates on the the `change` event\n `.lazy`           | An alias for `.change`","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-15","text":" alias for `.change`\n `.debounce.[?]ms` | Debounce the sending of updates by the specified millisecond delay\n `.throttle.[?]ms` | Throttle network request updates by the specified millisecond interval\n `.number`         | Cast the text value of an input to `int` on the server\n `.boolean`        | Cast the text value of an input to `bool` on the server","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-16","text":"`bool` on the server\n `.fill`           | Use the initial value provided by a \"value\" HTML attribute on page-load","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-17","text":"tribute on page-load\n\n## Input fields\n\nLivewire supports most native input elements out of the box. Meaning you should just be able to attach `wire:model` to any input element in the browser and easily bind properties to them.\n\nHere's a comprehensive list of the different available input types and how you use them in a Livewire context.\n\n### Text inputs","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-18","text":"xt.\n\n### Text inputs\n\nFirst and foremost, text inputs are the bedrock of most forms. Here's how to bind a property named \"title\" to one:\n\n```blade\n<input type=\"text\" wire:model=\"title\">\n```\n\n### Textarea inputs\n\nTextarea elements are similarly straightforward. Simply add `wire:model` to a textarea and the value will be bound:\n\n```blade\n<textarea type=\"text\" wire:model=\"content\"></textarea>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-19","text":"ent\"></textarea>\n```\n\nIf the \"content\" value is initialized with a string, Livewire will fill the textarea with that value - there's no need to do something like the following:\n\n```blade\n<!-- Warning: This snippet demonstrates what NOT to do... -->\n\n<textarea type=\"text\" wire:model=\"content\">{{ $content }}</textarea>\n```\n\n### Checkboxes","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-20","text":"\n```\n\n### Checkboxes\n\nCheckboxes can be used for single values, such as when toggling a boolean property. Or, checkboxes may be used to toggle a single value in a group of related values. We'll discuss both scenarios:\n\n#### Single checkbox","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-21","text":"#### Single checkbox\n\nAt the end of a signup form, you might have a checkbox allowing the user to opt-in to email updates. You might call this property `$receiveUpdates`. You can easily bind this value to the checkbox using `wire:model`:\n\n```blade\n<input type=\"checkbox\" wire:model=\"receiveUpdates\">\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-22","text":"receiveUpdates\">\n```\n\nNow when the `$receiveUpdates` value is `false`, the checkbox will be unchecked. Of course, when the value is `true`, the checkbox will be checked.\n\n#### Multiple checkboxes\n\nNow, let's say in addition to allowing the user to decide to receive updates, you have an array property in your class called `$updateTypes`, allowing the user to choose from a variety of update types:","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-23","text":"ety of update types:\n\n```php\npublic $updateTypes = [];\n```\n\nBy binding multiple checkboxes to the `$updateTypes` property, the user can select multiple update types and they will be added to the `$updateTypes` array property:","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-24","text":"pes` array property:\n\n```blade\n<input type=\"checkbox\" value=\"email\" wire:model=\"updateTypes\">\n<input type=\"checkbox\" value=\"sms\" wire:model=\"updateTypes\">\n<input type=\"checkbox\" value=\"notification\" wire:model=\"updateTypes\">\n```\n\nFor example, if the user checks the first two boxes but not the third, the value of `$updateTypes` will be: `[\"email\", \"sms\"]`\n\n### Radio buttons","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-25","text":"`\n\n### Radio buttons\n\nTo toggle between two different values for a single property, you may use radio buttons:\n\n```blade\n<input type=\"radio\" value=\"yes\" wire:model=\"receiveUpdates\">\n<input type=\"radio\" value=\"no\" wire:model=\"receiveUpdates\">\n```\n\n### Select dropdowns","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-26","text":"### Select dropdowns\n\nLivewire makes it simple to work with `<select>` dropdowns. When adding `wire:model` to a dropdown, the currently selected value will be bound to the provided property name and vice versa.\n\nIn addition, there's no need to manually add `selected` to the option that will be selected - Livewire handles that for you automatically.","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-27","text":"r you automatically.\n\nBelow is an example of a select dropdown filled with a static list of states:\n\n```blade\n<select wire:model=\"state\">\n    <option value=\"AL\">Alabama</option>\n    <option value=\"AK\">Alaska</option>\n    <option value=\"AZ\">Arizona</option>\n    ...\n</select>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-28","text":"   ...\n</select>\n```\n\nWhen a specific state is selected, for example, \"Alaska\", the `$state` property on the component will be set to `AK`. If you would prefer the value to be set to \"Alaska\" instead of \"AK\", you can leave the `value=\"\"` attribute off the `<option>` element entirely.\n\nOften, you may build your dropdown options dynamically using Blade:","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-29","text":"mically using Blade:\n\n```blade\n<select wire:model=\"state\">\n    @foreach (\\App\\Models\\State::all() as $state)\n        <option value=\"{{ $state->id }}\">{{ $state->label }}</option>\n    @endforeach\n</select>\n```\n\nIf you don't have a specific option selected by default, you may want to show a muted placeholder option by default, such as \"Select a state\":","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-30","text":"as \"Select a state\":\n\n```blade\n<select wire:model=\"state\">\n    <option disabled value=\"\">Select a state...</option>\n\n    @foreach (\\App\\Models\\State::all() as $state)\n        <option value=\"{{ $state->id }}\">{{ $state->label }}</option>\n    @endforeach\n</select>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-31","text":"oreach\n</select>\n```\n\nAs you can see, there is no \"placeholder\" attribute for a select menu like there is for text inputs. Instead, you have to add a `disabled` option element as the first option in the list.\n\n### Dependent select dropdowns\n\nSometimes you may want one select menu to be dependent on another. For example, a list of cities that changes based on which state is selected.","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-32","text":"h state is selected.\n\nFor the most part, this works as you'd expect, however there is one important gotcha: You must add a `wire:key` to the changing select so that Livewire properly refreshes its value when the options change.\n\nHere's an example of two selects, one for states, one for cities. When the state select changes, the options in the city select will change properly:","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-33","text":"ill change properly:\n\n```blade\n<!-- States select menu... -->\n<select wire:model.live=\"selectedState\">\n    @foreach (State::all() as $state)\n        <option value=\"{{ $state->id }}\">{{ $state->label }}</option>\n    @endforeach\n</select>","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-34","text":"endforeach\n</select>\n\n<!-- Cities dependent select menu... -->\n<select wire:model.live=\"selectedCity\" wire:key=\"{{ $selectedState }}\"> <!-- [tl! highlight] -->\n    @foreach (City::whereStateId($selectedState->id)->get() as $city)\n        <option value=\"{{ $city->id }}\">{{ $city->label }}</option>\n    @endforeach\n</select>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-35","text":"oreach\n</select>\n```\n\nAgain, the only thing non-standard here is the `wire:key` that has been added to the second select. This ensures that when the state changes, the \"selectedCity\" value will be reset properly.\n\n### Multi-select dropdowns","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-36","text":"lti-select dropdowns\n\nIf you are using a \"multiple\" select menu, Livewire works as expected. In this example, states will be added to the `$states` array property when they are selected and removed if they are deselected:","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"8b0e8d5702d0149e1ff8dd1729abef1b-37","text":"they are deselected:\n\n```blade\n<select wire:model=\"states\" multiple>\n    <option value=\"AL\">Alabama</option>\n    <option value=\"AK\">Alaska</option>\n    <option value=\"AZ\">Arizona</option>\n    ...\n</select>\n```\n\n## Going deeper\n\nFor a more complete documentation on using `wire:model` in the context of HTML forms, visit the [Livewire forms documentation page](/docs/forms).\n","source":"/Users/fyyx/Documents/livewire/docs/wire-model.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-0","text":"Polling is a technique used in web applications to \"poll\" the server (send requests on a regular interval) for updates. It's a simple way to keep a page up-to-date without the need for a more sophisticated technology like [WebSockets](/docs/events#real-time-events-using-laravel-echo).\n\n## Basic usage\n\nUsing polling inside Livewire is as simple as adding `wire:poll` to an element.","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-1","text":"poll` to an element.\n\nBelow is an example of a `SubscriberCount` component that shows a user's subscriber count:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-2","text":" Livewire\\Component;\n\nclass SubscriberCount extends Component\n{\n    public function render()\n    {\n        return view('livewire.subscriber-count', [\n            'count' => Auth::user()->subscribers->count(),\n        ]);\n    }\n}\n```\n\n```blade\n<div wire:poll> <!-- [tl! highlight] -->\n    Subscribers: {{ $count }}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-3","text":"$count }}\n</div>\n```\n\nNormally, this component would show the subscriber count for the user and never update until the page was refreshed. However, because of `wire:poll` on the component's template, this component will now refresh itself every `2.5` seconds, keeping the subscriber count up-to-date.\n\nYou can also specify an action to fire on the polling interval by passing a value to `wire:poll`:","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-4","text":"alue to `wire:poll`:\n\n```blade\n<div wire:poll=\"refreshSubscribers\">\n    Subscribers: {{ $count }}\n</div>\n```\n\nNow, the `refreshSubscribers()` method on the component will be called every `2.5` seconds.\n\n## Timing control","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-5","text":".\n\n## Timing control\n\nThe primary drawback of polling is that it can be resource intensive. If you have a thousand visitors on a page that uses polling, one thousand network requests will be triggered every `2.5` seconds.\n\nThe best way to reduce requests in this scenario is simply to make the polling interval longer.","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-6","text":"ing interval longer.\n\nYou can manually control how often the component will poll by appending the desired duration to `wire:poll` like so:\n\n```blade\n<div wire:poll.15s> <!-- In seconds... -->\n\n<div wire:poll.15000ms> <!-- In milliseconds... -->\n```\n\n## Background throttling","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-7","text":"ackground throttling\n\nTo further cut down on server requests, Livewire automatically throttles polling when a page is in the background. For example, if a user keeps a page open in a different browser tab, Livewire will reduce the number of polling requests by 95% until the user revisits the tab.","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-8","text":"er revisits the tab.\n\nIf you want to opt-out of this behavior and keep polling continuously, even when a tab is in the background, you can add the `.keep-alive` modifier to `wire:poll`:\n\n```blade\n<div wire:poll.keep-alive>\n```\n\n##  Viewport throttling","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-9","text":" Viewport throttling\n\nAnother measure you can take to only poll when necessary, is to add the `.visible` modifier to `wire:poll`. The `.visible` modifier instructs Livewire to only poll the component when it is visible on the page:\n\n```blade\n<div wire:poll.visible>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"3bcf5e6789a3418ffdc6aadd998fc4c7-10","text":"re:poll.visible>\n```\n\nIf a component using `wire:visible` is at the bottom of a long page, it won't start polling until the user scrolls it into the viewport. When the user scrolls away, it will stop polling again.\n","source":"/Users/fyyx/Documents/livewire/docs/wire-poll.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-0","text":"> [!warning] Get comfortable with Livewire first\n> Before using Volt, we recommend getting familiar with standard, class-based Livewire usage. This will allow you to quickly transfer your knowledge of Livewire into writing components using Volt's functional API.","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-1","text":"lt's functional API.\n\nVolt is an elegantly crafted functional API for Livewire that supports single-file components, allowing a component's PHP logic and Blade templates to coexist in the same file. Behind the scenes, the functional API is compiled to Livewire class components and linked with the template present in the same file.\n\nA simple Volt component looks like the following:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-2","text":"owing:\n\n```php\n<?php\n\nuse function Livewire\\Volt\\{state};\n\nstate(['count' => 0]);\n\n$increment = fn () => $this->count++;\n\n?>\n\n<div>\n    <h1>{{ $count }}</h1>\n    <button wire:click=\"increment\">+</button>\n</div>\n```\n\n## Installation\n\nTo get started, install Volt into your project using the Composer package manager:\n\n```bash\ncomposer require livewire/volt\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-3","text":"re livewire/volt\n```\n\nAfter installing Volt, you may execute the `volt:install` Artisan command, which will install Volt's service provider file into your application. This service provider specifies the mounted directories in which Volt will search for single file components:\n\n```bash\nphp artisan volt:install\n```\n\n## Creating components","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-4","text":" Creating components\n\nYou may create a Volt component by placing a file with the `.blade.php` extension in any of your Volt mounted directories. By default, the `VoltServiceProvider` mounts the `resources/views/livewire` and `resources/views/pages` directories, but you may customize these directories in your Volt service provider's `boot` method.","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-5","text":"der's `boot` method.\n\nFor convenience, you may use the `make:volt` Artisan command to create a new Volt component:\n\n```bash\nphp artisan make:volt counter\n```\n\nBy adding the `--test` directive when generating a component, a corresponding test file will also be generated. If you want the associated test to use [Pest](https://pestphp.com/), you should use the `--pest` flag:","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-6","text":"e the `--pest` flag:\n\n```bash\nphp artisan make:volt counter --test --pest\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-7","text":"er --test --pest\n```\n\n\nBy adding the `--class` directive it will generate a class-based volt component.\n\n```bash\nphp artisan make:volt counter --class\n```\n\n## API style","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-8","text":"ss\n```\n\n## API style\n\nBy utilizing Volt's functional API, we can define a Livewire component's logic through imported `Livewire\\Volt` functions. Volt then transforms and compiles the functional code into a conventional Livewire class, enabling us to leverage the extensive capabilities of Livewire with reduced boilerplate.","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-9","text":"reduced boilerplate.\n\nVolt's API automatically binds any closure it uses to the underlying component. So, at any time, actions, computed properties, or listeners can refer to the component using the `$this` variable:\n\n```php\nuse function Livewire\\Volt\\{state};\n\nstate(['count' => 0]);\n\n$increment = fn () => $this->count++;\n\n// ...\n```\n\n### Class-based Volt components","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-10","text":"ased Volt components\n\nIf you would like to enjoy the single-file component capabilities of Volt while still writing class-based components, we've got you covered. To get started, define an anonymous class that extends `Livewire\\Volt\\Component`. Within the class, you may utilize all of the features of Livewire using traditional Livewire syntax:\n\n```blade\n<?php\n\nuse Livewire\\Volt\\Component;","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-11","text":"wire\\Volt\\Component;\n\nnew class extends Component {\n    public $count = 0;\n\n    public function increment()\n    {\n        $this->count++;\n    }\n} ?>\n\n<div>\n    <h1>{{ $count }}</h1>\n    <button wire:click=\"increment\">+</button>\n</div>\n```\n\n#### Class attributes","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-12","text":"### Class attributes\n\nJust like typical Livewire components, Volt components support class attributes. When utilizing anonymous PHP classes, class attributes should be defined after the `new` keyword:\n\n```blade\n<?php\n\nuse Livewire\\Attributes\\{Layout, Title};\nuse Livewire\\Volt\\Component;\n\nnew\n#[Layout('layouts.guest')]\n#[Title('Login')]\nclass extends Component\n{\n    public string $name = '';","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-13","text":"c string $name = '';\n\n    // ...\n```\n\n#### Providing additional view data\n\nWhen using class-based Volt components, the rendered view is the template present in the same file. If you need to pass additional data to the view each time it is rendered, you may use the `with` method. This data will be passed to the view in addition to the component's public properties:\n\n```blade\n<?php","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-14","text":"ies:\n\n```blade\n<?php\n\nuse Livewire\\WithPagination;\nuse Livewire\\Volt\\Component;\nuse App\\Models\\Post;\n\nnew class extends Component {\n    use WithPagination;\n\n    public function with(): array\n    {\n        return [\n            'posts' => Post::paginate(10),\n        ];\n    }\n} ?>\n\n<div>\n    <!-- ... -->\n</div>\n```\n\n#### Modifying the view instance","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-15","text":"ng the view instance\n\nSometimes, you may wish to interact with the view instance directly, for example, to set the view's title using a translated string. To achieve this, you may define a `rendering` method on your component:\n\n```blade\n<?php\n\nuse Illuminate\\View\\View;\nuse Livewire\\Volt\\Component;","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-16","text":"wire\\Volt\\Component;\n\nnew class extends Component {\n    public function rendering(View $view): void\n    {\n        $view->title('Create Post');\n\n        // ...\n    }\n\n    // ...\n```\n\n## Rendering and mounting components\n\nJust like a typical Livewire component, Volt components may be rendered using Livewire's tag syntax or the `@livewire` Blade directive:","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-17","text":"re` Blade directive:\n\n```blade\n<livewire:user-index :users=\"$users\" />\n```\n\nTo declare the component's accepted properties, you may use the `state` function:\n\n```php\nuse function Livewire\\Volt\\{state};\n\nstate('users');\n\n// ...\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-18","text":"users');\n\n// ...\n```\n\nIf necessary, you can intercept the properties passed to the component by providing a closure to the `state` function, allowing you to interact with and modify the given value:\n\n```php\nuse function Livewire\\Volt\\{state};\n\nstate(['count' => fn ($users) => count($users)]);\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-19","text":"count($users)]);\n```\n\nThe `mount` function may be used to define the \"mount\" [lifecycle hook](/docs/lifecycle-hooks) of the Livewire component. The parameters provided to the component will be injected into this method. Any other parameters required by the mount hook will be resolved by Laravel's service container:\n\n```php\nuse App\\Services\\UserCounter;\nuse function Livewire\\Volt\\{mount};","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-20","text":"vewire\\Volt\\{mount};\n\nmount(function (UserCounter $counter, $users) {\n    $counter->store('userCount', count($users));\n\n    // ...\n});\n```\n\n### Full-page components\n\nOptionally, you may render a Volt component as a full page component by defining a Volt route in your application's `routes/web.php` file:\n\n```php\nuse Livewire\\Volt\\Volt;\n\nVolt::route('/users', 'user-index');\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-21","text":", 'user-index');\n```\n\nBy default, the component will be rendered using the `components.layouts.app` layout. You may customize this layout file using the `layout` function:\n\n```php\nuse function Livewire\\Volt\\{layout, state};\n\nstate('users');\n\nlayout('components.layouts.admin');\n\n// ...\n```\n\nYou may also customize the title of the page using the `title` function:","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-22","text":"he `title` function:\n\n```php\nuse function Livewire\\Volt\\{layout, state, title};\n\nstate('users');\n\nlayout('components.layouts.admin');\n\ntitle('Users');\n\n// ...\n```\n\nIf the title relies on component state or an external dependency, you may pass a closure to the `title` function instead:\n\n```php\nuse function Livewire\\Volt\\{layout, state, title};\n\nstate('users');\n\nlayout('components.layouts.admin');","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-23","text":"nts.layouts.admin');\n\ntitle(fn () => 'Users: ' . $this->users->count());\n```\n\n## Properties\n\nVolt properties, like Livewire properties, are conveniently accessible in the view and persist between Livewire updates. You can define a property using the `state` function:\n\n```php\n<?php\n\nuse function Livewire\\Volt\\{state};\n\nstate(['count' => 0]);\n\n?>\n\n<div>\n    {{ $count }}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-24","text":"$count }}\n</div>\n```\n\nIf the initial value of a state property relies on outside dependencies, such as database queries, models, or container services, its resolution should be encapsulated within a closure. This prevents the value from being resolved until it is absolutely necessary:\n\n```php\nuse App\\Models\\User;\nuse function Livewire\\Volt\\{state};\n\nstate(['count' => fn () => User::count()]);\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-25","text":"User::count()]);\n```\n\nIf the initial value of a state property is being injected via [Laravel Folio's](https://github.com/laravel/folio) route model binding, it should also be encapsulated within a closure:\n\n```php\nuse App\\Models\\User;\nuse function Livewire\\Volt\\{state};\n\nstate(['user' => fn () => $user]);\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-26","text":"n () => $user]);\n```\n\nOf course, properties may also be declared without explicitly specifying their initial value. In such cases, their initial value will be `null` or will be set based on the properties passed into the component when it is rendered:\n\n```php\nuse function Livewire\\Volt\\{mount, state};\n\nstate(['count']);\n\nmount(function ($users) {\n    $this->count = count($users);\n\n    //\n});\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-27","text":"rs);\n\n    //\n});\n```\n\n### Locked properties\n\nLivewire offers the ability to safeguard properties by enabling you to \"lock\" them, thereby preventing any modifications from occurring on the client-side. To achieve this using Volt, simply chain the `locked` method on the state you wish to protect:\n\n```php\nstate(['id'])->locked();\n```\n\n### Reactive properties","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-28","text":" Reactive properties\n\nWhen working with nested components, you may find yourself in a situation where you need to pass a property from a parent component to a child component, and have the child component [automatically update](/docs/nesting#reactive-props) when the parent component updates the property.","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-29","text":"pdates the property.\n\nTo achieve this using Volt, you may chain the `reactive` method on the state you wish to be reactive:\n\n```php\nstate(['todos'])->reactive();\n```\n\n### Modelable properties","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-30","text":"Modelable properties\n\nIn cases where you don't want to make use of reactive properties, Livewire provides a [modelable feature](/docs/nesting#binding-to-child-data-using-wiremodel) where you may share state between parent component and child component using `wire:model` directly on a child component.","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-31","text":"n a child component.\n\nTo achieve this using Volt, simply chain the `modelable` method on the state you wish to be modelable:\n\n```php\nstate(['form'])->modelable();\n```\n\n### Computed properties","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-32","text":" Computed properties\n\nLivewire also allows you to define [computed properties](/docs/computed-properties), which can be useful for lazily fetching information needed by your component. Computed property results are \"memoized\", or cached in memory, for an individual Livewire request lifecycle.","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-33","text":"e request lifecycle.\n\nTo define a computed property, you may use the `computed` function. The name of the variable will determine the name of the computed property:\n\n```php\n<?php\n\nuse App\\Models\\User;\nuse function Livewire\\Volt\\{computed};\n\n$count = computed(function () {\n    return User::count();\n});\n\n?>\n\n<div>\n    {{ $this->count }}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-34","text":">count }}\n</div>\n```\n\nYou may persist the computed property's value in your application's cache by chaining the `persist` method onto the computed property definition:\n\n```php\n$count = computed(function () {\n    return User::count();\n})->persist();\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-35","text":";\n})->persist();\n```\n\nBy default, Livewire caches the computed property's value for 3600 seconds. You may customize this value by providing the desired number of seconds to the `persist` method:\n\n```php\n$count = computed(function () {\n    return User::count();\n})->persist(seconds: 10);\n```\n\n## Actions","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-36","text":"10);\n```\n\n## Actions\n\nLivewire [actions](/docs/actions) provide a convenient way to listen to page interactions and invoke a corresponding method on your component, resulting in the re-rendering of the component. Often, actions are invoked in response to the user clicking a button.","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-37","text":"r clicking a button.\n\nTo define a Livewire action using Volt, you simply need to define a closure. The name of the variable containing the closure will determine the name of the action:\n\n```php\n<?php\n\nuse function Livewire\\Volt\\{state};\n\nstate(['count' => 0]);\n\n$increment = fn () => $this->count++;\n\n?>\n\n<div>\n    <h1>{{ $count }}</h1>\n    <button wire:click=\"increment\">+</button>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-38","text":"</button>\n</div>\n```\n\nWithin the closure, the `$this` variable is bound to the underlying Livewire component, giving you the ability to access other methods on the component just as you would in a typical Livewire component:\n\n```php\nuse function Livewire\\Volt\\{state};\n\nstate(['count' => 0]);\n\n$increment = function () {\n    $this->dispatch('count-updated');\n\n    //\n};\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-39","text":"ed');\n\n    //\n};\n```\n\nYour action may also receive arguments or dependencies from Laravel's service container:\n\n```php\nuse App\\Repositories\\PostRepository;\nuse function Livewire\\Volt\\{state};\n\nstate(['postId']);\n\n$delete = function (PostRepository $posts) {\n    $posts->delete($this->postId);\n\n    // ...\n};\n```\n\n### Renderless actions","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-40","text":"# Renderless actions\n","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-41","text":" Renderless actions\n\nIn some cases, your component might declare an action that does not perform any operations that would cause the component's rendered Blade template to change","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-42","text":"e template to change. If that's the case, you can [skip the rendering phase](/docs/actions#skipping-re-renders) of Livewire's lifecycle by encapsulating the action within the `action` function and chaining the `renderless` method onto its definition:","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-43","text":"onto its definition:\n\n```php\nuse function Livewire\\Volt\\{action};\n\n$incrementViewCount = action(fn () => $this->viewCount++)->renderless();\n```\n\n### Protected helpers","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-44","text":"## Protected helpers\n\nBy default, all Volt actions are \"public\" and may be invoked by the client. If you wish to create a function that is [only accessible from within your actions](/docs/actions#keep-dangerous-methods-protected-or-private), you may use the `protect` function:\n\n```php\nuse App\\Repositories\\PostRepository;\nuse function Livewire\\Volt\\{protect, state};\n\nstate(['postId']);","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-45","text":"\n\nstate(['postId']);\n\n$delete = function (PostRepository $posts) {\n    $this->ensurePostCanBeDeleted();\n\n    $posts->delete($this->postId);\n\n    // ...\n};\n\n$ensurePostCanBeDeleted = protect(function () {\n    // ...\n});\n```\n\n## Forms","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-46","text":"..\n});\n```\n\n## Forms\n\nLivewire's [forms](/docs/forms) provide a convenient way to deal with form validation and submission within a single class. To use a Livewire form within a Volt component, you may utilize the `form` function:\n\n```php\n<?php\n\nuse App\\Livewire\\Forms\\PostForm;\nuse function Livewire\\Volt\\{form};\n\nform(PostForm::class);\n\n$save = function () {\n    $this->form->store();","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-47","text":"this->form->store();\n\n    // ...\n};\n\n?>\n\n<form wire:submit=\"save\">\n    <input type=\"text\" wire:model=\"form.title\">\n    @error('form.title') <span class=\"error\">{{ $message }}</span> @enderror\n\n    <button type=\"submit\">Save</button>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-48","text":"/button>\n</form>\n```\n\nAs you can see, the `form` function accepts the name of a Livewire form class. Once defined, the form can be accessed via the `$this->form` property within your component.\n\nIf you want to use a different property name for your form, you can pass the name as the second argument to the `form` function:\n\n```php\nform(PostForm::class, 'postForm');","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-49","text":":class, 'postForm');\n\n$save = function () {\n    $this->postForm->store();\n\n    // ...\n};\n```\n\n## Listeners\n\nLivewire's global [event system](/docs/events) enables communication between components. If two Livewire components exist on a page, they can communicate by utilizing events and listeners. When using Volt, listeners can be defined using the `on` function:","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-50","text":"g the `on` function:\n\n```php\nuse function Livewire\\Volt\\{on};\n\non(['eventName' => function () {\n    //\n}]);\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-51","text":"() {\n    //\n}]);\n```\n\nIf you need to assign dynamic names to event listeners, such as those based on the authenticated user or data passed to the component, you can pass a closure to the `on` function. This closure can receive any component parameter, as well as additional dependencies which will be resolved via Laravel's service container:","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-52","text":"s service container:\n\n```php\non(fn ($post) => [\n    'event-'.$post->id => function () {\n        //\n    }),\n]);\n```\n\nFor convenience, component data may also be referenced when defining listeners using \"dot\" notation:\n\n```php\non(['event-{post.id}' => function () {\n    //\n}]);\n```\n\n## Lifecycle hooks","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-53","text":"\n\n## Lifecycle hooks\n\nLivewire has a variety of [lifecycle hooks](/docs/lifecycle-hooks) that may be used to execute code at various points in a component's lifecycle. Using Volt's convenient API, you can define these lifecycle hooks using their corresponding functions:\n\n```php\nuse function Livewire\\Volt\\{boot, booted, ...};","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-54","text":"{boot, booted, ...};\n\nboot(fn () => /* ... */);\nbooted(fn () => /* ... */);\nmount(fn () => /* ... */);\nhydrate(fn () => /* ... */);\nhydrate(['count' => fn () => /* ... */]);\ndehydrate(fn () => /* ... */);\ndehydrate(['count' => fn () => /* ... */]);\nupdating(['count' => fn () => /* ... */]);\nupdated(['count' => fn () => /* ... */]);\n```\n\n## Lazy loading placeholders","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-55","text":"loading placeholders\n\nWhen rendering Livewire components, you may pass the `lazy` parameter to a Livewire component to [defer its loading](/docs/lazy) until the initial page is fully loaded. By default, Livewire inserts `<div></div>` tags into the DOM where the component will be loaded.","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-56","text":"nent will be loaded.\n\nIf you would like to customize the HTML that is displayed within the component's placeholder while the initial page is loaded, you may use the `placeholder` function:\n\n```php\nuse function Livewire\\Volt\\{placeholder};\n\nplaceholder('<div>Loading...</div>');\n```\n\n## Validation","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-57","text":";\n```\n\n## Validation\n\nLivewire offers easy access to Laravel's powerful [validation features](/docs/validation). Using Volt's API, you may define your component's validation rules using the `rules` function. Like traditional Livewire components, these rules will be applied to your component data when you invoke the `validate` method:\n\n```php\n<?php\n\nuse function Livewire\\Volt\\{rules};","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-58","text":"vewire\\Volt\\{rules};\n\nrules(['name' => 'required|min:6', 'email' => 'required|email']);\n\n$submit = function () {\n    $this->validate();\n\n    // ...\n};\n\n?>\n\n<form wire:submit.prevent=\"submit\">\n    //\n</form>\n```\n\nIf you need to define rules dynamically, such as rules based on the authenticated user or a information from your database, you can provide a closure to the `rules` function:","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-59","text":"he `rules` function:\n\n```php\nrules(fn () => [\n    'name' => ['required', 'min:6'],\n    'email' => ['required', 'email', 'not_in:'.Auth::user()->email]\n]);\n```\n\n### Error messages and attributes\n\nTo modify the validation messages or attributes used during validation, you can chain the `messages` and `attributes` methods onto your `rules` definition:\n\n```php\nuse function Livewire\\Volt\\{rules};","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-60","text":"vewire\\Volt\\{rules};\n\nrules(['name' => 'required|min:6', 'email' => 'required|email'])\n    ->messages([\n        'email.required' => 'The :attribute may not be empty.',\n        'email.email' => 'The :attribute format is invalid.',\n    ])->attributes([\n        'email' => 'email address',\n    ]);\n```\n\n## File uploads","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-61","text":"```\n\n## File uploads\n\nWhen using Volt, [uploading and storing files](/docs/uploads) is much easier thanks to Livewire. To include the `Livewire\\WithFileUploads` trait on your functional Volt component, you may use the `usesFileUploads` function:\n\n```php\nuse function Livewire\\Volt\\{state, usesFileUploads};\n\nusesFileUploads();\n\nstate(['photo']);","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-62","text":";\n\nstate(['photo']);\n\n$save = function () {\n    $this->validate([\n        'photo' => 'image|max:1024',\n    ]);\n\n    $this->photo->store('photos');\n};\n```\n\n## URL query parameters","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-63","text":"URL query parameters\n\nSometimes it's useful to [update the browser's URL query parameters](/docs/url) when your component state changes. In these cases, you can use the `url` method to instruct Livewire to sync the URL query parameters with a piece of component state:\n\n```php\n<?php\n\nuse App\\Models\\Post;\nuse function Livewire\\Volt\\{computed, state};\n\nstate(['search'])->url();","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-64","text":"(['search'])->url();\n\n$posts = computed(function () {\n    return Post::where('title', 'like', '%'.$this->search.'%')->get();\n});\n\n?>\n\n<div>\n    <input wire:model.live=\"search\" type=\"search\" placeholder=\"Search posts by title...\">\n\n    <h1>Search Results:</h1>","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-65","text":"Search Results:</h1>\n\n    <ul>\n        @foreach($this->posts as $post)\n            <li wire:key=\"{{ $post->id }}\">{{ $post->title }}</li>\n        @endforeach\n    </ul>\n</div>\n```\n\nAdditional URL query parameters options supported by Livewire, such as URL query parameters aliases, may also be provided to the `url` method:\n\n```php\nuse App\\Models\\Post;\nuse function Livewire\\Volt\\{state};","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-66","text":"vewire\\Volt\\{state};\n\nstate(['page' => 1])->url(as: 'p', history: true, keep: true);\n\n// ...\n```\n\n## Pagination\n\nLivewire and Volt also have complete support for [pagination](/docs/pagination). To include Livewire's `Livewire\\WithPagination` trait on your functional Volt component, you may use the `usesPagination` function:\n\n```php\n<?php\n\nuse function Livewire\\Volt\\{with, usesPagination};","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-67","text":"th, usesPagination};\n\nusesPagination();\n\nwith(fn () => ['posts' => Post::paginate(10)]);\n\n?>\n\n<div>\n    @foreach ($posts as $post)\n        //\n    @endforeach\n\n    {{ $posts->links() }}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-68","text":"inks() }}\n</div>\n```\n\nLike Laravel, Livewire's default pagination view uses Tailwind classes for styling. If you use Bootstrap in your application, you can enable the Bootstrap pagination theme by specifying your desired theme when invoking the `usesPagination` function:\n\n```php\nusesPagination(theme: 'bootstrap');\n```\n\n## Custom traits and interfaces","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-69","text":"raits and interfaces\n\nTo include any arbitrary trait or interface on your functional Volt component, you may use the `uses` function:\n\n```php\nuse function Livewire\\Volt\\{uses};\n\nuse App\\Contracts\\Sorting;\nuse App\\Concerns\\WithSorting;\n\nuses([Sorting::class, WithSorting::class]);\n```\n\n## Anonymous components","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-70","text":"Anonymous components\n\nSometimes, you may want to convert a small portion of a page into a Volt component without extracting it into a separate file. For example, imagine a Laravel route that returns the following view:\n\n```php\nRoute::get('/counter', fn () => view('pages/counter.blade.php'));\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-71","text":"er.blade.php'));\n```\n\nThe view's content is a typical Blade template, including layout definitions and slots. However, by wrapping a portion of the view within the `@volt` Blade directive, we can convert that piece of the view into a fully-functional Volt component:\n\n```php\n<?php\n\nuse function Livewire\\Volt\\{state};\n\nstate(['count' => 0]);\n\n$increment = fn () => $this->count++;\n\n?>","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-72","text":" $this->count++;\n\n?>\n\n<x-app-layout>\n    <x-slot name=\"header\">\n        Counter\n    </x-slot>\n\n    @volt('counter')\n        <div>\n            <h1>{{ $count }}</h1>\n            <button wire:click=\"increment\">+</button>\n        </div>\n    @endvolt\n</x-app-layout>\n```\n\n#### Passing data to anonymous components","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-73","text":"anonymous components\n\nWhen rendering a view that contains an anonymous component, all of the data given to the view will also be available to the anonymous Volt component:\n\n```php\nuse App\\Models\\User;\n\nRoute::get('/counter', fn () => view('users.counter', [\n    'count' => User::count(),\n]));\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-74","text":"r::count(),\n]));\n```\n\nOf course, you may declare this data as \"state\" on your Volt component. When initializing state from data proxied to the component by the view, you only need to declare the name of the state variable. Volt will automatically hydrate the state's default value using the proxied view data:\n\n```php\n<?php\n\nuse function Livewire\\Volt\\{state};\n\nstate('count');","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-75","text":"e};\n\nstate('count');\n\n$increment = function () {\n    // Store the new count value in the database...\n\n    $this->count++;\n};\n\n?>\n\n<x-app-layout>\n    <x-slot name=\"header\">\n        Initial value: {{ $count }}\n    </x-slot>\n\n    @volt('counter')\n        <div>\n            <h1>{{ $count }}</h1>\n            <button wire:click=\"increment\">+</button>\n        </div>\n    @endvolt\n</x-app-layout>\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-76","text":"\n</x-app-layout>\n```\n\n## Testing components\n\nTo begin testing a Volt component, you may invoke the `Volt::test` method, providing the name of the component:\n\n```php\nuse Livewire\\Volt\\Volt;\n\nit('increments the counter', function () {\n    Volt::test('counter')\n        ->assertSee('0')\n        ->call('increment')\n        ->assertSee('1');\n});\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-77","text":"ertSee('1');\n});\n```\n\nWhen testing a Volt component, you may utilize all of the methods provided by the standard [Livewire testing API](/docs/testing).\n\nIf your Volt component is nested, you may use \"dot\" notation to specify the component that you wish to test:\n\n```php\nVolt::test('users.stats')\n```","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"7b3c6d183968060e9a84e5e9e5e25da1-78","text":"t('users.stats')\n```\n\nWhen testing a page that contains an anonymous Volt component, you may use the `assertSeeVolt` method to assert that the component is rendered:\n\n```php\n$this->get('/users')\n    ->assertSeeVolt('stats');\n```\n","source":"/Users/fyyx/Documents/livewire/docs/volt.md"}
{"id":"9f8ecd844e2b349cb83dde1329147dc7-0","text":"\nLivewire's `wire:navigate` feature makes page navigation much faster, providing an SPA-like experience for your users.\n\nThis page is a simple reference for the `wire:navigate` directive. Be sure to read the [page on Livewire's Navigate feature](/docs/navigate) for more complete documentation.\n\nBelow is a simple example of adding `wire:navigate` to links in a nav bar:","source":"/Users/fyyx/Documents/livewire/docs/wire-navigate.md"}
{"id":"9f8ecd844e2b349cb83dde1329147dc7-1","text":" links in a nav bar:\n\n```blade\n<nav>\n    <a href=\"/\" wire:navigate>Dashboard</a>\n    <a href=\"/posts\" wire:navigate>Posts</a>\n    <a href=\"/users\" wire:navigate>Users</a>\n</nav>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-navigate.md"}
{"id":"9f8ecd844e2b349cb83dde1329147dc7-2","text":"Users</a>\n</nav>\n```\n\nWhen any of these links are clicked, Livewire will intercept the click and, instead of allowing the browser to perform a full page visit, Livewire will fetch the page in the background and swap it with the current page (resulting in much faster and smoother page navigation).\n\n## Prefetching pages on hover","source":"/Users/fyyx/Documents/livewire/docs/wire-navigate.md"}
{"id":"9f8ecd844e2b349cb83dde1329147dc7-3","text":"ching pages on hover\n\nBy adding the `.hover` modifier, Livewire will pre-fetch a page when a user hovers over a link. This way, the page will have already been downloaded from the server when the user clicks on the link.\n\n```blade\n<a href=\"/\" wire:navigate.hover>Dashboard</a>\n```\n\n## Going deeper","source":"/Users/fyyx/Documents/livewire/docs/wire-navigate.md"}
{"id":"9f8ecd844e2b349cb83dde1329147dc7-4","text":"```\n\n## Going deeper\n\nFor more complete documentation on this feature, visit [Livewire's navigate documentation page](/docs/navigate).\n","source":"/Users/fyyx/Documents/livewire/docs/wire-navigate.md"}
{"id":"a937ff90db960fb378ab04427cef6551-0","text":"Livewire aims to make validating a user's input and giving them feedback as pleasant as possible. By building on top of Laravel's validation features, Livewire leverages your existing knowledge while also providing you with robust, additional features like real-time validation.\n\nHere's an example `CreatePost` component that demonstrates the most basic validation workflow in Livewire:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-1","text":"ewire:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n\tpublic $title = '';\n\n    public $content = '';\n\n    public function save()\n    {\n        $validated = $this->validate([ // [tl! highlight:3]\n\t\t\t'title' => 'required|min:3',\n\t\t\t'content' => 'required|min:3',\n        ]);\n\n\t\tPost::create($validated);","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-2","text":":create($validated);\n\n\t\treturn redirect()->to('/posts');\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```\n\n```blade\n<form wire:submit=\"save\">\n\t<input type=\"text\" wire:model=\"title\">\n    <div>@error('title') {{ $message }} @enderror</div>\n\n\t<textarea wire:model=\"content\"></textarea>\n    <div>@error('content') {{ $message }} @enderror</div>","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-3","text":"e }} @enderror</div>\n\n\t<button type=\"submit\">Save</button>\n</form>\n```\n\nAs you can see, Livewire provides a `validate()` method that you can call to validate your component's properties. It returns the validated set of data that you can then safely insert into the database.\n\nOn the frontend, you can use Laravel's existing Blade directives to show validation messages to your users.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-4","text":"sages to your users.\n\nFor more information, see [Laravel's documentation on rendering validation errors in Blade](https://laravel.com/docs/blade#validation-errors).\n\n## Validate attributes\n\nIf you prefer to co-locate your component's validation rules with the properties directly, you can use Livewire's `#[Validate]` attribute.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-5","text":"alidate]` attribute.\n\nBy associating validation rules with properties using `#[Validate]`, Livewire will automatically run the properties validation rules before each update. However, you should still run `$this->validate()` before persisting data to a database so that properties that haven't been updated are also validated.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-6","text":" are also validated.\n\n```php\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    #[Validate('required|min:3')] // [tl! highlight]\n\tpublic $title = '';\n\n    #[Validate('required|min:3')] // [tl! highlight]\n    public $content = '';\n\n    public function save()\n    {\n        $this->validate();","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-7","text":"  $this->validate();\n\n\t\tPost::create([\n            'title' => $this->title,\n            'content' => $this->content,\n\t\t]);\n\n\t\treturn redirect()->to('/posts');\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-8","text":" }\n\n    // ...\n}\n```\n\n> [!info] Validate attributes don't support Rule objects\n> PHP Attributes are restricted to certain syntaxes like plain strings and arrays. If you find yourself wanting to use run-time syntaxes like Laravel's Rule objects (`Rule::exists(...)`) you should instead [define a `rules()` method](#defining-a-rules-method) in your component.\n>","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-9","text":"in your component.\n>\n> Learn more in the documentation on [using Laravel Rule objects with Livewire](#using-laravel-rule-objects).","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-10","text":"ravel-rule-objects).\n\nIf you prefer more control over when the properties are validated, you can pass a `onUpdate: false` parameter to the `#[Validate]` attribute. This will disable any automatic validation and instead assume you want to manually validate the properties using the `$this->validate()` method:\n\n```php\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-11","text":"use App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    #[Validate('required|min:3', onUpdate: false)]\n\tpublic $title = '';\n\n    #[Validate('required|min:3', onUpdate: false)]\n    public $content = '';\n\n    public function save()\n    {\n        $validated = $this->validate();\n\n\t\tPost::create($validated);\n\n\t\treturn redirect()->to('/posts');\n    }\n\n    // ...\n}\n```\n\n### Custom attribute name","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-12","text":"ustom attribute name\n\nIf you wish to customize the attribute name injected into the validation message, you may do so using the `as: ` parameter:\n\n```php\nuse Livewire\\Attributes\\Validate;\n\n#[Validate('required', as: 'date of birth')]\npublic $dob;\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-13","text":"')]\npublic $dob;\n```\n\nWhen validation fails in the above snippet, Laravel will use \"date of birth\" instead of \"dob\" as the name of the field in the validation message. The generated message will be \"The date of birth field is required\" instead of \"The dob field is required\".\n\n### Custom validation message","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-14","text":"m validation message\n\nTo bypass Laravel's validation message and replace it with your own, you can use the `message: ` parameter in the `#[Validate]` attribute:\n\n```php\nuse Livewire\\Attributes\\Validate;\n\n#[Validate('required', message: 'Please provide a post title')]\npublic $title;\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-15","text":"]\npublic $title;\n```\n\nNow, when the validation fails for this property, the message will be \"Please provide a post title\" instead of \"The title field is required\".\n\nIf you wish to add different messages for different rules, you can simply provide multiple `#[Validate]` attributes:","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-16","text":"lidate]` attributes:\n\n```php\n#[Validate('required', message: 'Please provide a post title')]\n#[Validate('min:3', message: 'This title is too short')]\npublic $title;\n```\n\n### Opting out of localization\n\nBy default, Livewire rule messages and attributes are localized using Laravel's translate helper: `trans()`.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-17","text":"e helper: `trans()`.\n\nYou can opt-out of localization by passing the `translate: false` parameter to the `#[Validate]` attribute:\n\n```php\n#[Validate('required', message: 'Please provide a post title', translate: false)]\npublic $title;\n```\n\n### Custom key","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-18","text":"\n```\n\n### Custom key\n\nWhen applying validation rules directly to a property using the `#[Validate]` attribute, Livewire assumes the validation key should be the name of the property itself. However, there are times when you may want to customize the validation key.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-19","text":" the validation key.\n\nFor example, you might want to provide separate validation rules for an array property and its children. In this case, instead of passing a validation rule as the first argument to the `#[Validate]` attribute, you can pass an array of key-value pairs instead:","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-20","text":"value pairs instead:\n\n```php\n#[Validate([\n    'todos' => 'required',\n    'todos.*' => [\n        'required',\n        'min:3',\n        new Uppercase,\n    ],\n])]\npublic $todos = [];\n```\n\nNow, when a user updates `$todos`, or the `validate()` method is called, both of these validation rules will be applied.\n\n## Form objects","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-21","text":"ed.\n\n## Form objects\n\nAs more properties and validation rules are added to a Livewire component, it can begin to feel too crowded. To alleviate this pain and also provide a helpful abstraction for code reuse, you can use Livewire's *Form Objects* to store your properties and validation rules.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-22","text":"nd validation rules.\n\nBelow is the same `CreatePost` example, but now the properties and rules have been extracted to a dedicated form object named `PostForm`:\n\n```php\n<?php\n\nnamespace App\\Livewire\\Forms;\n\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Form;\n\nclass PostForm extends Form\n{\n    #[Validate('required|min:3')]\n\tpublic $title = '';","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-23","text":"\tpublic $title = '';\n\n    #[Validate('required|min:3')]\n    public $content = '';\n}\n```\n\nThe `PostForm` above can now be defined as a property on the `CreatePost` component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Livewire\\Forms\\PostForm;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    public PostForm $form;","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-24","text":"blic PostForm $form;\n\n    public function save()\n    {\n\t\tPost::create(\n    \t\t$this->form->all()\n    \t);\n\n\t\treturn redirect()->to('/posts');\n    }\n\n    // ...\n}\n```\n\nAs you can see, instead of listing out each property individually, we can retrieve all the property values using the `->all()` method on the form object.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-25","text":" on the form object.\n\nAlso, when referencing the property names in the template, you must prepend `form.` to each instance:\n\n```blade\n<form wire:submit=\"save\">\n\t<input type=\"text\" wire:model=\"form.title\">\n    <div>@error('form.title') {{ $message }} @enderror</div>\n\n\t<textarea wire:model=\"form.content\"></textarea>\n    <div>@error('form.content') {{ $message }} @enderror</div>","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-26","text":"e }} @enderror</div>\n\n\t<button type=\"submit\">Save</button>\n</form>\n```\n\nWhen using form objects, `#[Validate]` attribute validation will be run every time a property is updated. However, if you disable this behavior by specifying `onUpdate: false` on the attribute, you can manually run a form object's validation using `$this->form->validate()`:","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-27","text":"->form->validate()`:\n\n```php\npublic function save()\n{\n    Post::create(\n        $this->form->validate()\n    );\n\n    return redirect()->to('/posts');\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-28","text":">to('/posts');\n}\n```\n\nForm objects are a useful abstraction for most larger datasets and a variety of additional features that make them even more powerful. For more information, check out the comprehensive [form object documentation](/docs/forms#extracting-a-form-object).\n\n## Real-time validation","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-29","text":"Real-time validation\n\nReal-time validation is the term used for when you validate a user's input as they fill out a form rather than waiting for the form submission.\n\nBy using `#[Validate]` attributes directly on Livewire properties, any time a network request is sent to update a property's value on the server, the provided validation rules will be applied.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-30","text":"les will be applied.\n\nThis means to provide a real-time validation experience for your users on a specific input, no extra backend work is required. The only thing that is required is using `wire:model.live` or `wire:model.blur` to instruct Livewire to trigger network requests as the fields are filled out.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-31","text":"elds are filled out.\n\nIn the below example, `wire:model.blur` has been added to the text input. Now, when a user types in the field and then tabs or clicks away from the field, a network request will be triggered with the updated value and the validation rules will run:\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"text\" wire:model.blur=\"title\">\n\n    <!-- -->\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-32","text":"<!-- -->\n</form>\n```\n\nIf you are using a `rules()` method to declare your validation rules for a property instead of the `#[Validate]` attribute, you can still include a #[Validate] attribute with no parameters to retain the real-time validating behavior:\n\n```php\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-33","text":"use App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    #[Validate] // [tl! highlight]\n\tpublic $title = '';\n\n    public $content = '';\n\n    protected function rules()\n    {\n        return [\n            'title' => 'required|min:5',\n            'content' => 'required|min:5',\n        ];\n    }\n\n    public function save()\n    {\n        $validated = $this->validate();\n\n\t\tPost::create($validated);","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-34","text":":create($validated);\n\n\t\treturn redirect()->to('/posts');\n    }\n```\n\nNow, in the above example, even though `#[Validate]` is empty, it will tell Livewire to run the fields validation provided by `rules()` everytime the property is updated.\n\n## Customizing error messages","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-35","text":"izing error messages\n\nOut-of-the-box, Laravel provides sensible validation messages like \"The title field is required.\" if the `$title` property has the `required` rule attached to it.\n\nHowever, you may need to customize the language of these error messages to better suite your application and its users.\n\n### Custom attribute names","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-36","text":"stom attribute names\n\nSometimes the property you are validating has a name that isn't suited for displaying to users. For example, if you have a database field in your app named `dob` that stands for \"Date of birth\", you would want to show your users \"The date of birth field is required\" instead of \"The dob field is required\".","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-37","text":" field is required\".\n\nLivewire allows you to specify an alternative name for a property using the `as: ` parameter:\n\n```php\nuse Livewire\\Attributes\\Validate;\n\n#[Validate('required', as: 'date of birth')]\npublic $dob = '';\n```\n\nNow, if the `required` validation rule fails, the error message will state \"The date of birth field is required.\" instead of \"The dob field is required.\".","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-38","text":"field is required.\".\n\n### Custom messages\n\nIf customizing the property name isn't enough, you can customize the entire validation message using the `message: ` parameter:\n\n```php\nuse Livewire\\Attributes\\Validate;\n\n#[Validate('required', message: 'Please fill out your date of birth.')]\npublic $dob = '';\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-39","text":"ublic $dob = '';\n```\n\nIf you have multiple rules to customize the message for, it is recommended that you use entirely separate `#[Validate]` attributes for each, like so:\n\n```php\nuse Livewire\\Attributes\\Validate;\n\n#[Validate('required', message: 'Please enter a title.')]\n#[Validate('min:5', message: 'Your title is too short.')]\npublic $title = '';\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-40","text":"lic $title = '';\n```\n\nIf you want to use the `#[Validate]` attribute's array syntax instead, you can specify custom attributes and messages like so:\n\n```php\nuse Livewire\\Attributes\\Validate;","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-41","text":"Attributes\\Validate;\n\n#[Validate([\n    'titles' => 'required',\n    'titles.*' => 'required|min:5',\n], message: [\n    'required' => 'The :attribute is missing.',\n    'titles.required' => 'The :attribute are missing.',\n    'min' => 'The :attribute is too short.',\n], attribute: [\n    'titles.*' => 'title',\n])]\npublic $titles = [];\n```\n\n## Defining a `rules()` method","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-42","text":"g a `rules()` method\n\nAs an alternative to Livewire's `#[Validate]` attributes, you can define a method in your component called `rules()` and return a list of fields and corresponding validation rules. This can be helpful if you are trying to use run-time syntaxes that aren't supported in PHP Attributes, for example, Laravel rule objects like `Rule::password()`.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-43","text":" `Rule::password()`.\n\nThese rules will then be applied when you run `$this->validate()` inside the component. You also can define the `messages()` and `validationAttributes()` functions.\n\nHere's an example:\n\n```php\nuse Livewire\\Component;\nuse App\\Models\\Post;\nuse Illuminate\\Validation\\Rule;\n\nclass CreatePost extends Component\n{\n\tpublic $title = '';\n\n    public $content = '';","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-44","text":"ublic $content = '';\n\n    protected function rules() // [tl! highlight:6]\n    {\n        return [\n            'title' => Rule::exists('posts', 'title'),\n            'content' => 'required|min:3',\n        ];\n    }","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-45","text":"3',\n        ];\n    }\n\n    protected function messages() // [tl! highlight:6]\n    {\n        return [\n            'content.required' => 'The :attribute are missing.',\n            'content.min' => 'The :attribute is too short.',\n        ];\n    }\n\n    protected function validationAttributes() // [tl! highlight:6]\n    {\n        return [\n            'content' => 'description',\n        ];\n    }","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-46","text":"n',\n        ];\n    }\n\n    public function save()\n    {\n        $this->validate();\n\n\t\tPost::create([\n            'title' => $this->title,\n            'content' => $this->content,\n\t\t]);\n\n\t\treturn redirect()->to('/posts');\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-47","text":" }\n\n    // ...\n}\n```\n\n> [!warning] The `rules()` method doesn't validate on data updates","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-48","text":"date on data updates\n> When defining rules via the `rules()` method, Livewire will ONLY use these validation rules to validate properties when you run `$this->validate()`. This is different than standard `#[Validate]` attributes which are applied every time a field is updated via something like `wire:model`","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-49","text":"ng like `wire:model`. To apply these validation rules to a property every time it's updated, you can still use `#[Validate]` with no extra parameters.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-50","text":"no extra parameters.\n\n> [!warning] Don't conflict with Livewire's mechanisms\n> While using Livewire's validation utilities, your component should **not** have properties or methods named `rules`, `messages`, `validationAttributes` or `validationCustomValues`, unless you're customizing the validation process. Otherwise, those will conflict with Livewire's mechanisms.\n\n## Using Laravel Rule objects","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-51","text":"Laravel Rule objects\n\nLaravel `Rule` objects are an extremely powerful way to add advanced validation behavior to your forms.\n\nHere is an example of using Rule objects in conjunction with Livewire's `rules()` method to achieve more sophisticated validation:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Validation\\Rule;\nuse App\\Models\\Post;\nuse Livewire\\Form;","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-52","text":";\nuse Livewire\\Form;\n\nclass UpdatePost extends Form\n{\n    public ?Post $post;\n\n    public $title = '';\n\n    public $content = '';\n\n    protected function rules()\n    {\n        return [\n            'title' => [\n                'required',\n                Rule::unique('posts')->ignore($this->post), // [tl! highlight]\n            ],\n            'content' => 'required|min:5',\n        ];\n    }","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-53","text":"5',\n        ];\n    }\n\n    public function mount()\n    {\n        $this->title = $this->post->title;\n        $this->content = $this->post->content;\n    }\n\n    public function update()\n    {\n        $this->validate(); // [tl! highlight]\n\n        $this->post->update($this->all());\n\n        $this->reset();\n    }\n\n    // ...\n}\n```\n\n## Manually controlling validation errors","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-54","text":"ng validation errors\n\nLivewire's validation utilities should handle the most common validation scenarios; however, there are times when you may want full control over the validation messages in your component.\n\nBelow are all the available methods for manipulating the validation errors in your Livewire component:","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-55","text":" Livewire component:\n\nMethod | Description\n--- | ---\n`$this->addError([key], [message])` | Manually add a validation message to the error bag\n`$this->resetValidation([?key])` | Reset the validation errors for the provided key, or reset all errors if no key is supplied\n`$this->getErrorBag()` | Retrieve the underlying Laravel error bag used in the Livewire component","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-56","text":"e Livewire component\n\n> [!info] Using `$this->addError()` with Form Objects\n> When manually adding errors using `$this->addError` inside of a form object the key will automatically be prefixed with the name of the property the form is assigned to in the parent component. For example, if in your Component you assign the form to a property called `$data`, key will become `data.key`.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-57","text":"l become `data.key`.\n\n## Accessing the validator instance\n\nSometimes you may want to access the Validator instance that Livewire uses internally in the `validate()` method. This is possible using the `withValidator` method. The closure you provide receives the fully constructed validator as an argument, allowing you to call any of its methods before the validation rules are actually evaluated.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-58","text":" actually evaluated.\n\nBelow is an example of intercepting Livewire's internal validator to manually check a condition and add an additional validation message:\n\n```php\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    #[Validate('required|min:3')]\n\tpublic $title = '';\n\n    #[Validate('required|min:3')]\n    public $content = '';","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-59","text":"ublic $content = '';\n\n    public function boot()\n    {\n        $this->withValidator(function ($validator) {\n            $validator->after(function ($validator) {\n                if (str($this->title)->startsWith('\"')) {\n                    $validator->errors()->add('title', 'Titles cannot start with quotations');\n                }\n            });\n        });\n    }","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-60","text":");\n        });\n    }\n\n    public function save()\n    {\n\t\tPost::create($this->all());\n\n\t\treturn redirect()->to('/posts');\n    }\n\n    // ...\n}\n```\n\n## Using custom validators","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-61","text":"ng custom validators\n\nIf you wish to use your own validation system in Livewire, that isn't a problem. Livewire will catch any `ValidationException` exceptions thrown inside of components and provide the errors to the view just as if you were using Livewire's own `validate()` method.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-62","text":"`validate()` method.\n\nBelow is an example of the `CreatePost` component, but instead of using Livewire's validation features, a completely custom validator is being created and applied to the component properties:\n\n```php\nuse Illuminate\\Support\\Facades\\Validator;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n\tpublic $title = '';\n\n    public $content = '';","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-63","text":"ublic $content = '';\n\n    public function save()\n    {\n        $validated = Validator::make(\n            // Data to validate...\n            ['title' => $this->title, 'content' => $this->content],\n\n            // Validation rules to apply...\n            ['title' => 'required|min:3', 'content' => 'required|min:3'],","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-64","text":"> 'required|min:3'],\n\n            // Custom validation messages...\n            ['required' => 'The :attribute field is required'],\n         )->validate();\n\n\t\tPost::create($validated);\n\n\t\treturn redirect()->to('/posts');\n    }\n\n    // ...\n}\n```\n\n## Testing validation\n\nLivewire provides useful testing utilities for validation scenarios, such as the `assertHasErrors()` method.","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-65","text":"HasErrors()` method.\n\nBelow is a basic test case that ensures validation errors are thrown if no input is set for the `title` property:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-66","text":"\nuse Tests\\TestCase;\n\nclass CreatePostTest extends TestCase\n{\n    public function test_cant_create_post_without_title()\n    {\n        Livewire::test(CreatePost::class)\n            ->set('content', 'Sample content...')\n            ->call('save')\n            ->assertHasErrors('title');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-67","text":"title');\n    }\n}\n```\n\nIn addition to testing the presence of errors, `assertHasErrors` allows you to also narrow down the assertion to specific rules by passing the rules to assert against as the second argument to the method:","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-68","text":"ument to the method:\n\n```php\npublic function test_cant_create_post_with_title_shorter_than_3_characters()\n{\n    Livewire::test(CreatePost::class)\n        ->set('title', 'Sa')\n        ->set('content', 'Sample content...')\n        ->call('save')\n        ->assertHasErrors(['title' => ['min:3']]);\n}\n```\n\nYou can also assert the presence of validation errors for multiple properties at the same time:","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-69","text":"es at the same time:\n\n```php\npublic function test_cant_create_post_without_title_and_content()\n{\n    Livewire::test(CreatePost::class)\n        ->call('save')\n        ->assertHasErrors(['title', 'content']);\n}\n```\n\nFor more information on other testing utilities provided by Livewire, check out the [testing documentation](/docs/testing).\n\n## Deprecated `[#Rule]` attribute","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"a937ff90db960fb378ab04427cef6551-70","text":" `[#Rule]` attribute\n\nWhen Livewire v3 first launched, it used the term \"Rule\" instead of \"Validate\" for it's validation attributes (`#[Rule]`).\n\nBecause of naming conflicts with Laravel rule objects, this has since been changed to `#[Validate]`. Both are supported in Livewire v3, however it is recommended that you change all occurrences of `#[Rule]` with `#[Validate]` to stay current.\n","source":"/Users/fyyx/Documents/livewire/docs/validation.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-0","text":"After a user performs some action — like submitting a form — you may want to redirect them to another page in your application.","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-1","text":"in your application.\n\nBecause Livewire requests aren't standard full-page browser requests, standard HTTP redirects won't work. Instead, you need to trigger redirects via JavaScript. Fortunately, Livewire exposes a simple `$this->redirect()` helper method to use within your components. Internally, Livewire will handle the process of redirecting on the frontend.","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-2","text":"ing on the frontend.\n\nIf you prefer, you can use [Laravel's built-in redirect utilities](https://laravel.com/docs/responses#redirects) within your components as well.\n\n## Basic usage\n\nBelow is an example of a `CreatePost` Livewire component that redirects the user to another page after they submit the form to create a post:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-3","text":"espace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n\tpublic $title = '';\n\n    public $content = '';\n\n    public function save()\n    {\n\t\tPost::create([\n\t\t\t'title' => $this->title,\n\t\t\t'content' => $this->content,\n\t\t]);\n\n\t\t$this->redirect('/posts'); // [tl! highlight]\n    }","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-4","text":"tl! highlight]\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```\n\nAs you can see, when the `save` action is triggered, a redirect will also be triggered to `/posts`. When Livewire receives this response, it will redirect the user to the new URL on the frontend.\n\n## Redirect to Route","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-5","text":"## Redirect to Route\n\nIn case you want to redirect to a page using its route name you can use the `redirectRoute`.\n\nFor example, if you have a page with the route named `'profile'` like this: \n\n```php\n    Route::get('/user/profile', function () {\n        // ...\n    })->name('profile');\n```\n\nYou can use `redirectRoute` to redirect to that page using the name of the route like so:","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-6","text":"f the route like so:\n\n```php\n    $this->redirectRoute('profile');\n```\n\nIn case you need to pass parameters to the route you may use the second argument of the method `redirectRoute` like so:\n\n```php\n    $this->redirectRoute('profile', ['id' => 1]);\n```\n\n## Redirect to intended","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-7","text":"Redirect to intended\n\nIn case you want to redirect the user back to the previous page they were on you can use `redirectIntended`. It accepts an optional default URL as its first argument which is used as a fallback if no previous page can be determined:\n\n```php\n    $this->redirectIntended('/default/url');\n```\n\n## Redirecting to full-page components","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-8","text":"full-page components\n\nBecause Livewire uses Laravel's built-in redirection feature, you can use all of the redirection methods available to you in a typical Laravel application.\n\nFor example, if you are using a Livewire component as a full-page component for a route like so:\n\n```php\nuse App\\Livewire\\ShowPosts;\n\nRoute::get('/posts', ShowPosts::class);\n```","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-9","text":"owPosts::class);\n```\n\nYou can redirect to the component by providing the component name to the `redirect()` method:\n\n```php\npublic function save()\n{\n    // ...\n\n    $this->redirect(ShowPosts::class);\n}\n```\n\n## Flash messages","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-10","text":"`\n\n## Flash messages\n\nIn addition to allowing you to use Laravel's built-in redirection methods, Livewire also supports Laravel's [session flash data utilities](https://laravel.com/docs/session#flash-data).\n\nTo pass flash data along with a redirect, you can use Laravel's `session()->flash()` method like so:\n\n```php\nuse Livewire\\Component;\n\nclass UpdatePost extends Component\n{\n    // ...","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-11","text":"mponent\n{\n    // ...\n\n    public function update()\n    {\n        // ...\n\n        session()->flash('status', 'Post successfully updated.');\n\n        $this->redirect('/posts');\n    }\n}\n```\n\nAssuming the page being redirected to contain the following Blade snippet, the user will see a \"Post successfully updated.\" message after updating the post:","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"e2ddfbb679df7b6b6c8a24e7c9f18c40-12","text":"r updating the post:\n\n```blade\n@if (session('status'))\n    <div class=\"alert alert-success\">\n        {{ session('status') }}\n    </div>\n@endif\n```\n","source":"/Users/fyyx/Documents/livewire/docs/redirecting.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-0","text":"Livewire provides a variety of lifecycle hooks that allow you to execute code at specific points during a component's lifecycle. These hooks enable you to perform actions before or after particular events, such as initializing the component, updating properties, or rendering the template.\n\nHere's a list of all the available component lifecycle hooks:","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-1","text":"ent lifecycle hooks:\n\n| Hook Method      | Description                                                                     |\n|------------------|---------------------------------------------------------------------------------|\n| `mount()`        | Called when a component is created                                              |","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-2","text":"                   |\n| `hydrate()`      | Called when a component is re-hydrated at the beginning of a subsequent request |\n| `boot()`         | Called at the beginning of every request. Both initial, and subsequent          |\n| `updating()`     | Called before updating a component property                                     |","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-3","text":"                   |\n| `updated()`      | Called after updating a property                                                |\n| `rendering()`    | Called before `render()` is called                                              |\n| `rendered()`     | Called after `render()` is called                                               |","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-4","text":"                   |\n| `dehydrate()`    | Called at the end of every component request                                    |\n| `exception($e, $stopPropagation)` | Called when an exception is thrown                     |                    |","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-5","text":"                   |\n\n## Mount\n\nIn a standard PHP class, a constructor (`__construct()`) takes in outside parameters and initializes the object's state. However, in Livewire, you use the `mount()` method for accepting parameters and initializing the state of your component.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-6","text":"e of your component.\n\nLivewire components don't use `__construct()` because Livewire components are _re-constructed_ on subsequent network requests, and we only want to initialize the component once when it is first created.\n\nHere's an example of using the `mount()` method to initialize the `name` and `email` properties of an `UpdateProfile` component:","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-7","text":"eProfile` component:\n\n```php\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\n\nclass UpdateProfile extends Component\n{\n    public $name;\n\n    public $email;\n\n    public function mount()\n    {\n        $this->name = Auth::user()->name;\n\n        $this->email = Auth::user()->email;\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-8","text":" }\n\n    // ...\n}\n```\n\nAs mentioned earlier, the `mount()` method receives data passed into the component as method parameters:\n\n```php\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass UpdatePost extends Component\n{\n    public $title;\n\n    public $content;\n\n    public function mount(Post $post)\n    {\n        $this->title = $post->title;\n\n        $this->content = $post->content;\n    }","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-9","text":"post->content;\n    }\n\n    // ...\n}\n```\n\n> [!tip] You can use dependency injection with all hook methods\n> Livewire allows you to resolve dependencies out of [Laravel's service container](https://laravel.com/docs/container#automatic-injection) by type-hinting method parameters on lifecycle hooks.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-10","text":" on lifecycle hooks.\n\nThe `mount()` method is a crucial part of using Livewire. The following documentation provides further examples of using the `mount()` method to accomplish common tasks:","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-11","text":"mplish common tasks:\n\n* [Initializing properties](/docs/properties#initializing-properties)\n* [Receiving data from parent components](/docs/nesting#passing-props-to-children)\n* [Accessing route parameters](/docs/components#accessing-route-parameters)\n\n## Boot","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-12","text":"parameters)\n\n## Boot\n\nAs helpful as `mount()` is, it only runs once per component lifecycle, and you may want to run logic at the beginning of every single request to the server for a given component.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-13","text":"r a given component.\n\nFor these cases, Livewire provides a `boot()` method where you can write component setup code that you intend to run every single time the component class is booted: both on initialization and on subsequent requests.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-14","text":"subsequent requests.\n\nThe `boot()` method can be useful for things like initializing protected properties, which are not persisted between requests. Below is an example of initializing a protected property as an Eloquent model:\n\n```php\nuse Livewire\\Attributes\\Locked;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPost extends Component\n{\n    #[Locked]\n    public $postId = 1;","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-15","text":" public $postId = 1;\n\n    protected Post $post;\n\n    public function boot() // [tl! highlight:3]\n    {\n        $this->post = Post::find($this->postId);\n    }\n\n    // ...\n}\n```\n\nYou can use this technique to have complete control over initializing a component property in your Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-16","text":" Livewire component.\n\n> [!tip] Most of the time, you can use a computed property instead\n> The technique used above is powerful; however, it's often better to use [Livewire's computed properties](/docs/computed-properties) to solve this use case.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-17","text":"solve this use case.\n\n> [!warning] Always lock sensitive public properties","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-18","text":"ve public properties\n> As you can see above, we are using the `#[Locked]` attribute on the `$postId` property. In a scenario like the above, where you want to ensure the `$postId` property isn't tampered with by users on the client-side, it's important to authorize the property's value before using it or add `#[Locked]` to the property ensure it is never changed.\n>","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-19","text":" is never changed.\n>\n> For more information, check out the [documentation on Locked properties](/docs/locked).","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-20","text":"ties](/docs/locked).\n\n\n## Update\n\nClient-side users can update public properties in many different ways, most commonly by modifying an input with `wire:model` on it.\n\nLivewire provides convenient hooks to intercept the updating of a public property so that you can validate or authorize a value before it's set, or ensure a property is set in a given format.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-21","text":"t in a given format.\n\nBelow is an example of using `updating` to prevent the modification of the `$postId` property.\n\nIt's worth noting that for this particular example, in an actual application, you should use the [`#[Locked]` attribute](/docs/locked) instead, like in the above example.\n\n```php\nuse Exception;\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    public $postId = 1;","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-22","text":" public $postId = 1;\n\n    public function updating($property, $value)\n    {\n        // $property: The name of the current property being updated\n        // $value: The value about to be set to the property\n\n        if ($property === 'postId') {\n            throw new Exception;\n        }\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-23","text":" }\n\n    // ...\n}\n```\n\nThe above `updating()` method runs before the property is updated, allowing you to catch invalid input and prevent the property from updating. Below is an example of using `updated()` to ensure a property's value stays consistent:\n\n```php\nuse Livewire\\Component;\n\nclass CreateUser extends Component\n{\n    public $username = '';\n\n    public $email = '';","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-24","text":" public $email = '';\n\n    public function updated($property)\n    {\n        // $property: The name of the current property that was updated\n\n        if ($property === 'username') {\n            $this->username = strtolower($this->username);\n        }\n    }\n\n    // ...\n}\n```\n\nNow, anytime the `$username` property is updated client-side, we will ensure that the value will always be lowercase.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-25","text":"always be lowercase.\n\nBecause you are often targeting a specific property when using update hooks, Livewire allows you to specify the property name directly as part of the method name. Here's the same example from above but rewritten utilizing this technique:\n\n```php\nuse Livewire\\Component;\n\nclass CreateUser extends Component\n{\n    public $username = '';\n\n    public $email = '';","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-26","text":" public $email = '';\n\n    public function updatedUsername()\n    {\n        $this->username = strtolower($this->username);\n    }\n\n    // ...\n}\n```\n\nOf course, you can also apply this technique to the `updating` hook.\n\n### Arrays\n\nArray properties have an additional `$key` argument passed to these functions to specify the changing element.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-27","text":"he changing element.\n\nNote that when the array itself is updated instead of a specific key, the `$key` argument is null.\n\n```php\nuse Livewire\\Component;\n\nclass UpdatePreferences extends Component\n{\n    public $preferences = [];\n\n    public function updatedPreferences($value, $key)\n    {\n        // $value = 'dark'\n        // $key   = 'theme'\n    }\n\n    // ...\n}\n```\n\n## Hydrate & Dehydrate","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-28","text":" Hydrate & Dehydrate\n\nHydrate and dehydrate are lesser-known and lesser-utilized hooks. However, there are specific scenarios where they can be powerful.\n\nThe terms \"dehydrate\" and \"hydrate\" refer to a Livewire component being serialized to JSON for the client-side and then unserialized back into a PHP object on the subsequent request.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-29","text":" subsequent request.\n\nWe often use the terms \"hydrate\" and \"dehydrate\" to refer to this process throughout Livewire's codebase and the documentation. If you'd like more clarity on these terms, you can learn more by [consulting our hydration documentation](/docs/hydration).","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-30","text":"n](/docs/hydration).\n\nLet's look at an example that uses both `mount()` , `hydrate()`, and `dehydrate()` all together to support using a custom [data transfer object (DTO)](https://en.wikipedia.org/wiki/Data_transfer_object) instead of an Eloquent model to store the post data in the component:\n\n```php\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    public $post;","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-31","text":"\n{\n    public $post;\n\n    public function mount($title, $content)\n    {\n        // Runs at the beginning of the first initial request...\n\n        $this->post = new PostDto([\n            'title' => $title,\n            'content' => $content,\n        ]);\n    }","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-32","text":"t,\n        ]);\n    }\n\n    public function hydrate()\n    {\n        // Runs at the beginning of every \"subsequent\" request...\n        // This doesn't run on the initial request (\"mount\" does)...\n\n        $this->post = new PostDto($this->post);\n    }\n\n    public function dehydrate()\n    {\n        // Runs at the end of every single request...\n\n        $this->post = $this->post->toArray();\n    }","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-33","text":"st->toArray();\n    }\n\n    // ...\n}\n```\n\nNow, from actions and other places inside your component, you can access the `PostDto` object instead of the primitive data.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-34","text":" the primitive data.\n\nThe above example mainly demonstrates the abilities and nature of the `hydrate()` and `dehydrate()` hooks. However, it is recommended that you use [Wireables or Synthesizers](/docs/properties#supporting-custom-types) to accomplish this instead.\n\n## Render","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-35","text":" instead.\n\n## Render\n\nIf you want to hook into the process of rendering a component's Blade view, you can do so using the `rendering()` and `rendered()` hooks:\n\n```php\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    public function render()\n    {\n        return view('livewire.show-posts', [\n            'post' => Post::all(),\n        ])\n    }","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-36","text":"(),\n        ])\n    }\n\n    public function rendering($view, $data)\n    {\n        // Runs BEFORE the provided view is rendered...\n        //\n        // $view: The view about to be rendered\n        // $data: The data provided to the view\n    }","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-37","text":"ed to the view\n    }\n\n    public function rendered($view, $html)\n    {\n        // Runs AFTER the provided view is rendered...\n        //\n        // $view: The rendered view\n        // $html: The final, rendered HTML\n    }\n\n    // ...\n}\n```\n\n## Exception","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-38","text":"\n}\n```\n\n## Exception\n\nSometimes it can be helpful to intercept and catch errors, eg: to customize the error message or ignore specific type of exceptions. The `exception()` hook allows you to do just that: you can perform check on the `$error`, and use the `$stopPropagation` parameter to catch the issue.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-39","text":" to catch the issue.\nThis also unlocks powerful patterns when you want to stop further execution of code (return early), this is how internal methods like `validate()` works.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-40","text":" `validate()` works.\n\n```php\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    public function mount() // [tl! highlight:3]\n    {\n        $this->post = Post::find($this->postId);\n    }\n\n    public function exception($e, $stopPropagation) {\n        if ($e instanceof NotFoundException) {\n            $this->notify('Post is not found');\n            $stopPropagation();\n        }\n    }","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-41","text":"n();\n        }\n    }\n\n    // ...\n}\n```\n\n## Using hooks inside a trait\n\nTraits are a helpful way to reuse code across components or extract code from a single component into a dedicated file.\n\nTo avoid multiple traits conflicting with each other when declaring lifecycle hook methods, Livewire supports prefixing hook methods with the _camelCased_ name of the current trait declaring them.","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-42","text":"rait declaring them.\n\nThis way, you can have multiple traits using the same lifecycle hooks and avoid conflicting method definitions.\n\nBelow is an example of a component referencing a trait called `HasPostForm`:\n\n```php\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    use HasPostForm;\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-43","text":"m;\n\n    // ...\n}\n```\n\nNow here's the actual `HasPostForm` trait containing all the available prefixed hooks:\n\n```php\ntrait HasPostForm\n{\n    public $title = '';\n\n    public $content = '';\n\n    public function mountHasPostForm()\n    {\n        // ...\n    }\n\n    public function hydrateHasPostForm()\n    {\n        // ...\n    }\n\n    public function bootHasPostForm()\n    {\n        // ...\n    }","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"74fc2ae848019d8bb83426a4445979ef-44","text":"        // ...\n    }\n\n    public function updatingHasPostForm()\n    {\n        // ...\n    }\n\n    public function updatedHasPostForm()\n    {\n        // ...\n    }\n\n    public function renderingHasPostForm()\n    {\n        // ...\n    }\n\n    public function renderedHasPostForm()\n    {\n        // ...\n    }\n\n    public function dehydrateHasPostForm()\n    {\n        // ...\n    }\n\n    // ...\n}\n```\n","source":"/Users/fyyx/Documents/livewire/docs/lifecycle-hooks.md"}
{"id":"cc60558a501ff08472f10cad722e5c46-0","text":"\nLivewire offers a `wire:init` directive to run an action as soon as the component is rendered. This can be helpful in cases where you don't want to hold up the entire page load, but want to load some data immediately after the page load.\n\n```blade\n<div wire:init=\"loadPosts\">\n    <!-- ... -->\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-init.md"}
{"id":"cc60558a501ff08472f10cad722e5c46-1","text":"- ... -->\n</div>\n```\n\nThe `loadPosts` action will be run immediately after the Livewire component renders on the page.\n\nIn most cases however, [Livewire's lazy loading feature](/docs/lazy) is preferable to using `wire:init`.\n","source":"/Users/fyyx/Documents/livewire/docs/wire-init.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-0","text":"\n## Basic usage\n\nShowing or hiding content in Livewire is as simple as using one of Blade's conditional directives like `@if`. To enhance this experience for your users, Livewire provides a `wire:transition` directive that allows you to transition conditional elements smoothly in and out of the page.","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-1","text":"and out of the page.\n\nFor example, below is a `ShowPost` component with the ability to toggle viewing comments on and off:\n\n```php\nuse App\\Models\\Post;\n\nclass ShowPost extends Component\n{\n    public Post $post;\n\n    public $showComments = false;\n}\n```\n\n```blade\n<div>\n    <!-- ... -->\n\n    <button wire:click=\"$set('showComments', true)\">Show comments</button>","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-2","text":"ow comments</button>\n\n    @if ($showComments)\n        <div wire:transition> <!-- [tl! highlight] -->\n            @foreach ($post->comments as $comment)\n                <!-- ... -->\n            @endforeach\n        </div>\n    @endif\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-3","text":"   @endif\n</div>\n```\nBecause `wire:transition` has been added to the `<div>` containing the post's comments, when the \"Show comments\" button is pressed, `$showComments` will be set to `true` and the comments will \"fade\" onto the page instead of abruptly appearing.","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-4","text":" abruptly appearing.\n\n## Limitations\n\nCurrently, `wire:transition` is only supported on a single element inside a Blade conditional like `@if`. It will not work as expected when used in a list of sibling elements. For example, the following will NOT work properly:","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-5","text":"l NOT work properly:\n\n```blade\n<!-- Warning: The following is code that will not work properly -->\n<ul>\n    @foreach ($post->comments as $comment)\n        <li wire:transition wire:key=\"{{ $comment->id }}\">{{ $comment->content }}</li>\n    @endforeach\n</ul>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-6","text":"endforeach\n</ul>\n```\n\nIf one of the above comment `<li>` elements were to get removed, you would expect Livewire to transition it out. However, because of hurdles with Livewire's underlying \"morph\" mechanism, this will not be the case. There is currently no way to transition dynamic lists in Livewire using `wire:transition`.\n\n## Default transition style","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-7","text":"ult transition style\n\nBy default, Livewire applies both an opacity and a scale CSS transition to elements with `wire:transition`. Here's a visual preview:","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-8","text":"'s a visual preview:\n\n<div x-data=\"{ show: false }\" x-cloak class=\"border border-gray-700 rounded-xl p-6 w-full flex justify-between\">\n    <a href=\"#\" x-on:click.prevent=\"show = ! show\" class=\"py-2.5 outline-none\">\n        Preview transition <span x-text=\"show ? 'out' : 'in →'\">in</span>\n    </a>\n    <div class=\"hey\">\n        <div\n            x-show=\"show\"\n            x-transition","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-9","text":"        x-transition\n            class=\"inline-flex px-16 py-2.5 rounded-[10px] bg-pink-400 text-white uppercase font-medium transition focus-visible:outline-none focus-visible:!ring-1 focus-visible:!ring-white\"\n            style=\"\n                background: linear-gradient(109.48deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.1) 100%), #EE5D99;","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-10","text":"0.1) 100%), #EE5D99;\n                box-shadow: inset 0px -1px 0px rgba(0, 0, 0, 0.5), inset 0px 1px 0px rgba(255, 255, 255, 0.1);\n            \"\n        >\n            &nbsp;\n        </div>\n    </div>\n</div>","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-11","text":"v>\n    </div>\n</div>\n\nThe above transition uses the following values for transitioning by default:\n\nTransition in | Transition out\n--- | ---\n`duration: 150ms` | `duration: 75ms`\n`opacity: [0 - 100]` | `opacity: [100 - 0]`\n`transform: scale([0.95 - 1])` | `transform: scale([1 - 0.95])`\n\n## Customizing transitions","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-12","text":"tomizing transitions\n\nTo customize the CSS Livewire internally uses when transitioning, you can use any combination of the available modifiers:","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-13","text":"available modifiers:\n\nModifier | Description\n--- | ---\n`.in` | Only transition the element \"in\"\n`.out` | Only transition the element \"out\"\n`.duration.[?]ms` | Customize the transition duration in milliseconds\n`.duration.[?]s` | Customize the transition duration in seconds\n`.delay.[?]ms` | Customize the transition delay in milliseconds\n`.delay.[?]s` | Customize the transition delay in seconds","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-14","text":"ion delay in seconds\n`.opacity` | Only apply the opacity transition\n`.scale` | Only apply the scale transition\n`.origin.[top\\|bottom\\|left\\|right]` | Customize the scale \"origin\" used","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-15","text":" scale \"origin\" used\n\nBelow is a list of various transition combinations that may help to better visualize these customizations:\n\n**Fade-only transition**","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-16","text":"de-only transition**\n\nBy default, Livewire both fades and scales the element when transitioning. You can disable scaling and only fade by adding the `.opacity` modifier. This is useful for things like transitioning a full-page overlay, where adding a scale doesn't make sense.\n\n```html\n<div wire:transition.opacity>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-17","text":"nsition.opacity>\n```\n\n<div x-data=\"{ show: false }\" x-cloak class=\"border border-gray-700 rounded-xl p-6 w-full flex justify-between\">\n    <a href=\"#\" x-on:click.prevent=\"show = ! show\" class=\"py-2.5 outline-none\">\n        Preview transition <span x-text=\"show ? 'out' : 'in →'\">in</span>\n    </a>\n    <div class=\"hey\">\n        <div\n            x-show=\"show\"\n            x-transition.opacity","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-18","text":"x-transition.opacity\n            class=\"inline-flex px-16 py-2.5 rounded-[10px] bg-pink-400 text-white uppercase font-medium transition focus-visible:outline-none focus-visible:!ring-1 focus-visible:!ring-white\"\n            style=\"\n                background: linear-gradient(109.48deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.1) 100%), #EE5D99;","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-19","text":"0.1) 100%), #EE5D99;\n                box-shadow: inset 0px -1px 0px rgba(0, 0, 0, 0.5), inset 0px 1px 0px rgba(255, 255, 255, 0.1);\n            \"\n        >\n            ...\n        </div>\n    </div>\n</div>","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-20","text":"v>\n    </div>\n</div>\n\n**Fade-out transition**\n\nA common transition technique is to show an element immediately when transitioning in, and fade its opacity when transitioning out. You'll notice this effect on most native MacOS dropdowns and menus. Therefore it's commonly applied on the web to dropdowns, popovers, and menus.\n\n```html\n<div wire:transition.out.opacity.duration.200ms>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-21","text":".duration.200ms>\n```\n\n<div x-data=\"{ show: false }\" x-cloak class=\"border border-gray-700 rounded-xl p-6 w-full flex justify-between\">\n    <a href=\"#\" x-on:click.prevent=\"show = ! show\" class=\"py-2.5 outline-none\">\n        Preview transition <span x-text=\"show ? 'out' : 'in →'\">in</span>\n    </a>\n    <div class=\"hey\">\n        <div\n            x-show=\"show\"","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-22","text":"       x-show=\"show\"\n            x-transition.out.opacity.duration.200ms\n            class=\"inline-flex px-16 py-2.5 rounded-[10px] bg-pink-400 text-white uppercase font-medium transition focus-visible:outline-none focus-visible:!ring-1 focus-visible:!ring-white\"\n            style=\"\n                background: linear-gradient(109.48deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.1) 100%), #EE5D99;","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-23","text":"0.1) 100%), #EE5D99;\n                box-shadow: inset 0px -1px 0px rgba(0, 0, 0, 0.5), inset 0px 1px 0px rgba(255, 255, 255, 0.1);\n            \"\n        >\n            ...\n        </div>\n    </div>\n</div>","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-24","text":"v>\n    </div>\n</div>\n\n**Origin-top transition**\n\nWhen using Livewire to transition an element such as a dropdown menu, it makes sense to scale in from the top of the menu as the origin, rather than center (Livewire's default). This way the menu feels visually anchored to the element that triggered it.\n\n```html\n<div wire:transition.scale.origin.top>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-25","text":"cale.origin.top>\n```\n\n<div x-data=\"{ show: false }\" x-cloak class=\"border border-gray-700 rounded-xl p-6 w-full flex justify-between\">\n    <a href=\"#\" x-on:click.prevent=\"show = ! show\" class=\"py-2.5 outline-none\">\n        Preview transition <span x-text=\"show ? 'out' : 'in →'\">in</span>\n    </a>\n    <div class=\"hey\">\n        <div\n            x-show=\"show\"\n            x-transition.origin.top","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-26","text":"ransition.origin.top\n            class=\"inline-flex px-16 py-2.5 rounded-[10px] bg-pink-400 text-white uppercase font-medium transition focus-visible:outline-none focus-visible:!ring-1 focus-visible:!ring-white\"\n            style=\"\n                background: linear-gradient(109.48deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.1) 100%), #EE5D99;","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-27","text":"0.1) 100%), #EE5D99;\n                box-shadow: inset 0px -1px 0px rgba(0, 0, 0, 0.5), inset 0px 1px 0px rgba(255, 255, 255, 0.1);\n            \"\n        >\n            ...\n        </div>\n    </div>\n</div>","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-28","text":"v>\n    </div>\n</div>\n\n> [!tip] Livewire uses Alpine transitions behind the scenes","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-29","text":"ns behind the scenes\n> When using `wire:transition` on an element, Livewire is internally applying Alpine's `x-transition` directive. Therefore you can use most if not all syntaxes you would normally use with `x-transition`. Check out [Alpine's transition documentation](https://alpinejs.dev/directives/transition) for all its capabilities.","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"f23decbbcb9fd3370c25c8d6b0734d33-30","text":"ll its capabilities.\n\n","source":"/Users/fyyx/Documents/livewire/docs/wire-transition.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-0","text":"\nTo begin your Livewire journey, we will create a simple \"counter\" component and render it in the browser. This example is a great way to experience Livewire for the first time as it demonstrates Livewire's _liveness_ in the simplest way possible.\n\n## Prerequisites\n\nBefore we start, make sure you have the following installed:\n\n- Laravel version 10 or later\n- PHP version 8.1 or later","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-1","text":"version 8.1 or later\n\n## Install Livewire\n\nFrom the root directory of your Laravel app, run the following [Composer](https://getcomposer.org/) command:\n\n```shell\ncomposer require livewire/livewire\n```","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-2","text":"ivewire/livewire\n```\n\n> [!warning] Make sure Alpine isn't already installed","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-3","text":"'t already installed\n> If the application you are using already has AlpineJS installed, you will need to remove it for Livewire to work properly; otherwise, Alpine will be loaded twice and Livewire won't function. For example, if you installed the Laravel Breeze \"Blade with Alpine\" starter kit, you will need to remove Alpine from `resources/js/app.js`.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-4","text":"esources/js/app.js`.\n\n## Create a Livewire component\n\nLivewire provides a convenient Artisan command to generate new components quickly. Run the following command to make a new `Counter` component:\n\n```shell\nphp artisan make:livewire counter\n```\n\nThis command will generate two new files in your project:\n* `app/Livewire/Counter.php`\n* `resources/views/livewire/counter.blade.php`","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-5","text":"e/counter.blade.php`\n\n## Writing the class\n\nOpen `app/Livewire/Counter.php` and replace its contents with the following:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass Counter extends Component\n{\n    public $count = 1;\n\n    public function increment()\n    {\n        $this->count++;\n    }\n\n    public function decrement()\n    {\n        $this->count--;\n    }","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-6","text":"this->count--;\n    }\n\n    public function render()\n    {\n        return view('livewire.counter');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-7","text":"unter');\n    }\n}\n```\n\nHere's a brief explanation of the code above:\n- `public $count = 1;` — Declares a public property named `$count` with an initial value of `1`.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-8","text":"nitial value of `1`.\n- `public function increment()` — Declares a public method named `increment()` that increments the `$count` property each time it's called. Public methods like this can be triggered from the browser in a variety of ways, including when a user clicks a button.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-9","text":"ser clicks a button.\n- `public function render()` — Declares a `render()` method that returns a Blade view. This Blade view will contain the HTML template for our component.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-10","text":"e for our component.\n\n## Writing the view\n\nOpen the `resources/views/livewire/counter.blade.php` file and replace its content with the following:\n\n```blade\n<div>\n    <h1>{{ $count }}</h1>\n\n    <button wire:click=\"increment\">+</button>\n\n    <button wire:click=\"decrement\">-</button>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-11","text":"</button>\n</div>\n```\n\nThis code will display the value of the `$count` property and two buttons that increment and decrement the `$count` property, respectively.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-12","text":"perty, respectively.\n\n> [!warning] Livewire components MUST have a single root element\n> In order for Livewire to work, components must have just **one** single element as its root. If multiple root elements are detected, an exception is thrown. It is recommended to use a `<div>` element as in the example. HTML comments count as separate elements and should be put inside the root element.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-13","text":"de the root element.\n> When rendering [full-page components](/docs/components#full-page-components), named slots for the layout file may be put outside the root element. These are removed before the component is rendered.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-14","text":"mponent is rendered.\n\n## Register a route for the component\n\nOpen the `routes/web.php` file in your Laravel application and add the following code:\n\n```php\nuse App\\Livewire\\Counter;\n\nRoute::get('/counter', Counter::class);\n```","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-15","text":"Counter::class);\n```\n\nNow, our _counter_ component is assigned to the `/counter` route, so that when a user visits the `/counter` endpoint in your application, this component will be rendered by the browser.\n\n## Create a template layout","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-16","text":"te a template layout\n\nBefore you can visit `/counter` in the browser, we need an HTML layout for our component to render inside. By default, Livewire will automatically look for a layout file named: `resources/views/components/layouts/app.blade.php`\n\nYou may create this file if it doesn't already exist by running the following command:\n\n```shell\nphp artisan livewire:layout\n```","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-17","text":" livewire:layout\n```\n\nThis command will generate a file called `resources/views/components/layouts/app.blade.php` with the following contents:\n\n```blade\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-18","text":" initial-scale=1.0\">\n\n        <title>{{ $title ?? 'Page Title' }}</title>\n    </head>\n    <body>\n        {{ $slot }}\n    </body>\n</html>\n```\n\nThe _counter_ component will be rendered in place of the `$slot` variable in the template above.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-19","text":" the template above.\n\nYou may have noticed there is no JavaScript or CSS assets provided by Livewire. That is because Livewire 3 and above automatically injects any frontend assets it needs.\n\n## Test it out\n\nWith our component class and templates in place, our component is ready to test!","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-20","text":"nt is ready to test!\n\nVisit `/counter` in your browser, and you should see a number displayed on the screen with two buttons to increment and decrement the number.\n\nAfter clicking one of the buttons, you will notice that the count updates in real time, without the page reloading. This is the magic of Livewire: dynamic frontend applications written entirely in PHP.","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"a3bb466ea25aadefe7914e503ee56a32-21","text":"ten entirely in PHP.\n\nWe've barely scratched the surface of what Livewire is capable of. Keep reading the documentation to see everything Livewire has to offer.\n","source":"/Users/fyyx/Documents/livewire/docs/quickstart.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-0","text":"Components are the building blocks of your Livewire application. They combine state and behavior to create reusable pieces of UI for your front end. Here, we'll cover the basics of creating and rendering components.\n\n## Creating components\n\nA Livewire component is simply a PHP class that extends `Livewire\\Component`. You can create component files by hand or use the following Artisan command:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-1","text":"ing Artisan command:\n\n```shell\nphp artisan make:livewire CreatePost\n```\n\nIf you prefer kebab-cased names, you can use them as well:\n\n```shell\nphp artisan make:livewire create-post\n```\n\nAfter running this command, Livewire will create two new files in your application. The first will be the component's class: `app/Livewire/CreatePost.php`\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-2","text":"espace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n\tpublic function render()\n\t{\n\t\treturn view('livewire.create-post');\n\t}\n}\n```\n\nThe second will be the component's Blade view: `resources/views/livewire/create-post.blade.php`\n\n```blade\n<div>\n\t{{-- ... --}}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-3","text":" ... --}}\n</div>\n```\n\nYou may use namespace syntax or dot-notation to create your components in sub-directories. For example, the following commands will create a `CreatePost` component in the `Posts` sub-directory:\n\n```shell\nphp artisan make:livewire Posts\\\\CreatePost\nphp artisan make:livewire posts.create-post\n```\n\n### Inline components","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-4","text":"## Inline components\n\nIf your component is fairly small, you may want to create an _inline_ component. Inline components are single-file Livewire components whose view template is contained directly in the `render()` method rather than a separate file:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-5","text":" Livewire\\Component;\n\nclass CreatePost extends Component\n{\n\tpublic function render()\n\t{\n\t\treturn <<<'HTML' // [tl! highlight:4]\n\t\t<div>\n\t\t    {{-- Your Blade template goes here... --}}\n\t\t</div>\n\t\tHTML;\n\t}\n}\n```\n\nYou can create inline components by adding the `--inline` flag to the `make:livewire` command:\n\n```shell\nphp artisan make:livewire CreatePost --inline\n```\n\n### Omitting the render method","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-6","text":"ng the render method\n\nTo reduce boilerplate in your components, you can omit the `render()` method entirely and Livewire will use its own underlying `render()` method, which returns a view with the conventional name corresponding to your component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    //\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-7","text":"onent\n{\n    //\n}\n```\n\nIf the component above is rendered on a page, Livewire will automatically determine it should be rendered using the `livewire.create-post` template.\n\n### Customizing component stubs\n\nYou can customize the files (or _stubs_) Livewire uses to generate new components by running the following command:\n\n```shell\nphp artisan livewire:stubs\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-8","text":"n livewire:stubs\n```\n\nThis will create four new files in your application:\n\n* `stubs/livewire.stub` — used for generating new components\n* `stubs/livewire.inline.stub` — used for generating _inline_ components\n* `stubs/livewire.test.stub` — used for generating test files\n* `stubs/livewire.view.stub` — used for generating component views","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-9","text":"ting component views\n\nEven though these files live in your application, you can still use the `make:livewire` Artisan command and Livewire will automatically use your custom stubs when generating files.\n\n## Setting properties","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-10","text":"# Setting properties\n\nLivewire components have properties that store data and can be easily accessed within the component's class and Blade view. This section discusses the basics of adding a property to a component and using it in your application.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-11","text":"in your application.\n\nTo add a property to a Livewire component, declare a public property in your component class. For example, let's create a `$title` property in the `CreatePost` component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public $title = 'Post title...';","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-12","text":"e = 'Post title...';\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```\n\n### Accessing properties in the view\n\nComponent properties are automatically made available to the component's Blade view. You can reference it using standard Blade syntax. Here we'll display the value of the `$title` property:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-13","text":"e `$title` property:\n\n```blade\n<div>\n    <h1>Title: \"{{ $title }}\"</h1>\n</div>\n```\n\nThe rendered output of this component would be:\n\n```blade\n<div>\n    <h1>Title: \"Post title...\"</h1>\n</div>\n```\n\n### Sharing additional data with the view","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-14","text":"l data with the view\n\nIn addition to accessing properties from the view, you can explicitly pass data to the view from the `render()` method, like you might typically do from a controller. This can be useful when you want to pass additional data without first storing it as a property—because properties have [specific performance and security implications](/docs/properties#security-concerns).","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-15","text":"#security-concerns).\n\nTo pass data to the view in the `render()` method, you can use the `with()` method on the view instance. For example, let's say you want to pass the post author's name to the view. In this case, the post's author is the currently authenticated user:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-16","text":" Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public $title;\n\n    public function render()\n    {\n        return view('livewire.create-post')->with([\n\t        'author' => Auth::user()->name,\n\t    ]);\n    }\n}\n```\n\nNow you may access the `$author` property from the component's Blade view:\n\n```blade\n<div>\n\t<h1>Title: {{ $title }}</h1>\n\n\t<span>Author: {{ $author }}</span>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-17","text":"}}</span>\n</div>\n```\n\n### Adding `wire:key` to `@foreach` loops\n\nWhen looping through data in a Livewire template using `@foreach`, you must add a unique `wire:key` attribute to the root element rendered by the loop.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-18","text":"endered by the loop.\n\nWithout a `wire:key` attribute present within a Blade loop, Livewire won't be able to properly match old elements to their new positions when the loop changes. This can cause many hard to diagnose issues in your application.\n\nFor example, if you are looping through an array of posts, you may set the `wire:key` attribute to the post's ID:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-19","text":"te to the post's ID:\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <div wire:key=\"{{ $post->id }}\"> <!-- [tl! highlight] -->\n            <!-- ... -->\n        </div>\n    @endforeach\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-20","text":"ndforeach\n</div>\n```\n\nIf you are looping through an array that is rendering Livewire components you may set the key as a component attribute `:key` or pass the key as a third argument when using the `@livewire` directive.\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <livewire:post-item :$post :key=\"$post->id\">","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-21","text":"st :key=\"$post->id\">\n\n        @livewire(PostItem::class, ['post' => $post], key($post->id))\n    @endforeach\n</div>\n```\n\n### Binding inputs to properties\n\nOne of Livewire's most powerful features is \"data binding\": the ability to automatically keep properties in-sync with form inputs on the page.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-22","text":" inputs on the page.\n\nLet's bind the `$title` property from the `CreatePost` component to a text input using the `wire:model` directive:\n\n```blade\n<form>\n    <label for=\"title\">Title:</label>\n\n    <input type=\"text\" id=\"title\" wire:model=\"title\"> <!-- [tl! highlight] -->\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-23","text":"ght] -->\n</form>\n```\n\nAny changes made to the text input will be automatically synchronized with the `$title` property in your Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-24","text":" Livewire component.\n\n> [!warning] \"Why isn't my component live updating as I type?\"","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-25","text":"updating as I type?\"\n> If you tried this in your browser and are confused why the title isn't automatically updating, it's because Livewire only updates a component when an \"action\" is submitted—like pressing a submit button—not when a user types into a field. This cuts down on network requests and improves performance","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-26","text":"improves performance. To enable \"live\" updating as a user types, you can use `wire:model.live` instead. [Learn more about data binding](/docs/properties#data-binding).","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-27","text":"rties#data-binding).\n\n\nLivewire properties are extremely powerful and are an important concept to understand. For more information, check out the [Livewire properties documentation](/docs/properties).\n\n## Calling actions","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-28","text":"\n\n## Calling actions\n\nActions are methods within your Livewire component that handle user interactions or perform specific tasks. They're often useful for responding to button clicks or form submissions on a page.\n\nTo learn more about actions, let's add a `save` action to the `CreatePost` component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-29","text":"use App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    public $title;\n\n    public function save() // [tl! highlight:8]\n    {\n\t\tPost::create([\n\t\t\t'title' => $this->title\n\t\t]);\n\n\t\treturn redirect()->to('/posts')\n\t\t\t ->with('status', 'Post created!');\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-30","text":"-post');\n    }\n}\n```\n\nNext, let's call the `save` action from the component's Blade view by adding the `wire:submit` directive to the `<form>` element:\n\n```blade\n<form wire:submit=\"save\"> <!-- [tl! highlight] -->\n    <label for=\"title\">Title:</label>\n\n    <input type=\"text\" id=\"title\" wire:model=\"title\">\n\n\t<button type=\"submit\">Save</button>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-31","text":"/button>\n</form>\n```\n\nWhen the \"Save\" button is clicked, the `save()` method in your Livewire component will be executed and your component will re-render.\n\nTo keep learning about Livewire actions, visit the [actions documentation](/docs/actions).\n\n## Rendering components\n\nThere are two ways to render a Livewire component on a page:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-32","text":"component on a page:\n\n1. Include it within an existing Blade view\n2. Assign it directly to a route as a full-page component\n\nLet's cover the first way to render your component, as it's simpler than the second.\n\nYou can include a Livewire component in your Blade templates using the `<livewire:component-name />` syntax:\n\n```blade\n<livewire:create-post />\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-33","text":"e:create-post />\n```\n\nIf the component class is nested deeper within the `app/Livewire/` directory, you may use the `.` character to indicate directory nesting. For example, if we assume a component is located at `app/Livewire/EditorPosts/CreatePost.php`, we may render it like so:\n\n```blade\n<livewire:editor-posts.create-post />\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-34","text":"s.create-post />\n```\n\n> [!warning] You must use kebab-case\n> As you can see in the snippets above, you must use the _kebab-cased_ version of the component name. Using the _StudlyCase_ version of the name (`<livewire:CreatePost />`) is invalid and won't be recognized by Livewire.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-35","text":"ognized by Livewire.\n\n\n### Passing data into components\n\nTo pass outside data into a Livewire component, you can use attributes on the component tag. This is useful when you want to initialize a component with specific data.\n\nTo pass an initial value to the `$title` property of the `CreatePost` component, you can use the following syntax:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-36","text":"he following syntax:\n\n```blade\n<livewire:create-post title=\"Initial Title\" />\n```\n\nIf you need to pass dynamic values or variables to a component, you can write PHP expressions in component attributes by prefixing the attribute with a colon:\n\n```blade\n<livewire:create-post :title=\"$initialTitle\" />\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-37","text":"initialTitle\" />\n```\n\nData passed into components is received through the `mount()` lifecycle hook as method parameters. In this case, to assign the `$title` parameter to a property, you would write a `mount()` method like the following:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public $title;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-38","text":"{\n    public $title;\n\n    public function mount($title = null)\n    {\n        $this->title = $title;\n    }\n\n    // ...\n}\n```\n\nIn this example, the `$title` property will be initialized with the value \"Initial Title\".","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-39","text":"lue \"Initial Title\".\n\nYou can think of the `mount()` method as a class constructor. It runs on the initial load of the component, but not on subsequent requests within a page. You can learn more about `mount()` and other helpful lifecycle hooks within the [lifecycle documentation](/docs/lifecycle-hooks).","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-40","text":"cs/lifecycle-hooks).\n\nTo reduce boilerplate code in your components, you can alternatively omit the `mount()` method and Livewire will automatically set any properties on your component with names matching the passed in values:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public $title; // [tl! highlight]\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-41","text":"t]\n\n    // ...\n}\n```\n\nThis is effectively the same as assigning `$title` inside a `mount()` method.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-42","text":" a `mount()` method.\n\n> [!warning] These properties are not reactive by default","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-43","text":" reactive by default\n> The `$title` property will not update automatically if the outer `:title=\"$initialValue\"` changes after the initial page load. This is a common point of confusion when using Livewire, especially for developers who have used JavaScript frameworks like Vue or React and assume these \"parameters\" behave like \"reactive props\" in those frameworks","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-44","text":" in those frameworks. But, don't worry, Livewire allows you to opt-in to [making your props reactive](/docs/nesting#reactive-props).","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-45","text":"ing#reactive-props).\n\n\n## Full-page components\n\nLivewire allows you to assign components directly to a route in your Laravel application. These are called \"full-page components\". You can use them to build standalone pages with logic and views, fully encapsulated within a Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-46","text":" Livewire component.\n\nTo create a full-page component, define a route in your `routes/web.php` file and use the `Route::get()` method to map the component directly to a specific URL. For example, let's imagine you want to render the `CreatePost` component at the dedicated route: `/posts/create`.\n\nYou can accomplish this by adding the following line to your `routes/web.php` file:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-47","text":"outes/web.php` file:\n\n```php\nuse App\\Livewire\\CreatePost;\n\nRoute::get('/posts/create', CreatePost::class);\n```\n\nNow, when you visit the `/posts/create` path in your browser, the `CreatePost` component will be rendered as a full-page component.\n\n### Layout files","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-48","text":"t.\n\n### Layout files\n\nRemember that full-page components will use your application's layout, typically defined in the `resources/views/components/layouts/app.blade.php` file.\n\nYou may create this file if it doesn't already exist by running the following command:\n\n```shell\nphp artisan livewire:layout\n```\n\nThis command will generate a file called `resources/views/components/layouts/app.blade.php`.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-49","text":"outs/app.blade.php`.\n\nEnsure you have created a Blade file at this location and included a `{{ $slot }}` placeholder:\n\n```blade\n<!-- resources/views/components/layouts/app.blade.php -->\n\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-50","text":" initial-scale=1.0\">\n\n        <title>{{ $title ?? 'Page Title' }}</title>\n    </head>\n    <body>\n        {{ $slot }}\n    </body>\n</html>\n```\n\n#### Global layout configuration\n\nTo use a custom layout across all your components, you can set the `layout` key in `config/livewire.php` to the path of your custom layout, relative to `resources/views`. For example:\n\n```php\n'layout' => 'layouts.app',\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-51","text":"> 'layouts.app',\n```\n\nWith the above configuration, Livewire will render full-page components inside the layout file: `resources/views/layouts/app.blade.php`.\n\n#### Per-component layout configuration\n\nTo use a different layout for a specific component, you can place Livewire's `#[Layout]` attribute above the component's `render()` method, passing it the relative view path of your custom layout:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-52","text":" your custom layout:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Attributes\\Layout;\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n\t// ...\n\n\t#[Layout('layouts.app')] // [tl! highlight]\n\tpublic function render()\n\t{\n\t    return view('livewire.create-post');\n\t}\n}\n```\n\nOr if you prefer, you can use this attribute above the class declaration:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-53","text":"ation:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Attributes\\Layout;\nuse Livewire\\Component;\n\n#[Layout('layouts.app')] // [tl! highlight]\nclass CreatePost extends Component\n{\n\t// ...\n}\n```\n\nPHP attributes only support literal values. If you need to pass a dynamic value, or prefer this alternative syntax, you can use the fluent `->layout()` method in the component's `render()` method:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-54","text":"s `render()` method:\n\n```php\npublic function render()\n{\n    return view('livewire.create-post')\n\t     ->layout('layouts.app'); // [tl! highlight]\n}\n```\n\nAlternatively, Livewire supports using traditional Blade layout files with `@extends`.\n\nGiven the following layout file:\n\n```blade\n<body>\n    @yield('content')\n</body>\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-55","text":"ontent')\n</body>\n```\n\nYou can configure Livewire to reference it using `->extends()` instead of `->layout()`:\n\n```php\npublic function render()\n{\n    return view('livewire.show-posts')\n        ->extends('layouts.app'); // [tl! highlight]\n}\n```\n\nIf you need to configure the `@section` for the component to use, you can configure that as well with the `->section()` method:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-56","text":"->section()` method:\n\n```php\npublic function render()\n{\n    return view('livewire.show-posts')\n        ->extends('layouts.app')\n        ->section('body'); // [tl! highlight]\n}\n```\n\n### Setting the page title\n\nAssigning unique page titles to each page in your application is helpful for both users and search engines.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-57","text":" and search engines.\n\nTo set a custom page title for a full-page component, first, make sure your layout file includes a dynamic title:\n\n```blade\n<head>\n    <title>{{ $title ?? 'Page Title' }}</title>\n</head>\n```\n\nNext, above your Livewire component's `render()` method, add the `#[Title]` attribute and pass it your page title:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-58","text":"espace App\\Livewire;\n\nuse Livewire\\Attributes\\Title;\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n\t// ...\n\n\t#[Title('Create Post')] // [tl! highlight]\n\tpublic function render()\n\t{\n\t    return view('livewire.create-post');\n\t}\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-59","text":"ate-post');\n\t}\n}\n```\n\nThis will set the page title for the `CreatePost` Livewire component. In this example, the page title will be \"Create Post\" when the component is rendered.\n\nIf you prefer, you can use this attribute above the class declaration:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Attributes\\Title;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-60","text":" Livewire\\Component;\n\n#[Title('Create Post')] // [tl! highlight]\nclass CreatePost extends Component\n{\n\t// ...\n}\n```\n\nIf you need to pass a dynamic title, such as a title that uses a component property, you can use the `->title()` fluent method in the component's `render()` method:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-61","text":"s `render()` method:\n\n```php\npublic function render()\n{\n    return view('livewire.create-post')\n\t     ->title('Create Post'); // [tl! highlight]\n}\n```\n\n### Setting additional layout file slots","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-62","text":"al layout file slots\n\nIf your [layout file](#layout-files) has any named slots in addition to `$slot`, you can set their content in your Blade view by defining `<x-slot>`s outside your root element. For example, if you want to be able to set the page language for each component individually, you can add a dynamic `$lang` slot into the opening HTML tag in your layout file:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-63","text":"in your layout file:\n\n```blade\n<!-- resources/views/components/layouts/app.blade.php -->\n\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', $lang ?? app()->getLocale()) }}\"> <!-- [tl! highlight] -->\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-64","text":" initial-scale=1.0\">\n\n        <title>{{ $title ?? 'Page Title' }}</title>\n    </head>\n    <body>\n        {{ $slot }}\n    </body>\n</html>\n```\n\nThen, in your component view, define an `<x-slot>` element outside the root element:\n\n```blade\n<x-slot:lang>fr</x-slot> // This component is in French <!-- [tl! highlight] -->\n\n<div>\n    // French content goes here...\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-65","text":"s here...\n</div>\n```\n\n\n### Accessing route parameters\n\nWhen working with full-page components, you may need to access route parameters within your Livewire component.\n\nTo demonstrate, first, define a route with a parameter in your `routes/web.php` file:\n\n```php\nuse App\\Livewire\\ShowPost;\n\nRoute::get('/posts/{id}', ShowPost::class);\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-66","text":"howPost::class);\n```\n\nHere, we've defined a route with an `id` parameter which represents a post's ID.\n\nNext, update your Livewire component to accept the route parameter in the `mount()` method:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Models\\Post;\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    public Post $post;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-67","text":"  public Post $post;\n\n    public function mount($id) // [tl! highlight]\n    {\n        $this->post = Post::findOrFail($id);\n    }\n\n    public function render()\n    {\n        return view('livewire.show-post');\n    }\n}\n```\n\nIn this example, because the parameter name `$id` matches the route parameter `{id}`, if the `/posts/1` URL is visited, Livewire will pass the value of \"1\" as `$id`.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-68","text":"lue of \"1\" as `$id`.\n\n### Using route model binding\n\nLaravel's route model binding allows you to automatically resolve Eloquent models from route parameters.\n\nAfter defining a route with a model parameter in your `routes/web.php` file:\n\n```php\nuse App\\Livewire\\ShowPost;\n\nRoute::get('/posts/{post}', ShowPost::class);\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-69","text":"howPost::class);\n```\n\nYou can now accept the route model parameter through the `mount()` method of your component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Models\\Post;\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    public Post $post;\n\n    public function mount(Post $post) // [tl! highlight]\n    {\n        $this->post = $post;\n    }","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-70","text":">post = $post;\n    }\n\n    public function render()\n    {\n        return view('livewire.show-post');\n    }\n}\n```\n\nLivewire knows to use \"route model binding\" because the `Post` type-hint is prepended to the `$post` parameter in `mount()`.\n\nLike before, you can reduce boilerplate by omitting the `mount()` method:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-71","text":"use App\\Models\\Post;\n\nclass ShowPost extends Component\n{\n    public Post $post; // [tl! highlight]\n\n    public function render()\n    {\n        return view('livewire.show-post');\n    }\n}\n```\n\nThe `$post` property will automatically be assigned to the model bound via the route's `{post}` parameter.\n\n### Modifying the response","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-72","text":"difying the response\n\nIn some scenarios, you might want to modify the response and set a custom response header. You can hook into the response object by calling the `response()` method on the view and use a closure to modify the response object:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse Illuminate\\Http\\Response;","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-73","text":"inate\\Http\\Response;\n\nclass ShowPost extends Component\n{\n    public function render()\n    {\n        return view('livewire.show-post')\n            ->response(function(Response $response) {\n                $response->header('X-Custom-Header', true);\n            });\n    }\n}\n```\n\n## Using JavaScript","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-74","text":"\n## Using JavaScript\n\nThere are many instances where the built-in Livewire and Alpine utilities aren't enough to accomplish your goals inside your Livewire components.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-75","text":"Livewire components.\n\nFortunately, Livewire provides many useful extension points and utilities to interact with bespoke JavaScript. You can learn from the exhaustive reference on [the JavaScript documentation page](/docs/javascript). But for now, here are a few useful ways to use your own JavaScript inside your Livewire components.\n\n### Executing scripts","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-76","text":"## Executing scripts\n\nLivewire provides a helpful `@script` directive that, when wrapping a `<script>` element, will execute the given JavaScript when your component is initialized on the page.\n\nHere is an example of a simple `@script` that uses JavaScript's `setInterval()` to refresh your component every two seconds:","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-77","text":"t every two seconds:\n\n```blade\n@script\n<script>\n    setInterval(() => {\n        $wire.$refresh()\n    }, 2000)\n</script>\n@endscript\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-78","text":"ript>\n@endscript\n```\n\nYou'll notice we are using an object called `$wire` inside the `<script>` to control the component. Livewire automatically makes this object available inside any `@script`s. If you're unfamiliar with `$wire`, you can learn more about `$wire` in the following documentation:\n* [Accessing properties from JavaScript](/docs/properties#accessing-properties-from-javascript)","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-79","text":"ies-from-javascript)\n* [Calling Livewire actions from JS/Alpine](/docs/actions#calling-actions-from-alpine)\n* [The `$wire` object reference](/docs/javascript#the-wire-object)","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-80","text":"ipt#the-wire-object)\n\n### Loading assets\n\nIn addition to one-off `@script`s, Livewire provides a helpful `@assets` utility to easily load any script/style dependencies on the page.\n\nIt also ensures that the provided assets are loaded only once per browser page, unlike `@script`, which executes every time a new instance of that Livewire component is initialized.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-81","text":"nent is initialized.\n\nHere is an example of using `@assets` to load a date picker library called [Pikaday](https://github.com/Pikaday/Pikaday) and initialize it inside your component using `@script`:\n\n```blade\n<div>\n    <input type=\"text\" data-picker>\n</div>","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-82","text":" data-picker>\n</div>\n\n@assets\n<script src=\"https://cdn.jsdelivr.net/npm/pikaday/pikaday.js\" defer></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css\">\n@endassets\n\n@script\n<script>\n    new Pikaday({ field: $wire.$el.querySelector('[data-picker]') });\n</script>\n@endscript\n```","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-83","text":"ript>\n@endscript\n```\n\n> [!info] Using `@verbatim@script@endverbatim` and `@verbatim@assets@endverbatim` inside Blade components","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-84","text":"ide Blade components\n> If you are using [Blade components](https://laravel.com/docs/blade#components) to extract parts of your markup, you can use `@verbatim@script@endverbatim` and `@verbatim@assets@endverbatim` inside them as well; even if there are multiple Blade components inside the same Livewire component","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-85","text":"e Livewire component. However, `@verbatim@script@endverbatim` and `@verbatim@assets@endverbatim` are currently only supported in the context of a Livewire component, meaning if you use the given Blade component outside of Livewire entirely, those scripts and assets won't be loaded on the page.","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"e78387c49fddd8c6cdda1ee2c1c81b9b-86","text":" loaded on the page.\n","source":"/Users/fyyx/Documents/livewire/docs/components.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-0","text":"Laravel's pagination feature allows you to query a subset of data and provides your users with the ability to navigate between *pages* of those results.\n\nBecause Laravel's paginator was designed for static applications, in a non-Livewire app, each page navigation triggers a full browser visit to a new URL containing the desired page (`?page=2`).","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-1","text":"ed page (`?page=2`).\n\nHowever, when you use pagination inside a Livewire component, users can navigate between pages while remaining on the same page. Livewire will handle everything behind the scenes, including updating the URL query string with the current page.\n\n## Basic usage\n\nBelow is the most basic example of using pagination inside a `ShowPosts` component to only show ten posts at a time:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-2","text":"ten posts at a time:\n\n> [!warning] You must use the `WithPagination` trait\n> To take advantage of Livewire's pagination features, each component containing pagination must use the `Livewire\\WithPagination` trait.\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\WithPagination;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    use WithPagination;","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-3","text":" use WithPagination;\n\n    public function render()\n    {\n        return view('show-posts', [\n            'posts' => Post::paginate(10),\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    <div>\n        @foreach ($posts as $post)\n            <!-- ... -->\n        @endforeach\n    </div>\n\n    {{ $posts->links() }}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-4","text":"inks() }}\n</div>\n```\n\nAs you can see, in addition to limiting the number of posts shown via the `Post::paginate()` method, we will also use `$posts->links()` to render page navigation links.\n\nFor more information on pagination using Laravel, check out [Laravel's comprehensive pagination documentation](https://laravel.com/docs/pagination).\n\n## Disabling URL query string tracking","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-5","text":"uery string tracking\n\nBy default, Livewire's paginator tracks the current page in the browser URL's query string like so: `?page=2`.\n\nIf you wish to still use Livewire's pagination utility, but disable query string tracking, you can do so using the `WithoutUrlPagination` trait:\n\n```php\nuse Livewire\\WithoutUrlPagination;\nuse Livewire\\WithPagination;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-6","text":" Livewire\\Component;\n\nclass ShowPosts extends Component\n{\n    use WithPagination, WithoutUrlPagination; // [tl! highlight]\n\n    // ...\n}\n```\n\nNow, pagination will work as expected, but the current page won't show up in the query string. This also means the current page won't be persisted across page changes.\n\n## Customizing scroll behavior","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-7","text":"zing scroll behavior\n\nBy default, Livewire's paginator scrolls to the top of the page after every page change.\n\nYou can disable this behavior by passing `false` to the `scrollTo` parameter of the `links()` method like so:\n\n```blade\n{{ $posts->links(data: ['scrollTo' => false]) }}\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-8","text":"o' => false]) }}\n```\n\nAlternatively, you can provide any CSS selector to the `scrollTo` parameter, and Livewire will find the nearest element matching that selector and scroll to it after each navigation:\n\n```blade\n{{ $posts->links(data: ['scrollTo' => '#paginated-posts']) }}\n```\n\n## Resetting the page\n\nWhen sorting or filtering results, it is common to want to reset the page number back to `1`.","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-9","text":" number back to `1`.\n\nFor this reason, Livewire provides the `$this->resetPage()` method, allowing you to reset the page number from anywhere in your component.\n\nThe following component demonstrates using this method to reset the page after the search form is submitted:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\WithPagination;\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-10","text":"use App\\Models\\Post;\n\nclass SearchPosts extends Component\n{\n    use WithPagination;\n\n    public $query = '';\n\n    public function search()\n    {\n        $this->resetPage();\n    }\n\n    public function render()\n    {\n        return view('show-posts', [\n            'posts' => Post::where('title', 'like', '%'.$this->query.'%')->paginate(10),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-11","text":"     ]);\n    }\n}\n```\n\n```blade\n<div>\n    <form wire:submit=\"search\">\n        <input type=\"text\" wire:model=\"query\">\n\n        <button type=\"submit\">Search posts</button>\n    </form>\n\n    <div>\n        @foreach ($posts as $post)\n            <!-- ... -->\n        @endforeach\n    </div>\n\n    {{ $posts->links() }}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-12","text":"inks() }}\n</div>\n```\n\nNow, if a user was on page `5` of the results and then filtered the results further by pressing \"Search posts\", the page would be reset back to `1`.\n\n### Available page navigation methods\n\nIn addition to `$this->resetPage()`, Livewire provides other useful methods for navigating between pages programmatically from your component:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-13","text":"from your component:\n\n| Method        | Description                               |\n|-----------------|-------------------------------------------|\n| `$this->setPage($page)`    | Set the paginator to a specific page number |\n| `$this->resetPage()`    | Reset the page back to 1 |\n| `$this->nextPage()`    | Go to the next page |\n| `$this->previousPage()`    | Go to the previous page |","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-14","text":" the previous page |\n\n## Multiple paginators\n\nBecause both Laravel and Livewire use URL query string parameters to store and track the current page number, if a single page contains multiple paginators, it's important to assign them different names.\n\nTo demonstrate the problem more clearly, consider the following `ShowClients` component:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-15","text":"wClients` component:\n\n```php\nuse Livewire\\WithPagination;\nuse Livewire\\Component;\nuse App\\Models\\Client;\n\nclass ShowClients extends Component\n{\n    use WithPagination;\n\n    public function render()\n    {\n        return view('show-clients', [\n            'clients' => Client::paginate(10),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-16","text":"     ]);\n    }\n}\n```\n\nAs you can see, the above component contains a paginated set of *clients*. If a user were to navigate to page `2` of this result set, the URL might look like the following:\n\n```\nhttp://application.test/?page=2\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-17","text":"ion.test/?page=2\n```\n\nSuppose the page also contains a `ShowInvoices` component that also uses pagination. To independently track each paginator's current page, you need to specify a name for the second paginator like so:\n\n```php\nuse Livewire\\WithPagination;\nuse Livewire\\Component;\nuse App\\Models\\Invoices;\n\nclass ShowInvoices extends Component\n{\n    use WithPagination;","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-18","text":" use WithPagination;\n\n    public function render()\n    {\n        return view('show-invoices', [\n            'invoices' => Invoice::paginate(10, pageName: 'invoices-page'),\n        ]);\n    }\n}\n```\n\nNow, because of the `pageName` parameter that has been added to the `paginate` method, when a user visits page `2` of the *invoices*, the URL will contain the following:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-19","text":"ntain the following:\n\n```\nhttps://application.test/customers?page=2&invoices-page=2\n```\n\nWhen using Livewire's page navigation methods on a named paginator, you must provide the page name as an additional parameter:\n\n```php\n$this->setPage(2, pageName: 'invoices-page');\n\n$this->resetPage(pageName: 'invoices-page');\n\n$this->nextPage(pageName: 'invoices-page');","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-20","text":"e: 'invoices-page');\n\n$this->previousPage(pageName: 'invoices-page');\n```\n\n## Hooking into page updates\n\nLivewire allows you to execute code before and after a page is updated by defining either of the following methods inside your component:\n\n```php\nuse Livewire\\WithPagination;\n\nclass ShowPosts extends Component\n{\n    use WithPagination;","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-21","text":" use WithPagination;\n\n    public function updatingPage($page)\n    {\n        // Runs before the page is updated for this component...\n    }\n\n    public function updatedPage($page)\n    {\n        // Runs after the page is updated for this component...\n    }\n\n    public function render()\n    {\n        return view('show-posts', [\n            'posts' => Post::paginate(10),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-22","text":"     ]);\n    }\n}\n```\n\n### Named paginator hooks\n\nThe previous hooks only apply to the default paginator. If you are using a named paginator, you must define the methods using the paginator's name.\n\nFor example, below is an example of what a hook for a paginator named `invoices-page` would look like:\n\n```php\npublic function updatingInvoicesPage($page)\n{\n    //\n}\n```\n\n### General paginator hooks","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-23","text":"eral paginator hooks\n\nIf you prefer to not reference the paginator name in the hook method name, you can use the more generic alternatives and simply receive the `$pageName` as a second argument to the hook method:\n\n```php\npublic function updatingPaginators($page, $pageName)\n{\n    // Runs before the page is updated for this component...\n}","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-24","text":" this component...\n}\n\npublic function updatedPaginators($page, $pageName)\n{\n    // Runs after the page is updated for this component...\n}\n```\n\n## Using the simple theme\n\nYou can use Laravel's `simplePaginate()` method instead of `paginate()` for added speed and simplicity.","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-25","text":"peed and simplicity.\n\nWhen paginating results using this method, only *next* and *previous* navigation links will be shown to the user instead of individual links for each page number:\n\n```php\npublic function render()\n{\n    return view('show-posts', [\n        'posts' => Post::simplePaginate(10),\n    ]);\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-26","text":"e(10),\n    ]);\n}\n```\n\nFor more information on simple pagination, check out [Laravel's \"simplePaginator\" documentation](https://laravel.com/docs/pagination#simple-pagination).\n\n## Using cursor pagination\n\nLivewire also supports using Laravel's cursor pagination — a faster pagination method useful in large datasets:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-27","text":"l in large datasets:\n\n```php\npublic function render()\n{\n    return view('show-posts', [\n        'posts' => Post::cursorPaginate(10),\n    ]);\n}\n```\n\nBy using `cursorPaginate()` instead of `paginate()` or `simplePaginate()`, the query string in your application's URL will store an encoded *cursor* instead of a standard page number. For example:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-28","text":"number. For example:\n\n```\nhttps://example.com/posts?cursor=eyJpZCI6MTUsIl9wb2ludHNUb05leHRJdGVtcyI6dHJ1ZX0\n```\n\nFor more information on cursor pagination, check out [Laravel's cursor pagination documentation](https://laravel.com/docs/pagination#cursor-pagination).\n\n## Using Bootstrap instead of Tailwind","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-29","text":" instead of Tailwind\n\nIf you are using [Bootstrap](https://getbootstrap.com/) instead of [Tailwind](https://tailwindcss.com/) as your application's CSS framework, you can configure Livewire to use Bootstrap styled pagination views instead of the default Tailwind views.\n\nTo accomplish this, set the `pagination_theme` configuration value in your application's `config/livewire.php` file:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-30","text":"/livewire.php` file:\n\n```php\n'pagination_theme' => 'bootstrap',\n```\n\n> [!info] Publishing Livewire's configuration file\n> Before customizing the pagination theme, you must first publish Livewire's configuration file to your application's `/config` directory by running the following command:\n> ```shell\n> php artisan livewire:publish --config\n> ```\n\n## Modifying the default pagination views","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-31","text":"ult pagination views\n\nIf you want to modify Livewire's pagination views to fit your application's style, you can do so by *publishing* them using the following command:\n\n```shell\nphp artisan livewire:publish --pagination\n```\n\nAfter running this command, the following four files will be inserted into the `resources/views/vendor/livewire` directory:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-32","text":"livewire` directory:\n\n| View file name        | Description                               |\n|-----------------|-------------------------------------------|\n| `tailwind.blade.php`    | The standard Tailwind pagination theme |\n| `tailwind-simple.blade.php`    | The *simple* Tailwind pagination theme |\n| `bootstrap.blade.php`    | The standard Bootstrap pagination theme |","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-33","text":"p pagination theme |\n| `bootstrap-simple.blade.php`    | The *simple* Bootstrap pagination theme |","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-34","text":"p pagination theme |\n\nOnce the files have been published, you have complete control over them. When rendering pagination links using the paginated result's `->links()` method inside your template, Livewire will use these files instead of its own.\n\n## Using custom pagination views\n\nIf you wish to bypass Livewire's pagination views entirely, you can render your own in one of two ways:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-35","text":" in one of two ways:\n\n1. The `->links()` method in your Blade view\n2. The `paginationView()` or `paginationSimpleView()` method in your component\n\n### Via `->links()`\n\nThe first approach is to simply pass your custom pagination Blade view name to the `->links()` method directly:\n\n```blade\n{{ $posts->links('custom-pagination-links') }}\n```","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-36","text":"ation-links') }}\n```\n\nWhen rendering the pagination links, Livewire will now look for a view at `resources/views/custom-pagination-links.blade.php`.\n\n### Via `paginationView()` or `paginationSimpleView()`\n\nThe second approach is to declare a `paginationView` or `paginationSimpleView` method inside your component which returns the name of the view you would like to use:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-37","text":"u would like to use:\n\n```php\npublic function paginationView()\n{\n    return 'custom-pagination-links-view';\n}\n\npublic function paginationSimpleView()\n{\n    return 'custom-simple-pagination-links-view';\n}\n```\n\n### Sample pagination view\n\nBelow is an unstyled sample of a simple Livewire pagination view for your reference.","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-38","text":" for your reference.\n\nAs you can see, you can use Livewire's page navigation helpers like `$this->nextPage()` directly inside your template by adding `wire:click=\"nextPage\"` to buttons:","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-39","text":"xtPage\"` to buttons:\n\n```blade\n<div>\n    @if ($paginator->hasPages())\n        <nav role=\"navigation\" aria-label=\"Pagination Navigation\">\n            <span>\n                @if ($paginator->onFirstPage())\n                    <span>Previous</span>\n                @else\n                    <button wire:click=\"previousPage\" wire:loading.attr=\"disabled\" rel=\"prev\">Previous</button>","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-40","text":"v\">Previous</button>\n                @endif\n            </span>","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"1441130039314f643071e5cb27cfbc5e-41","text":"\n            </span>\n\n            <span>\n                @if ($paginator->onLastPage())\n                    <span>Next</span>\n                @else\n                    <button wire:click=\"nextPage\" wire:loading.attr=\"disabled\" rel=\"next\">Next</button>\n                @endif\n            </span>\n        </nav>\n    @endif\n</div>\n```\n\n","source":"/Users/fyyx/Documents/livewire/docs/pagination.md"}
{"id":"968b392db52a56198380008a7d9f0784-0","text":"Polling is a technique used in web applications to \"poll\" the server (send regular requests) for updates. It's a simple way to keep a page up-to-date without the need for a more sophisticated technology like [WebSockets](/docs/events#real-time-events-using-laravel-echo).\n\n## Basic usage\n\nUsing polling inside Livewire is as simple as adding `wire:poll` to an element.","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-1","text":"poll` to an element.\n\nBelow is an example of a `SubscriberCount` component that shows a user's subscriber count:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-2","text":" Livewire\\Component;\n\nclass SubscriberCount extends Component\n{\n    public function render()\n    {\n        return view('livewire.subscriber-count', [\n            'count' => Auth::user()->subscribers->count(),\n        ]);\n    }\n}\n```\n\n```blade\n<div wire:poll>\n    Subscribers: {{ $count }}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-3","text":"$count }}\n</div>\n```\n\nNormally, this component would show the subscriber count for the user and never update until the page was refreshed. However, because of `wire:poll` on the component's template, this component will now refresh itself every `2.5` seconds, keeping the subscriber count up-to-date.\n\nYou can also specify an action to fire on the polling interval by passing a value to `wire:poll`:","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-4","text":"alue to `wire:poll`:\n\n```blade\n<div wire:poll=\"refreshSubscribers\">\n    Subscribers: {{ $count }}\n</div>\n```\n\nNow, the `refreshSubscribers()` method on the component will be called every `2.5` seconds.\n\n## Timing control","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-5","text":".\n\n## Timing control\n\nThe primary drawback of polling is that it can be resource intensive. If you have a thousand visitors on a page that uses polling, one thousand network requests will be triggered every `2.5` seconds.\n\nThe best way to reduce requests in this scenario is simply to make the polling interval longer.","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-6","text":"ing interval longer.\n\nYou can manually control how often the component will poll by appending the desired duration to `wire:poll` like so:\n\n```blade\n<div wire:poll.15s> <!-- In seconds... -->\n\n<div wire:poll.15000ms> <!-- In milliseconds... -->\n```\n\n## Background throttling","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-7","text":"ackground throttling\n\nTo further cut down on server requests, Livewire automatically throttles polling when a page is in the background. For example, if a user keeps a page open in a different browser tab, Livewire will reduce the number of polling requests by 95% until the user revisits the tab.","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-8","text":"er revisits the tab.\n\nIf you want to opt-out of this behavior and keep polling continuously, even when a tab is in the background, you can add the `.keep-alive` modifier to `wire:poll`:\n\n```blade\n<div wire:poll.keep-alive>\n```\n\n##  Viewport throttling","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-9","text":" Viewport throttling\n\nAnother measure you can take to only poll when necessary, is to add the `.visible` modifier to `wire:poll`. The `.visible` modifier instructs Livewire to only poll the component when it is visible on the page:\n\n```blade\n<div wire:poll.visible>\n```","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"968b392db52a56198380008a7d9f0784-10","text":"re:poll.visible>\n```\n\nIf a component using `wire:visible` is at the bottom of a long page, it won't start polling until the user scrolls it into the viewport. When the user scrolls away, it will stop polling again.\n","source":"/Users/fyyx/Documents/livewire/docs/polling.md"}
{"id":"e46579f30b50754b46012382566ee897-0","text":"\nIn certain circumstances it can be helpful for your users to know if they are currently connected to the internet.\n\nIf for example, you have built a blogging platform on Livewire, you may want to notify your users in some way if they are offline so that they don't draft an entire blog post without the ability for Livewire to save it to the database.","source":"/Users/fyyx/Documents/livewire/docs/wire-offline.md"}
{"id":"e46579f30b50754b46012382566ee897-1","text":" it to the database.\n\nLivewire make this trivial by providing the `wire:offline` directive. By attaching `wire:offline` to an element in your Livewire component, it will be hidden by default and only be displayed when Livewire detects the network connection has been interrupted and is unavailable. It will then disappear again when the network has regained connection.\n\nFor example:","source":"/Users/fyyx/Documents/livewire/docs/wire-offline.md"}
{"id":"e46579f30b50754b46012382566ee897-2","text":"ction.\n\nFor example:\n\n```blade\n<p class=\"alert alert-warning\" wire:offline>\n    Whoops, your device has lost connection. The web page you are viewing is offline.\n</p>\n```\n","source":"/Users/fyyx/Documents/livewire/docs/wire-offline.md"}
{"id":"c1ec2b78a2fd438568740db785345f0b-0","text":"\nThe `wire:current` directive allows you to easily detect and style currently active links on a page.\n\nHere's a simple example of adding `wire:current` to links in a navbar so that the currently active link has a stronger font weight:","source":"/Users/fyyx/Documents/livewire/docs/wire-current.md"}
{"id":"c1ec2b78a2fd438568740db785345f0b-1","text":"tronger font weight:\n\n```blade\n<nav>\n    <a href=\"/dashboard\" ... wire:current=\"font-bold text-zinc-800\">Dashboard</a>\n    <a href=\"/posts\" ... wire:current=\"font-bold text-zinc-800\">Posts</a>\n    <a href=\"/users\" ... wire:current=\"font-bold text-zinc-800\">Users</a>\n</nav>\n```\n\nNow when a user visits `/posts`, the \"Posts\" link will have a stronger font treatment than the other links.","source":"/Users/fyyx/Documents/livewire/docs/wire-current.md"}
{"id":"c1ec2b78a2fd438568740db785345f0b-2","text":"han the other links.\n\nYou should note that `wire:current` works out of the box with `wire:navigate` links and page changes.\n\n## Exact matching\n\nBy default, `wire:current` uses a partial matching strategy, meaning it will be applied if the link and current page share the beginning portion of the Url's path.","source":"/Users/fyyx/Documents/livewire/docs/wire-current.md"}
{"id":"c1ec2b78a2fd438568740db785345f0b-3","text":"n of the Url's path.\n\nFor example, if the link is `/posts`, and the current page is `/posts/1`, the `wire:current` directive will be applied.\n\nIf you wish to use exact matching, you can add the `.exact` modifier to the directive.\n\nHere's an example where you might want to use exact matching to prevent the \"Dashboard\" link from being highlighted when the user visits `/posts`:","source":"/Users/fyyx/Documents/livewire/docs/wire-current.md"}
{"id":"c1ec2b78a2fd438568740db785345f0b-4","text":"ser visits `/posts`:\n\n```blade\n<nav>\n    <a href=\"/\" wire:current.exact=\"font-bold\">Dashboard</a>\n</nav>\n```\n\n## Strict matching\n\nBy default, `wire:current` will remove trailing slashes (`/`) from its comparison.\n\nIf you'd like to disable this behavior and force a stract path string comparison, you can append the `.strict` modifier:","source":"/Users/fyyx/Documents/livewire/docs/wire-current.md"}
{"id":"c1ec2b78a2fd438568740db785345f0b-5","text":" `.strict` modifier:\n\n```blade\n<nav>\n    <a href=\"/posts/\" wire:current.strict=\"font-bold\">Dashboard</a>\n</nav>\n```\n\n## Troubleshooting\n\nIf `wire:current` is not detecting the current link correctly, ensure the following:\n\n* You have at least one Livewire component on the page, or have hardcoded `@livewireScripts` in your layout\n* You have a `href` attribute on the link.\n","source":"/Users/fyyx/Documents/livewire/docs/wire-current.md"}
{"id":"415790215ce403fc7e778bf035454013-0","text":"Livewire offers powerful support for uploading files within your components.\n\nFirst, add the `WithFileUploads` trait to your component. Once this trait has been added to your component, you can use `wire:model` on file inputs as if they were any other input type and Livewire will take care of the rest.\n\nHere's an example of a simple component that handles uploading a photo:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-1","text":"photo:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Livewire\\Attributes\\Validate;\n\nclass UploadPhoto extends Component\n{\n    use WithFileUploads;\n\n    #[Validate('image|max:1024')] // 1MB Max\n    public $photo;\n\n    public function save()\n    {\n        $this->photo->store(path: 'photos');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-2","text":"hotos');\n    }\n}\n```\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"file\" wire:model=\"photo\">\n\n    @error('photo') <span class=\"error\">{{ $message }}</span> @enderror\n\n    <button type=\"submit\">Save photo</button>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-3","text":"/button>\n</form>\n```\n\n> [!warning] The \"upload\" method is reserved\n> Notice the above example uses a \"save\" method instead of an \"upload\" method. This is a common \"gotcha\". The term \"upload\" is reserved by Livewire. You cannot use it as a method or property name in your component.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-4","text":"e in your component.\n\nFrom the developer's perspective, handling file inputs is no different than handling any other input type: Add `wire:model` to the `<input>` tag and everything else is taken care of for you.\n\nHowever, more is happening under the hood to make file uploads work in Livewire. Here's a glimpse at what goes on when a user selects a file to upload:","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-5","text":"ts a file to upload:\n\n1. When a new file is selected, Livewire's JavaScript makes an initial request to the component on the server to get a temporary \"signed\" upload URL.\n2. Once the URL is received, JavaScript does the actual \"upload\" to the signed URL, storing the upload in a temporary directory designated by Livewire and returning the new temporary file's unique hash ID.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-6","text":"le's unique hash ID.\n3. Once the file is uploaded and the unique hash ID is generated, Livewire's JavaScript makes a final request to the component on the server, telling it to \"set\" the desired public property to the new temporary file.\n4. Now, the public property (in this case, `$photo`) is set to the temporary file upload and is ready to be stored or validated at any point.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-7","text":"idated at any point.\n\n## Storing uploaded files\n\nThe previous example demonstrates the most basic storage scenario: moving the temporarily uploaded file to the \"photos\" directory on the application's default filesystem disk.\n\nHowever, you may want to customize the file name of the stored file or even specify a specific storage \"disk\" to keep the file on (such as S3).","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-8","text":"ile on (such as S3).\n\n> [!tip] Original file names\n> You can access the original file name of a temporary upload, by calling its `->getClientOriginalName()` method.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-9","text":"ginalName()` method.\n\nLivewire honors the same APIs Laravel uses for storing uploaded files, so feel free to consult [Laravel's file upload documentation](https://laravel.com/docs/filesystem#file-uploads). However, below are a few common storage scenarios and examples:","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-10","text":"narios and examples:\n\n```php\npublic function save()\n{\n    // Store the file in the \"photos\" directory of the default filesystem disk\n    $this->photo->store(path: 'photos');\n\n    // Store the file in the \"photos\" directory in a configured \"s3\" disk\n    $this->photo->store(path: 'photos', options: 's3');","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-11","text":"os', options: 's3');\n\n    // Store the file in the \"photos\" directory with the filename \"avatar.png\"\n    $this->photo->storeAs(path: 'photos', name: 'avatar');\n\n    // Store the file in the \"photos\" directory in a configured \"s3\" disk with the filename \"avatar.png\"\n    $this->photo->storeAs(path: 'photos', name: 'avatar', options: 's3');","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-12","text":"ar', options: 's3');\n\n    // Store the file in the \"photos\" directory, with \"public\" visibility in a configured \"s3\" disk\n    $this->photo->storePublicly(path: 'photos', options: 's3');","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-13","text":"os', options: 's3');\n\n    // Store the file in the \"photos\" directory, with the name \"avatar.png\", with \"public\" visibility in a configured \"s3\" disk\n    $this->photo->storePubliclyAs(path: 'photos', name: 'avatar', options: 's3');\n}\n```\n\n## Handling multiple files\n\nLivewire automatically handles multiple file uploads by detecting the `multiple` attribute on the `<input>` tag.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-14","text":"n the `<input>` tag.\n\nFor example, below is a component with an array property named `$photos`. By adding `multiple` to the form's file input, Livewire will automatically append new files to this array:\n\n```php\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Livewire\\Attributes\\Validate;\n\nclass UploadPhotos extends Component\n{\n    use WithFileUploads;","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-15","text":"use WithFileUploads;\n\n    #[Validate(['photos.*' => 'image|max:1024'])]\n    public $photos = [];\n\n    public function save()\n    {\n        foreach ($this->photos as $photo) {\n            $photo->store(path: 'photos');\n        }\n    }\n}\n```\n\n```blade\n<form wire:submit=\"save\">\n    <input type=\"file\" wire:model=\"photos\" multiple>","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-16","text":"l=\"photos\" multiple>\n\n    @error('photos.*') <span class=\"error\">{{ $message }}</span> @enderror\n\n    <button type=\"submit\">Save photo</button>\n</form>\n```\n\n## File validation\n\nLike we've discussed, validating file uploads with Livewire is the same as handling file uploads from a standard Laravel controller.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-17","text":" Laravel controller.\n\n> [!warning] Ensure S3 is properly configured\n> Many of the validation rules relating to files require access to the file. When [uploading directly to S3](#uploading-directly-to-amazon-s3), these validation rules will fail if the S3 file object is not publicly accessible.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-18","text":"publicly accessible.\n\nFor more information on file validation, consult [Laravel's file validation documentation](https://laravel.com/docs/validation#available-validation-rules).\n\n## Temporary preview URLs\n\nAfter a user chooses a file, you should typically show them a preview of that file before they submit the form and store the file.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-19","text":" and store the file.\n\nLivewire makes this trivial by using the `->temporaryUrl()` method on uploaded files.\n\n> [!info] Temporary URLs are restricted to images\n> For security reasons, temporary preview URLs are only supported on files with image MIME types.\n\nLet's explore an example of a file upload with an image preview:","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-20","text":"th an image preview:\n\n```php\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Livewire\\Attributes\\Validate;\n\nclass UploadPhoto extends Component\n{\n    use WithFileUploads;\n\n    #[Validate('image|max:1024')]\n    public $photo;\n\n    // ...\n}\n```\n\n```blade\n<form wire:submit=\"save\">\n    @if ($photo) <!-- [tl! highlight:2] -->\n        <img src=\"{{ $photo->temporaryUrl() }}\">\n    @endif","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-21","text":"rl() }}\">\n    @endif\n\n    <input type=\"file\" wire:model=\"photo\">\n\n    @error('photo') <span class=\"error\">{{ $message }}</span> @enderror\n\n    <button type=\"submit\">Save photo</button>\n</form>\n```\n\nAs previously discussed, Livewire stores temporary files in a non-public directory; therefore, typically there's no simple way to expose a temporary, public URL to your users for image previewing.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-22","text":"or image previewing.\n\nHowever, Livewire solves this issue by providing a temporary, signed URL that pretends to be the uploaded image so your page can show an image preview to your users.\n\nThis URL is protected against showing files in directories above the temporary directory. And, because it's signed, users can't abuse this URL to preview other files on your system.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-23","text":"iles on your system.\n\n> [!tip] S3 temporary signed URLs\n> If you've configured Livewire to use S3 for temporary file storage, calling `->temporaryUrl()` will generate a temporary, signed URL to S3 directly so that image previews aren't loaded from your Laravel application server.\n\n## Testing file uploads\n\nYou can use Laravel's existing file upload testing helpers to test file uploads.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-24","text":"o test file uploads.\n\nBelow is a complete example of testing the `UploadPhoto` component with Livewire:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse Illuminate\\Http\\UploadedFile;\nuse Illuminate\\Support\\Facades\\Storage;\nuse App\\Livewire\\UploadPhoto;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-25","text":"\nuse Tests\\TestCase;\n\nclass UploadPhotoTest extends TestCase\n{\n    public function test_can_upload_photo()\n    {\n        Storage::fake('avatars');\n\n        $file = UploadedFile::fake()->image('avatar.png');\n\n        Livewire::test(UploadPhoto::class)\n            ->set('photo', $file)\n            ->call('upload', 'uploaded-avatar.png');","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-26","text":"loaded-avatar.png');\n\n        Storage::disk('avatars')->assertExists('uploaded-avatar.png');\n    }\n}\n```\n\nBelow is an example of the `UploadPhoto` component required to make the previous test pass:\n\n```php\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\n\nclass UploadPhoto extends Component\n{\n    use WithFileUploads;\n\n    public $photo;","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-27","text":"\n\n    public $photo;\n\n    public function upload($name)\n    {\n        $this->photo->storeAs('/', $name, disk: 'avatars');\n    }\n\n    // ...\n}\n```\n\nFor more information on testing file uploads, please consult [Laravel's file upload testing documentation](https://laravel.com/docs/http-tests#testing-file-uploads).\n\n## Uploading directly to Amazon S3","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-28","text":"irectly to Amazon S3\n\nAs previously discussed, Livewire stores all file uploads in a temporary directory until the developer permanently stores the file.\n\nBy default, Livewire uses the default filesystem disk configuration (usually `local`) and stores the files within a `livewire-tmp/` directory.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-29","text":"ire-tmp/` directory.\n\nConsequently, file uploads are always utilizing your application server, even if you choose to store the uploaded files in an S3 bucket later.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-30","text":" an S3 bucket later.\n\nIf you wish to bypass your application server and instead store Livewire's temporary uploads in an S3 bucket, you can configure that behavior in your application's `config/livewire.php` configuration file. First, set `livewire.temporary_file_upload.disk` to `s3` (or another custom disk that uses the `s3` driver):","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-31","text":"es the `s3` driver):\n\n```php\nreturn [\n    // ...\n    'temporary_file_upload' => [\n        'disk' => 's3',\n        // ...\n    ],\n];\n```\n\nNow, when a user uploads a file, the file will never actually be stored on your server. Instead, it will be uploaded directly to your S3 bucket within the `livewire-tmp/` sub-directory.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-32","text":"tmp/` sub-directory.\n\n> [!info] Publishing Livewire's configuration file\n> Before customizing the file upload disk, you must first publish Livewire's configuration file to your application's `/config` directory by running the following command:\n> ```shell\n> php artisan livewire:publish --config\n> ```\n\n### Configuring automatic file cleanup","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-33","text":"tomatic file cleanup\n\nLivewire's temporary upload directory will fill up with files quickly; therefore, it's essential to configure S3 to clean up files older than 24 hours.\n\nTo configure this behavior, run the following Artisan command from the environment that is utilizing an S3 bucket for file uploads:\n\n```shell\nphp artisan livewire:configure-s3-upload-cleanup\n```","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-34","text":"3-upload-cleanup\n```\n\nNow, any temporary files older than 24 hours will be cleaned up by S3 automatically.\n\n> [!info]\n> If you are not using S3 for file storage, Livewire will handle file cleanup automatically and there is no need to run the command above.\n\n## Loading indicators","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-35","text":"# Loading indicators\n\nAlthough `wire:model` for file uploads works differently than other `wire:model` input types under the hood, the interface for showing loading indicators remains the same.\n\nYou can display a loading indicator scoped to the file upload like so:\n\n```blade\n<input type=\"file\" wire:model=\"photo\">\n\n<div wire:loading wire:target=\"photo\">Uploading...</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-36","text":"loading...</div>\n```\n\nNow, while the file is uploading, the \"Uploading...\" message will be shown and then hidden when the upload is finished.\n\nFor more information on loading states, check out our comprehensive [loading state documentation](/docs/wire-loading).\n\n## Progress indicators","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-37","text":" Progress indicators\n\nEvery Livewire file upload operation dispatches JavaScript events on the corresponding `<input>` element, allowing custom JavaScript to intercept the events:","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-38","text":"ntercept the events:\n\nEvent | Description\n--- | ---\n`livewire-upload-start` | Dispatched when the upload starts\n`livewire-upload-finish` | Dispatched if the upload is successfully finished\n`livewire-upload-cancel` | Dispatched if the upload was cancelled prematurely\n`livewire-upload-error` | Dispatched if the upload fails","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-39","text":" if the upload fails\n`livewire-upload-progress` | An event containing the upload progress percentage as the upload progresses","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-40","text":"he upload progresses\n\nBelow is an example of wrapping a Livewire file upload in an Alpine component to display an upload progress bar:","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-41","text":"upload progress bar:\n\n```blade\n<form wire:submit=\"save\">\n    <div\n        x-data=\"{ uploading: false, progress: 0 }\"\n        x-on:livewire-upload-start=\"uploading = true\"\n        x-on:livewire-upload-finish=\"uploading = false\"\n        x-on:livewire-upload-cancel=\"uploading = false\"\n        x-on:livewire-upload-error=\"uploading = false\"","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-42","text":"=\"uploading = false\"\n        x-on:livewire-upload-progress=\"progress = $event.detail.progress\"\n    >\n        <!-- File Input -->\n        <input type=\"file\" wire:model=\"photo\">","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-43","text":" wire:model=\"photo\">\n\n        <!-- Progress Bar -->\n        <div x-show=\"uploading\">\n            <progress max=\"100\" x-bind:value=\"progress\"></progress>\n        </div>\n    </div>\n\n    <!-- ... -->\n</form>\n```\n\n## Cancelling an upload\n\nIf an upload is taking a long time, a user may want to cancel it. You can provide this functionality with Livewire's `$cancelUpload()` function in JavaScript.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-44","text":"ction in JavaScript.\n\nHere's an example of creating a \"Cancel Upload\" button in a Livewire component using `wire:click` to handle the click event:\n\n```blade\n<form wire:submit=\"save\">\n    <!-- File Input -->\n    <input type=\"file\" wire:model=\"photo\">\n\n    <!-- Cancel upload button -->\n    <button type=\"button\" wire:click=\"$cancelUpload('photo')\">Cancel Upload</button>\n\n    <!-- ... -->\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-45","text":" ... -->\n</form>\n```\n\nWhen \"Cancel upload\" is pressed, the file upload will request will be aborted and the file input will be cleared. The user can now attempt another upload with a different file.\n\nAlternatively, you can call `cancelUpload(...)` from Alpine like so:\n\n```blade\n<button type=\"button\" x-on:click=\"$wire.cancelUpload('photo')\">Cancel Upload</button>\n```\n\n## JavaScript upload API","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-46","text":"avaScript upload API\n\nIntegrating with third-party file-uploading libraries often requires more control than a simple `<input type=\"file\" wire:model=\"...\">` element.\n\nFor these scenarios, Livewire exposes dedicated JavaScript functions.","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-47","text":"avaScript functions.\n\nThese functions exist on a JavaScript component object, which can be accessed using Livewire's convenient `$wire` object from within your Livewire component's template:\n\n```blade\n@script\n<script>\n    let file = $wire.el.querySelector('input[type=\"file\"]').files[0]","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-48","text":"e=\"file\"]').files[0]\n\n    // Upload a file...\n    $wire.upload('photo', file, (uploadedFilename) => {\n        // Success callback...\n    }, () => {\n        // Error callback...\n    }, (event) => {\n        // Progress callback...\n        // event.detail.progress contains a number between 1 and 100 as the upload progresses\n    }, () => {\n        // Cancelled callback...\n    })","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-49","text":"d callback...\n    })\n\n    // Upload multiple files...\n    $wire.uploadMultiple('photos', [file], successCallback, errorCallback, progressCallback, cancelledCallback)\n\n    // Remove single file from multiple uploaded files...\n    $wire.removeUpload('photos', uploadedFilename, successCallback)\n\n    // Cancel an upload...\n    $wire.cancelUpload('photos')\n</script>\n@endscript\n```\n\n## Configuration","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-50","text":"``\n\n## Configuration\n\nBecause Livewire stores all file uploads temporarily before the developer can validate or store them, it assumes some default handling behavior for all file uploads.\n\n### Global validation\n\nBy default, Livewire will validate all temporary file uploads with the following rules: `file|max:12288` (Must be a file less than 12MB).","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-51","text":"ile less than 12MB).\n\nIf you wish to customize these rules, you can do so inside your application's `config/livewire.php` file:\n\n```php\n'temporary_file_upload' => [\n    // ...\n    'rules' => 'file|mimes:png,jpg,pdf|max:102400', // (100MB max, and only accept PNGs, JPEGs, and PDFs)\n],\n```\n\n### Global middleware","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-52","text":"## Global middleware\n\nThe temporary file upload endpoint is assigned a throttling middleware by default. You can customize exactly what middleware this endpoint uses via the following configuration option:\n\n```php\n'temporary_file_upload' => [\n    // ...\n    'middleware' => 'throttle:5,1', // Only allow 5 uploads per user per minute\n],\n```\n\n### Temporary upload directory","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"415790215ce403fc7e778bf035454013-53","text":"ary upload directory\n\nTemporary files are uploaded to the specified disk's `livewire-tmp/` directory. You can customize this directory via the following configuration option:\n\n```php\n'temporary_file_upload' => [\n    // ...\n    'directory' => 'tmp',\n],\n```\n","source":"/Users/fyyx/Documents/livewire/docs/uploads.md"}
{"id":"fa371071971c0fea5bdefd1c8ea2df6a-0","text":"39\"\n\n","source":"/Users/fyyx/Documents/livewire/docs/Untitled 2.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-0","text":"\n## Using JavaScript in Livewire components\n\nLivewire and Alpine provide plenty of utilities for building dynamic components directly in your HTML, however, there are times when it's helpful to break out of the HTML and execute plain JavaScript for your component. Livewire's `@script` and `@assets` directive allow you to do this in a predictable, maintainable way.\n\n### Executing scripts","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-1","text":"## Executing scripts\n\nTo execute bespoke JavaScript in your Livewire component, simply wrap a `<script>` element with `@script` and `@endscript`. This will tell Livewire to handle the execution of this JavaScript.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-2","text":" of this JavaScript.\n\nBecause scripts inside `@script` are handled by Livewire, they are executed at the perfect time after the page has loaded, but before the Livewire component has rendered. This means you no longer need to wrap your scripts in `document.addEventListener('...')` to load them properly.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-3","text":" load them properly.\n\nThis also means that lazily or conditionally loaded Livewire components are still able to execute JavaScript after the page has initialized.\n\n```blade\n<div>\n    ...\n</div>\n\n@script\n<script>\n    // This Javascript will get executed every time this component is loaded onto the page...\n</script>\n@endscript\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-4","text":"ript>\n@endscript\n```\n\nHere's a more full example where you can do something like register a JavaScript action that is used in your Livewire component.\n\n```blade\n<div>\n    <button wire:click=\"$js.increment\">+</button>\n</div>\n\n@script\n<script>\n    $js('increment', () => {\n        console.log('increment')\n    })\n</script>\n@endscript\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-5","text":"ript>\n@endscript\n```\n\nTo learn more about JavaScript actions, [visit the actions documentation](/docs/actions#javascript-actions).\n\n### Using `$wire` from scripts\n\nAnother helpful feature of using `@script` for your JavaScript is that you automatically have access to your Livewire component's `$wire` object.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-6","text":"nt's `$wire` object.\n\nHere's an example of using a simple `setInterval` to refresh the component every 2 seconds (You could easily do this with [`wire:poll`](/docs/wire-poll), but it's a simple way to demonstrate the point):\n\nYou can learn more about `$wire` on the [`$wire` documentation](#the-wire-object).","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-7","text":"](#the-wire-object).\n\n```blade\n@script\n<script>\n    setInterval(() => {\n        $wire.$refresh()\n    }, 2000)\n</script>\n@endscript\n```\n\n### Evaluating one-off JavaScript expressions\n\nIn addition to designating entire methods to be evaluated in JavaScript, you can use the `js()` method to evaluate smaller, individual expressions on the backend.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-8","text":"ions on the backend.\n\nThis is generally useful for performing some kind of client-side follow-up after a server-side action is performed.\n\nFor example, here is an example of a `CreatePost` component that triggers a client-side alert dialog after the post is saved to the database:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-9","text":" Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public $title = '';\n\n    public function save()\n    {\n        // ...\n\n        $this->js(\"alert('Post saved!')\"); // [tl! highlight:6]\n    }\n}\n```\n\nThe JavaScript expression `alert('Post saved!')` will now be executed on the client after the post has been saved to the database on the server.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-10","text":"abase on the server.\n\nYou can access the current component's `$wire` object inside the expression.\n\n### Loading assets\n\nThe `@script` directive is useful for executing a bit of JavaScript every time a Livewire component loads, however, there are times you might want to load entire script and style assets on the page along with the component.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-11","text":" with the component.\n\nHere is an example of using `@assets` to load a date picker library called [Pikaday](https://github.com/Pikaday/Pikaday) and initialize it inside your component using `@script`:\n\n```blade\n<div>\n    <input type=\"text\" data-picker>\n</div>","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-12","text":" data-picker>\n</div>\n\n@assets\n<script src=\"https://cdn.jsdelivr.net/npm/pikaday/pikaday.js\" defer></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css\">\n@endassets\n\n@script\n<script>\n    new Pikaday({ field: $wire.$el.querySelector('[data-picker]') });\n</script>\n@endscript\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-13","text":"ript>\n@endscript\n```\n\nWhen this component loads, Livewire will make sure any `@assets` are loaded on that page before evaluating `@script`s. In addition, it will ensure the provided `@assets` are only loaded once per page no matter how many instances of this component there are, unlike `@script`, which will evaluate for every component instance on the page.\n\n## Global Livewire events","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-14","text":"obal Livewire events\n\nLivewire dispatches two helpful browser events for you to register any custom extension points from outside scripts:\n\n```html\n<script>\n    document.addEventListener('livewire:init', () => {\n        // Runs after Livewire is loaded but before it's initialized\n        // on the page...\n    })","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-15","text":"n the page...\n    })\n\n    document.addEventListener('livewire:initialized', () => {\n        // Runs immediately after Livewire has finished initializing\n        // on the page...\n    })\n</script>\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-16","text":"    })\n</script>\n```\n\n> [!info]\n> It is often beneficial to register any [custom directives](#registering-custom-directives) or [lifecycle hooks](#javascript-hooks) inside of `livewire:init` so that they are available before Livewire begins initializing on the page.\n\n## The `Livewire` global object","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-17","text":"ewire` global object\n\nLivewire's global object is the best starting point for interacting with Livewire from external scripts.\n\nYou can access the global `Livewire` JavaScript object on `window` from anywhere inside your client-side code.\n\nIt is often helpful to use `window.Livewire` inside a `livewire:init` event listener\n\n### Accessing components","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-18","text":"Accessing components\n\nYou can use the following methods to access specific Livewire components loaded on the current page:\n\n```js\n// Retrieve the $wire object for the first component on the page...\nlet component = Livewire.first()\n\n// Retrieve a given component's `$wire` object by its ID...\nlet component = Livewire.find(id)","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-19","text":" = Livewire.find(id)\n\n// Retrieve an array of component `$wire` objects by name...\nlet components = Livewire.getByName(name)\n\n// Retrieve $wire objects for every component on the page...\nlet components = Livewire.all()\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-20","text":"= Livewire.all()\n```\n\n> [!info]\n> Each of these methods returns a `$wire` object representing the component's state in Livewire.\n> <br><br>\n> You can learn more about these objects in [the `$wire` documentation](#the-wire-object).\n\n### Interacting with events","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-21","text":"eracting with events\n\nIn addition to dispatching and listening for events from individual components in PHP, the global `Livewire` object allows you to interact with [Livewire's event system](/docs/events) from anywhere in your application:\n\n```js\n// Dispatch an event to any Livewire components listening...\nLivewire.dispatch('post-created', { postId: 2 })","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-22","text":"ted', { postId: 2 })\n\n// Dispatch an event to a given Livewire component by name...\nLivewire.dispatchTo('dashboard', 'post-created', { postId: 2 })\n\n// Listen for events dispatched from Livewire components...\nLivewire.on('post-created', ({ postId }) => {\n    // ...\n})\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-23","text":" {\n    // ...\n})\n```\n","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-24","text":"{\n    // ...\n})\n```\n\nIn certain scenarios, you might need to unregister global Livewire events. For instance, when working with Alpine components and `wire:navigate`, multiple listeners may be registered as `init` is called when navigating between pages. To address this, utilize the `destroy` function, automatically invoked by Alpine","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-25","text":"ly invoked by Alpine. Loop through all your listeners within this function to unregister them and prevent any unwanted accumulation.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-26","text":"wanted accumulation.\n\n```js\nAlpine.data('MyComponent', () => ({\n    listeners: [],\n    init() {\n        this.listeners.push(\n            Livewire.on('post-created', (options) => {\n                // Do something...\n            })\n        );\n    },\n    destroy() {\n        this.listeners.forEach((listener) => {\n            listener();\n        });\n    }\n}));\n```\n### Using lifecycle hooks","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-27","text":"sing lifecycle hooks\n\nLivewire allows you to hook into various parts of its global lifecycle using `Livewire.hook()`:\n\n```js\n// Register a callback to execute on a given internal Livewire hook...\nLivewire.hook('component.init', ({ component, cleanup }) => {\n    // ...\n})\n```\n\nMore information about Livewire's JavaScript hooks can be [found below](#javascript-hooks).","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-28","text":"(#javascript-hooks).\n\n### Registering custom directives\n\nLivewire allows you to register custom directives using `Livewire.directive()`.\n\nBelow is an example of a custom `wire:confirm` directive that uses JavaScript's `confirm()` dialog to confirm or cancel an action before it is sent to the server:\n\n```html\n<button wire:confirm=\"Are you sure?\" wire:click=\"delete\">Delete post</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-29","text":"te post</button>\n```\n\nHere is the implementation of `wire:confirm` using `Livewire.directive()`:\n\n```js\nLivewire.directive('confirm', ({ el, directive, component, cleanup }) => {\n    let content =  directive.expression","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-30","text":"directive.expression\n\n    // The \"directive\" object gives you access to the parsed directive.\n    // For example, here are its values for: wire:click.prevent=\"deletePost(1)\"\n    //\n    // directive.raw = wire:click.prevent\n    // directive.value = \"click\"\n    // directive.modifiers = ['prevent']\n    // directive.expression = \"deletePost(1)\"","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-31","text":"on = \"deletePost(1)\"\n\n    let onClick = e => {\n        if (! confirm(content)) {\n            e.preventDefault()\n            e.stopImmediatePropagation()\n        }\n    }\n\n    el.addEventListener('click', onClick, { capture: true })","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-32","text":", { capture: true })\n\n    // Register any cleanup code inside `cleanup()` in the case\n    // where a Livewire component is removed from the DOM while\n    // the page is still active.\n    cleanup(() => {\n        el.removeEventListener('click', onClick)\n    })\n})\n```\n\n## Object schemas","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-33","text":"`\n\n## Object schemas\n\nWhen extending Livewire's JavaScript system, it's important to understand the different objects you might encounter.\n\nHere is an exhaustive reference of each of Livewire's relevant internal properties.\n\nAs a reminder, the average Livewire user may never interact with these. Most of these objects are available for Livewire's internal system or advanced users.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-34","text":"m or advanced users.\n\n### The `$wire` object\n\nGiven the following generic `Counter` component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass Counter extends Component\n{\n    public $count = 1;\n\n    public function increment()\n    {\n        $this->count++;\n    }\n\n    public function render()\n    {\n        return view('livewire.counter');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-35","text":"unter');\n    }\n}\n```\n\nLivewire exposes a JavaScript representation of the server-side component in the form of an object that is commonly referred to as `$wire`:\n\n```js\nlet $wire = {\n    // All component public properties are directly accessible on $wire...\n    count: 0,\n\n    // All public methods are exposed and callable on $wire...\n    increment() { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-36","text":"increment() { ... },\n\n    // Access the `$wire` object of the parent component if one exists...\n    $parent,\n\n    // Access the root DOM element of the Livewire component...\n    $el,\n\n    // Access the ID of the current Livewire component...\n    $id,\n\n    // Get the value of a property by name...\n    // Usage: $wire.$get('count')\n    $get(name) { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-37","text":" $get(name) { ... },\n\n    // Set a property on the component by name...\n    // Usage: $wire.$set('count', 5)\n    $set(name, value, live = true) { ... },\n\n    // Toggle the value of a boolean property...\n    $toggle(name, live = true) { ... },\n\n    // Call the method...\n    // Usage: $wire.$call('increment')\n    $call(method, ...params) { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-38","text":" ...params) { ... },\n\n    // Define a JavaScript action...\n    // Usage: $wire.$js('increment', () => { ... })\n    $js(name, callback) { ... },\n\n    // Entangle the value of a Livewire property with a different,\n    // arbitrary, Alpine property...\n    // Usage: <div x-data=\"{ count: $wire.$entangle('count') }\">\n    $entangle(name, live = false) { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-39","text":"ve = false) { ... },\n\n    // Watch the value of a property for changes...\n    // Usage: Alpine.$watch('count', (value, old) => { ... })\n    $watch(name, callback) { ... },\n\n    // Refresh a component by sending a commit to the server\n    // to re-render the HTML and swap it into the page...\n    $refresh() { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-40","text":" $refresh() { ... },\n\n    // Identical to the above `$refresh`. Just a more technical name...\n    $commit() { ... },\n\n    // Listen for a an event dispatched from this component or its children...\n    // Usage: $wire.$on('post-created', () => { ... })\n    $on(event, callback) { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-41","text":", callback) { ... },\n\n    // Listen for a lifecycle hook triggered from this component or the request...\n    // Usage: $wire.$hook('commit', () => { ... })\n    $hook(name, callback) { ... },\n\n    // Dispatch an event from this component...\n    // Usage: $wire.$dispatch('post-created', { postId: 2 })\n    $dispatch(event, params = {}) { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-42","text":"arams = {}) { ... },\n\n    // Dispatch an event onto another component...\n    // Usage: $wire.$dispatchTo('dashboard', 'post-created', { postId: 2 })\n    $dispatchTo(otherComponentName, event, params = {}) { ... },\n\n    // Dispatch an event onto this component and no others...\n    $dispatchSelf(event, params = {}) { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-43","text":"arams = {}) { ... },\n\n    // A JS API to upload a file directly to component\n    // rather than through `wire:model`...\n    $upload(\n        name, // The property name\n        file, // The File JavaScript object\n        finish = () => { ... }, // Runs when the upload is finished...\n        error = () => { ... }, // Runs if an error is triggered mid-upload...","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-44","text":"ggered mid-upload...\n        progress = (event) => { // Runs as the upload progresses...\n            event.detail.progress // An integer from 1-100...\n        },\n    ) { ... },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-45","text":"   },\n    ) { ... },\n\n    // API to upload multiple files at the same time...\n    $uploadMultiple(name, files, finish, error, progress) { },\n\n    // Remove an upload after it's been temporarily uploaded but not saved...\n    $removeUpload(name, tmpFilename, finish, error) { ... },\n\n    // Retrieve the underlying \"component\" object...\n    __instance() { ... },\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-46","text":"nce() { ... },\n}\n```\n\nYou can learn more about `$wire` in [Livewire's documentation on accessing properties in JavaScript](/docs/properties#accessing-properties-from-javascript).\n\n### The `snapshot` object","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-47","text":"he `snapshot` object\n\nBetween each network request, Livewire serializes the PHP component into an object that can be consumed in JavaScript. This snapshot is used to unserialize the component back into a PHP object and therefore has mechanisms built in to prevent tampering:\n\n```js\nlet snapshot = {\n    // The serialized state of the component (public properties)...\n    data: { count: 0 },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-48","text":" data: { count: 0 },\n\n    // Long-standing information about the component...\n    memo: {\n        // The component's unique ID...\n        id: '0qCY3ri9pzSSMIXPGg8F',\n\n        // The component's name. Ex. <livewire:[name] />\n        name: 'counter',","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-49","text":"    name: 'counter',\n\n        // The URI, method, and locale of the web page that the\n        // component was originally loaded on. This is used\n        // to re-apply any middleware from the original request\n        // to subsequent component update requests (commits)...\n        path: '/',\n        method: 'GET',\n        locale: 'en',","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-50","text":"       locale: 'en',\n\n        // A list of any nested \"child\" components. Keyed by\n        // internal template ID with the component ID as the values...\n        children: [],\n\n        // Weather or not this component was \"lazy loaded\"...\n        lazyLoaded: false,\n\n        // A list of any validation errors thrown during the\n        // last request...\n        errors: [],\n    },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-51","text":"  errors: [],\n    },\n\n    // A securely encrypted hash of this snapshot. This way,\n    // if a malicious user tampers with the snapshot with\n    // the goal of accessing un-owned resources on the server,\n    // the checksum validation will fail and an error will\n    // be thrown...\n    checksum: '1bc274eea17a434e33d26bcaba4a247a4a7768bd286456a83ea6e9be2d18c1e7',\n}\n```\n\n### The `component` object","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-52","text":"e `component` object\n\nEvery component on a page has a corresponding component object behind the scenes keeping track of its state and exposing its underlying functionality. This is one layer deeper than `$wire`. It is only meant for advanced usage.\n\nHere's an actual component object for the above `Counter` component with descriptions of relevant properties in JS comments:","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-53","text":"ties in JS comments:\n\n```js\nlet component = {\n    // The root HTML element of the component...\n    el: HTMLElement,\n\n    // The unique ID of the component...\n    id: '0qCY3ri9pzSSMIXPGg8F',\n\n    // The component's \"name\" (<livewire:[name] />)...\n    name: 'counter',","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-54","text":"    name: 'counter',\n\n    // The latest \"effects\" object. Effects are \"side-effects\" from server\n    // round-trips. These include redirects, file downloads, etc...\n    effects: {},\n\n    // The component's last-known server-side state...\n    canonical: { count: 0 },\n\n    // The component's mutable data object representing its\n    // live client-side state...\n    ephemeral: { count: 0 },","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-55","text":"meral: { count: 0 },\n\n    // A reactive version of `this.ephemeral`. Changes to\n    // this object will be picked up by AlpineJS expressions...\n    reactive: Proxy,\n\n    // A Proxy object that is typically used inside Alpine\n    // expressions as `$wire`. This is meant to provide a\n    // friendly JS object interface for Livewire components...\n    $wire: Proxy,","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-56","text":"..\n    $wire: Proxy,\n\n    // A list of any nested \"child\" components. Keyed by\n    // internal template ID with the component ID as the values...\n    children: [],\n\n    // The last-known \"snapshot\" representation of this component.\n    // Snapshots are taken from the server-side component and used\n    // to re-create the PHP object on the backend...\n    snapshot: {...},","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-57","text":"    snapshot: {...},\n\n    // The un-parsed version of the above snapshot. This is used to send back to the\n    // server on the next roundtrip because JS parsing messes with PHP encoding\n    // which often results in checksum mis-matches.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-58","text":"hecksum mis-matches.\n    snapshotEncoded: '{\"data\":{\"count\":0},\"memo\":{\"id\":\"0qCY3ri9pzSSMIXPGg8F\",\"name\":\"counter\",\"path\":\"\\/\",\"method\":\"GET\",\"children\":[],\"lazyLoaded\":true,\"errors\":[],\"locale\":\"en\"},\"checksum\":\"1bc274eea17a434e33d26bcaba4a247a4a7768bd286456a83ea6e9be2d18c1e7\"}',\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-59","text":"be2d18c1e7\"}',\n}\n```\n\n### The `commit` payload\n\nWhen an action is performed on a Livewire component in the browser, a network request is triggered. That network request contains one or many components and various instructions for the server. Internally, these component network payloads are called \"commits\".","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-60","text":"re called \"commits\".\n\nThe term \"commit\" was chosen as a helpful way to think about Livewire's relationship between frontend and backend. A component is rendered and manipulated on the frontend until an action is performed that requires it to \"commit\" its state and updates to the backend.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-61","text":"ates to the backend.\n\nYou will recognize this schema from the payload in the network tab of your browser's DevTools, or [Livewire's JavaScript hooks](#javascript-hooks):\n\n```js\nlet commit = {\n    // Snapshot object...\n    snapshot: { ... },\n\n    // A key-value pair list of properties\n    // to update on the server...\n    updates: {},","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-62","text":"...\n    updates: {},\n\n    // An array of methods (with parameters) to call server-side...\n    calls: [\n        { method: 'increment', params: [] },\n    ],\n}\n```\n\n## JavaScript hooks\n\nFor advanced users, Livewire exposes its internal client-side \"hook\" system. You can use the following hooks to extend Livewire's functionality or gain more information about your Livewire application.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-63","text":"ivewire application.\n\n### Component initialization\n\nEvery time a new component is discovered by Livewire — whether on the initial page load or later on — the `component.init` event is triggered. You can hook into `component.init` to intercept or initialize anything related to the new component:\n\n```js\nLivewire.hook('component.init', ({ component, cleanup }) => {\n    //\n})\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-64","text":") => {\n    //\n})\n```\n\nFor more information, please consult the [documentation on the component object](#the-component-object).\n\n### DOM element initialization\n\nIn addition to triggering an event when new components are initialized, Livewire triggers an event for each DOM element within a given Livewire component.\n\nThis can be used to provide custom Livewire HTML attributes within your application:","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-65","text":"in your application:\n\n```js\nLivewire.hook('element.init', ({ component, el }) => {\n    //\n})\n```\n\n### DOM Morph hooks\n\nDuring the DOM morphing phase—which occurs after Livewire completes a network roundtrip—Livewire triggers a series of events for every element that is mutated.\n\n```js\nLivewire.hook('morph.updating',  ({ el, component, toEl, skip, childrenOnly }) => {\n\t//\n})","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-66","text":"nOnly }) => {\n\t//\n})\n\nLivewire.hook('morph.updated', ({ el, component }) => {\n\t//\n})\n\nLivewire.hook('morph.removing', ({ el, component, skip }) => {\n\t//\n})\n\nLivewire.hook('morph.removed', ({ el, component }) => {\n\t//\n})\n\nLivewire.hook('morph.adding',  ({ el, component }) => {\n\t//\n})\n\nLivewire.hook('morph.added',  ({ el }) => {\n\t//\n})\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-67","text":"l }) => {\n\t//\n})\n```\n\nIn addition to the events fired per element, a `morph` and `morphed` event is fired for each Livewire component:\n\n```js\nLivewire.hook('morph',  ({ el, component }) => {\n\t// Runs just before the child elements in `component` are morphed\n})\n\nLivewire.hook('morphed',  ({ el, component }) => {\n    // Runs after all child elements in `component` are morphed\n})\n```","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-68","text":"` are morphed\n})\n```\n\n### Commit hooks\n\nBecause Livewire requests contain multiple components, _request_ is too broad of a term to refer to an individual component's request and response payload. Instead, internally, Livewire refers to component updates as _commits_ — in reference to _committing_ component state to the server.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-69","text":"state to the server.\n\nThese hooks expose `commit` objects. You can learn more about their schema by reading [the commit object documentation](#the-commit-payload).\n\n#### Preparing commits\n\nThe `commit.prepare` hook will be triggered immediately before a request is sent to the server. This gives you a chance to add any last minute updates or actions to the outgoing request:","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-70","text":"he outgoing request:\n\n```js\nLivewire.hook('commit.prepare', ({ component }) => {\n    // Runs before commit payloads are collected and sent to the server...\n})\n```\n\n#### Intercepting commits\n\nEvery time a Livewire component is sent to the server, a _commit_ is made. To hook into the lifecycle and contents of an individual commit, Livewire exposes a `commit` hook.","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-71","text":"ses a `commit` hook.\n\nThis hook is extremely powerful as it provides methods for hooking into both the request and response of a Livewire commit:\n\n```js\nLivewire.hook('commit', ({ component, commit, respond, succeed, fail }) => {\n    // Runs immediately before a commit's payload is sent to the server...","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-72","text":"ent to the server...\n\n    respond(() => {\n        // Runs after a response is received but before it's processed...\n    })\n\n    succeed(({ snapshot, effects }) => {\n        // Runs after a successful response is received and processed\n        // with a new snapshot and list of effects...\n    })\n\n    fail(() => {\n        // Runs if some part of the request failed...\n    })\n})\n```\n\n## Request hooks","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-73","text":"``\n\n## Request hooks\n\nIf you would like to instead hook into the entire HTTP request going and returning from the server, you can do so using the `request` hook:\n\n```js\nLivewire.hook('request', ({ url, options, payload, respond, succeed, fail }) => {\n    // Runs after commit payloads are compiled, but before a network request is sent...","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-74","text":"k request is sent...\n\n    respond(({ status, response }) => {\n        // Runs when the response is received...\n        // \"response\" is the raw HTTP response object\n        // before await response.text() is run...\n    })\n\n    succeed(({ status, json }) => {\n        // Runs when the response is received...\n        // \"json\" is the JSON response object...\n    })","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-75","text":"nse object...\n    })\n\n    fail(({ status, content, preventDefault }) => {\n        // Runs when the response has an error status code...\n        // \"preventDefault\" allows you to disable Livewire's\n        // default error handling...\n        // \"content\" is the raw response content...\n    })\n})\n```\n\n### Customizing page expiration behavior","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-76","text":" expiration behavior\n\nIf the default page expired dialog isn't suitable for your application, you can implement a custom solution using the `request` hook:","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-77","text":" the `request` hook:\n\n```html\n<script>\n    document.addEventListener('livewire:init', () => {\n        Livewire.hook('request', ({ fail }) => {\n            fail(({ status, preventDefault }) => {\n                if (status === 419) {\n                    confirm('Your custom page expiration behavior...')","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"c4bed0a373893b7dd4840963822e5fa6-78","text":"ration behavior...')\n\n                    preventDefault()\n                }\n            })\n        })\n    })\n</script>\n```\n\nWith the above code in your application, users will receive a custom dialog when their session has expired.\n","source":"/Users/fyyx/Documents/livewire/docs/javascript.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-0","text":"\n## Creating your first test\n\nBy appending the `--test` flag to the `make:livewire` command, you can generate a test file along with a component:\n\n```shell\nphp artisan make:livewire create-post --test\n```\n\nIn addition to generating the component files themselves, the above command will generate the following test file `tests/Feature/Livewire/CreatePostTest.php`:","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-1","text":"CreatePostTest.php`:\n\nIf you would like to create a [Pest PHP](https://pestphp.com/) test, you may provide the `--pest` option to the make:livewire command:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-2","text":"\nuse Tests\\TestCase;\n\nclass CreatePostTest extends TestCase\n{\n    public function test_renders_successfully()\n    {\n        Livewire::test(CreatePost::class)\n            ->assertStatus(200);\n    }\n}\n```\n\nOf course, you can always create these files by hand or even use Livewire's testing utilities inside any other existing PHPUnit test in your Laravel application.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-3","text":"Laravel application.\n\nBefore reading further, you may wish to familiarize yourself with [Laravel's own built-in testing features](https://laravel.com/docs/testing).\n\n## Testing a page contains a component\n\nThe simplest Livewire test you can write is asserting that a given endpoint in your application includes and successfully renders a given Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-4","text":" Livewire component.\n\nLivewire provides an `assertSeeLivewire()` method that can be used from any Laravel test:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\CreatePost;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-5","text":"\nuse Tests\\TestCase;\n\nclass CreatePostTest extends TestCase\n{\n    public function test_component_exists_on_the_page()\n    {\n        $this->get('/posts/create')\n            ->assertSeeLivewire(CreatePost::class);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-6","text":":class);\n    }\n}\n```\n\n> [!tip] These are called smoke tests","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-7","text":"e called smoke tests\n> Smoke tests are broad tests that ensure there are no catastrophic problems in your application","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-8","text":" in your application. Although it may seem like a test that isn't worth writing, pound for pound, these are some of the most valuable tests you can write as they require very little maintenance and provide you a base level of confidence that your application will render successfully with no major errors.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-9","text":"ith no major errors.\n\n## Testing views\n\nLivewire provides a simple yet powerful utility for asserting the existence of text in the component's rendered output: `assertSee()`.\n\nBelow is an example of using `assertSee()` to ensure that all posts in the database are displayed on the page:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-10","text":"ts\\Feature\\Livewire;\n\nuse App\\Livewire\\ShowPosts;\nuse Livewire\\Livewire;\nuse App\\Models\\Post;\nuse Tests\\TestCase;\n\nclass ShowPostsTest extends TestCase\n{\n    public function test_displays_posts()\n    {\n        Post::factory()->make(['title' => 'On bathing well']);\n        Post::factory()->make(['title' => 'There\\'s no time like bathtime']);","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-11","text":"me like bathtime']);\n\n        Livewire::test(ShowPosts::class)\n            ->assertSee('On bathing well')\n            ->assertSee('There\\'s no time like bathtime');\n    }\n}\n```\n\n### Asserting data from the view\n\nIn addition to asserting the output of a rendered view, sometimes it's helpful to test the data being passed into the view.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-12","text":"assed into the view.\n\nHere's the same test as above, but testing the view data rather than the rendered output:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\ShowPosts;\nuse Livewire\\Livewire;\nuse App\\Models\\Post;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-13","text":"\nuse Tests\\TestCase;\n\nclass ShowPostsTest extends TestCase\n{\n    public function test_displays_all_posts()\n    {\n        Post::factory()->make(['title' => 'On bathing well']);\n        Post::factory()->make(['title' => 'The bathtub is my sanctuary']);","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-14","text":" is my sanctuary']);\n\n        Livewire::test(ShowPosts::class)\n            ->assertViewHas('posts', function ($posts) {\n                return count($posts) == 2;\n            });\n    }\n}\n```\n\nAs you can see, `assertViewHas()` provides control over what assertions you want to make against the specified data.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-15","text":" the specified data.\n\nIf you would rather make a simple assertion, such as ensuring a piece of view data matches a given value, you can pass the value directly as the second argument given to the `assertViewHas()` method.\n\nFor example, assuming you have a component with a variable named `$postCount` being passed into the view, you can make assertions against its literal value like so:","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-16","text":"teral value like so:\n\n```php\n$this->assertViewHas('postCount', 3)\n```\n\n## Setting the authenticated user\n\nMost web applications require users to log in before using them. Rather than manually authenticating a fake user at the beginning of your tests, Livewire provides an `actingAs()` method.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-17","text":"`actingAs()` method.\n\nBelow is an example of a test where multiple users have posts, yet the authenticated user should only be able to see their own posts:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\ShowPosts;\nuse Livewire\\Livewire;\nuse App\\Models\\User;\nuse App\\Models\\Post;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-18","text":"\nuse Tests\\TestCase;\n\nclass ShowPostsTest extends TestCase\n{\n    public function test_user_only_sees_their_own_posts()\n    {\n        $user = User::factory()\n            ->has(Post::factory()->count(3))\n            ->create();\n\n        $stranger = User::factory()\n            ->has(Post::factory()->count(2))\n            ->create();","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-19","text":"         ->create();\n\n        Livewire::actingAs($user)\n            ->test(ShowPosts::class)\n            ->assertViewHas('posts', function ($posts) {\n                return count($posts) == 3;\n            });\n    }\n}\n```\n\n## Testing properties\n\nLivewire also provides helpful testing utilities for setting and asserting properties within your components.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-20","text":"hin your components.\n\nComponent properties are typically updated in your application when users interact with form inputs containing `wire:model`. But, because tests don't typically type into an actual browser, Livewire allows you to set properties directly using the `set()` method.\n\nBelow is an example of using `set()` to update the `$title` property of a `CreatePost` component:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-21","text":"onent:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;\n\nclass CreatePostTest extends TestCase\n{\n    public function test_can_set_title()\n    {\n        Livewire::test(CreatePost::class)\n            ->set('title', 'Confessions of a serial soaker')\n            ->assertSet('title', 'Confessions of a serial soaker');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-22","text":"oaker');\n    }\n}\n```\n\n### Initializing properties\n\nOften, Livewire components receive data being passed in from a parent component or route parameters. Because Livewire components are tested in isolation, you can manually pass data into them using the second parameter of the `Livewire::test()` method:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-23","text":"ts\\Feature\\Livewire;\n\nuse App\\Livewire\\UpdatePost;\nuse Livewire\\Livewire;\nuse App\\Models\\Post;\nuse Tests\\TestCase;\n\nclass UpdatePostTest extends TestCase\n{\n    public function test_title_field_is_populated()\n    {\n        $post = Post::factory()->make([\n            'title' => 'Top ten bath bombs',\n        ]);","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-24","text":" bombs',\n        ]);\n\n        Livewire::test(UpdatePost::class, ['post' => $post])\n            ->assertSet('title', 'Top ten bath bombs');\n    }\n}\n```\n\nThe underlying component being tested (`UpdatePost`) will receive `$post` through its `mount()` method. Let's look at the source for `UpdatePost` to paint a clearer picture of this feature:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-25","text":"espace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass UpdatePost extends Component\n{\n\tpublic Post $post;\n\n    public $title = '';\n\n\tpublic function mount(Post $post)\n\t{\n\t\t$this->post = $post;\n\n\t\t$this->title = $post->title;\n\t}\n\n\t// ...\n}\n```\n\n### Setting URL parameters","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-26","text":"tting URL parameters\n\nIf your Livewire component depends on specific query parameters in the URL of the page it's loaded on, you can use the `withQueryParams()` method to set the query parameters manually for your test.\n\nBelow is a basic `SearchPosts` component that uses [Livewire's URL feature](/docs/url) to store and track the current search query in the query string:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-27","text":"tring:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse Livewire\\Attributes\\Url;\nuse App\\Models\\Post;\n\nclass SearchPosts extends Component\n{\n    #[Url] // [tl! highlight]\n    public $search = '';\n\n    public function render()\n    {\n        return view('livewire.search-posts', [\n            'posts' => Post::search($this->search)->get(),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-28","text":"     ]);\n    }\n}\n```\n\nAs you can see, the `$search` property above uses Livewire's `#[Url]` attribute to denote that its value should be stored in the URL.\n\nBelow is an example of how you would simulate the scenario of loading this component on a page with specific query parameters in the URL:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-29","text":"ts\\Feature\\Livewire;\n\nuse App\\Livewire\\SearchPosts;\nuse Livewire\\Livewire;\nuse App\\Models\\Post;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-30","text":"\nuse Tests\\TestCase;\n\nclass SearchPostsTest extends TestCase\n{\n    public function test_can_search_posts_via_url_query_string()\n    {\n        Post::factory()->create(['title' => 'Testing the first water-proof hair dryer']);\n        Post::factory()->create(['title' => 'Rubber duckies that actually float']);","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-31","text":"t actually float']);\n\n        Livewire::withQueryParams(['search' => 'hair'])\n            ->test(SearchPosts::class)\n            ->assertSee('Testing the first')\n            ->assertDontSee('Rubber duckies');\n    }\n}\n```\n\n### Setting cookies\n\nIf your Livewire component depends on cookies, you can use the `withCookie()` or `withCookies()` methods to set the cookies manually for your test.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-32","text":"ually for your test.\n\nBelow is a basic `Cart` component that loads a discount token from a cookie on mount:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse Livewire\\Attributes\\Url;\nuse App\\Models\\Post;\n\nclass Cart extends Component\n{\n    public $discountToken;\n\n    public mount()\n    {\n        $this->discountToken = request()->cookie('discountToken');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-33","text":"Token');\n    }\n}\n```\n\nAs you can see, the `$discountToken` property above gets its value from a cookie in the request.\n\nBelow is an example of how you would simulate the scenario of loading this component on a page with cookies:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\Cart;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-34","text":"\nuse Tests\\TestCase;\n\nclass CartTest extends TestCase\n{\n    public function test_can_load_discount_token_from_a_cookie()\n    {\n        Livewire::withCookies(['discountToken' => 'CALEB2023'])\n            ->test(Cart::class)\n            ->assertSet('discountToken', 'CALEB2023');\n    }\n}\n```\n\n## Calling actions","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-35","text":"\n\n## Calling actions\n\nLivewire actions are typically called from the frontend using something like `wire:click`.\n\nBecause Livewire component tests don't use an actual browser, you can instead trigger actions in your tests using the `call()` method.\n\nBelow is an example of a `CreatePost` component using the `call()` method to trigger the `save()` action:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-36","text":"ction:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\nuse App\\Models\\Post;\nuse Tests\\TestCase;\n\nclass CreatePostTest extends TestCase\n{\n    public function test_can_create_post()\n    {\n        $this->assertEquals(0, Post::count());","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-37","text":"s(0, Post::count());\n\n        Livewire::test(CreatePost::class)\n            ->set('title', 'Wrinkly fingers? Try this one weird trick')\n            ->set('content', '...')\n            ->call('save');\n\n        $this->assertEquals(1, Post::count());\n    }\n}\n```\n\nIn the above test, we assert that calling `save()` creates a new post in the database.","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-38","text":"ost in the database.\n\nYou can also pass parameters to actions by passing additional parameters into the `call()` method:\n\n```php\n->call('deletePost', $postId);\n```\n\n### Validation\n\nTo test that a validation error has been thrown, you can use Livewire's `assertHasErrors()` method:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-39","text":"ts\\Feature\\Livewire;\n\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;\n\nclass CreatePostTest extends TestCase\n{\n    public function test_title_field_is_required()\n    {\n        Livewire::test(CreatePost::class)\n            ->set('title', '')\n            ->call('save')\n            ->assertHasErrors('title');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-40","text":"title');\n    }\n}\n```\n\nIf you want to test that a specific validation rule has failed, you can pass an array of rules:\n\n```php\n$this->assertHasErrors(['title' => ['required']]);\n```\n\nOr if you'd rather assert a validation message exists, you can do so as well:\n\n```php\n$this->assertHasErrors(['title' => ['The title field is required.']]);\n```\n\n### Authorization","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-41","text":"`\n\n### Authorization\n\nAuthorizing actions relying on untrusted input in your Livewire components is [essential](/docs/properties#authorizing-the-input). Livewire provides `assertUnauthorized()` and `assertForbidden()` methods to ensure that an authentication or authorization check has failed:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-42","text":"ts\\Feature\\Livewire;\n\nuse App\\Livewire\\UpdatePost;\nuse Livewire\\Livewire;\nuse App\\Models\\User;\nuse App\\Models\\Post;\nuse Tests\\TestCase;\n\nclass UpdatePostTest extends TestCase\n{\n    public function test_cant_update_another_users_post()\n    {\n        $user = User::factory()->create();\n        $stranger = User::factory()->create();\n\n        $post = Post::factory()->for($stranger)->create();","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-43","text":"stranger)->create();\n\n        Livewire::actingAs($user)\n            ->test(UpdatePost::class, ['post' => $post])\n            ->set('title', 'Living the lavender life')\n            ->call('save')\n            ->assertUnauthorized();","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-44","text":"ssertUnauthorized();\n\n        Livewire::actingAs($user)\n            ->test(UpdatePost::class, ['post' => $post])\n            ->set('title', 'Living the lavender life')\n            ->call('save')\n            ->assertForbidden();\n    }\n}\n```\n\nIf you prefer, you can also test for explicit status codes that an action in your component may have triggered using `assertStatus()`:","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-45","text":"ng `assertStatus()`:\n\n```php\n->assertStatus(401); // Unauthorized\n->assertStatus(403); // Forbidden\n```\n\n### Redirects\n\nYou can test that a Livewire action performed a redirect using the `assertRedirect()` method:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-46","text":"\nuse Tests\\TestCase;\n\nclass CreatePostTest extends TestCase\n{\n    public function test_redirected_to_all_posts_after_creating_a_post()\n    {\n        Livewire::test(CreatePost::class)\n            ->set('title', 'Using a loofah doesn\\'t make you aloof...ugh')\n            ->set('content', '...')\n            ->call('save')\n            ->assertRedirect('/posts');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-47","text":"posts');\n    }\n}\n```\n\nAs an added convenience, you can assert that the user was redirected to a specific page component instead of a hard-coded URL.\n\n```php\n->assertRedirect(CreatePost::class);\n```\n\n### Events\n\nTo assert that an event was dispatched from within your component, you can use the `->assertDispatched()` method:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-48","text":"ts\\Feature\\Livewire;\n\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-49","text":"\nuse Tests\\TestCase;\n\nclass CreatePostTest extends TestCase\n{\n    public function test_creating_a_post_dispatches_event()\n    {\n        Livewire::test(CreatePost::class)\n            ->set('title', 'Top 100 bubble bath brands')\n            ->set('content', '...')\n            ->call('save')\n            ->assertDispatched('post-created');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-50","text":"eated');\n    }\n}\n```\n\nIt is often helpful to test that two components can communicate with each other by dispatching and listening for events. Using the `dispatch()` method, let's simulate a `CreatePost` component dispatching a `create-post` event. Then, we will assert that a `PostCountBadge` component, which listens for that event, updates its post count appropriately:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-51","text":"ately:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\PostCountBadge;\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;\n\nclass PostCountBadgeTest extends TestCase\n{\n    public function test_post_count_is_updated_when_event_is_dispatched()\n    {\n        $badge = Livewire::test(PostCountBadge::class)\n            ->assertSee(\"0\");","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-52","text":"   ->assertSee(\"0\");\n\n        Livewire::test(CreatePost::class)\n            ->set('title', 'Tear-free: the greatest lie ever told')\n            ->set('content', '...')\n            ->call('save')\n            ->assertDispatched('post-created');\n\n        $badge->dispatch('post-created')\n            ->assertSee(\"1\");\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-53","text":"ee(\"1\");\n    }\n}\n```\n\nSometimes it may come in handy to assert that an event was dispatched with one or more parameters. Let's have a look at a component called `ShowPosts` that dispatches an event called `banner-message` with a parameter called `message`:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\ShowPosts;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-54","text":"\nuse Tests\\TestCase;\n\nclass ShowPostsTest extends TestCase\n{\n    public function test_notification_is_dispatched_when_deleting_a_post()\n    {\n        Livewire::test(ShowPosts::class)\n            ->call('delete', postId: 3)\n            ->assertDispatched('notify',\n                message: 'The post was deleted',\n            );\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-55","text":"      );\n    }\n}\n```\n\nIf your component dispatches an event of which the parameter values must be asserted conditionally, you can pass in a closure as the second argument to the `assertDispatched` method like below. It receives the event name as the first argument, and an array containing the parameters as the second argument. Make sure the closure returns a boolean.\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-56","text":"olean.\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\ShowPosts;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-57","text":"\nuse Tests\\TestCase;\n\nclass ShowPostsTest extends TestCase\n{\n    public function test_notification_is_dispatched_when_deleting_a_post()\n    {\n        Livewire::test(ShowPosts::class)\n            ->call('delete', postId: 3)\n            ->assertDispatched('notify', function($eventName, $params) {\n                return ($params['message'] ?? '') === 'The post was deleted';\n            })\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-58","text":"      })\n    }\n}\n```\n\n## All available testing utilities\n\nLivewire provides many more testing utilities. Below is a comprehensive list of every testing method available to you, with a short description of how it's intended to be used:","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-59","text":"intended to be used:\n\n### Setup methods\n| Method                                                  | Description                                                                                                      |\n|---------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-60","text":"-------------------|\n| `Livewire::test(CreatePost::class)`                      | Test the `CreatePost` component |\n| `Livewire::test(UpdatePost::class, ['post' => $post])`                      | Test the `UpdatePost` component with the `post` parameter (To be received through the `mount()` method) |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-61","text":" `mount()` method) |\n| `Livewire::actingAs($user)`                      | Set the provided user as the session's authenticated user |\n| `Livewire::withQueryParams(['search' => '...'])`                      | Set the test's `search` URL query parameter to the provided value (ex. `?search=...`). Typically in the context of a property using Livewire's [`#[Url]` attribute](/docs/url) |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-62","text":"ribute](/docs/url) |\n| `Livewire::withCookie('color', 'blue')`                      | Set the test's `color` cookie to the provided value (`blue`). |\n| `Livewire::withCookies(['color' => 'blue', 'name' => 'Taylor])`                      | Set the test's `color` and `name` cookies to the provided values (`blue`, `Taylor`). |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-63","text":"`blue`, `Taylor`). |\n| `Livewire::withHeaders(['X-COLOR' => 'blue', 'X-NAME' => 'Taylor])`                      | Set the test's `X-COLOR` and `X-NAME` headers to the provided values (`blue`, `Taylor`). |\n| `Livewire::withoutLazyLoading()`                      | Disable lazy loading in this and all child components under test. |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-64","text":"onents under test. |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-65","text":"onents under test. |\n\n\n### Interacting with components\n| Method                                                  | Description                                                                                                      |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-66","text":"                   |\n|---------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|\n| `set('title', '...')`                      | Set the `title` property to the provided value |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-67","text":"the provided value |\n| `set(['title' => '...', ...])`                      | Set multiple component properties using an associative array |\n| `toggle('sortAsc')`                      | Toggle the `sortAsc` property between `true` and `false`  |\n| `call('save')`                      | Call the `save` action / method |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-68","text":"e` action / method |\n| `call('remove', $post->id)`                      | Call the `remove` method and pass the `$post->id` as the first parameter (Accepts subsequent parameters as well) |\n| `refresh()`                      | Trigger a component re-render |\n| `dispatch('post-created')`                      | Dispatch the `post-created` event from the component  |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-69","text":"rom the component  |\n| `dispatch('post-created', postId: $post->id)`                      | Dispatch the `post-created` event with `$post->id` as an additional parameter (`$event.detail` from Alpine) |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-70","text":"tail` from Alpine) |\n\n### Assertions\n| Method                                                | Description                                                                                                                                                                          |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-71","text":"                   |\n|-------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-72","text":"-------------------|\n| `assertSet('title', '...')`                           | Assert that the `title` property is set to the provided value                                                                                                                        |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-73","text":"                   |\n| `assertNotSet('title', '...')`                        | Assert that the `title` property is not set to the provided value                                                                                                                    |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-74","text":"                   |\n| `assertSetStrict('title', '...')`                     | Assert that the `title` property is set to the provided value using a strict comparison                                                                                                                        |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-75","text":"                   |\n| `assertNotSetStrict('title', '...')`                  | Assert that the `title` property is not set to the provided value using a strict comparison                                                                                                                  |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-76","text":"                   |\n| `assertReturned('...')`                               | Assert that the previous `->call(...)` returned a given value\n| `assertCount('posts', 3)`                             | Assert that the `posts` property is an array-like value with `3` items in it                                                                                                         |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-77","text":"                   |\n| `assertSnapshotSet('date', '08/26/1990')`             | Assert that the `date` property's raw / dehydrated value (from JSON) is set to `08/26/1990`. Alternative to asserting against the hydrated `DateTime` instance in the case of `date` |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-78","text":"the case of `date` |\n| `assertSnapshotNotSet('date', '08/26/1990')`          | Assert that `date`'s raw / dehydrated value is not equal to the provided value                                                                                                       |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-79","text":"                   |\n| `assertSee($post->title)`                             | Assert that the rendered HTML of the component contains the provided value                                                                                                           |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-80","text":"                   |\n| `assertDontSee($post->title)`                         | Assert that the rendered HTML does not contain the provided value                                                                                                                    |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-81","text":"                   |\n| `assertSeeHtml('<div>...</div>')`                     | Assert the provided string literal is contained in the rendered HTML without escaping the HTML characters (unlike `assertSee`, which does escape the provided characters by default) |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-82","text":"acters by default) |\n| `assertDontSeeHtml('<div>...</div>')`                 | Assert the provided string is contained in the rendered HTML                                                                                                                         |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-83","text":"                   |\n| `assertSeeText($post->title)`                         | Assert that the provided string is contained within the rendered HTML text. The rendered content will be passed to the `strip_tags` PHP function before the assertion is made                                                                                          |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-84","text":"                   |\n| `assertDontSeeText($post->title)`                     | Assert that the provided string is not contained within the rendered HTML text. The rendered content will be passed to the `strip_tags` PHP function before the assertion is made                                                                                |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-85","text":"                   |\n| `assertSeeInOrder(['...', '...'])`                    | Assert that the provided strings appear in order in the rendered HTML output of the component                                                                                        |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-86","text":"                   |\n| `assertSeeHtmlInOrder([$firstString, $secondString])` | Assert that the provided HTML strings appear in order in the rendered output of the component                                                                                        |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-87","text":"                   |\n| `assertDispatched('post-created')`                    | Assert that the given event has been dispatched by the component                                                                                                                     |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-88","text":"                   |\n| `assertNotDispatched('post-created')`                 | Assert that the given event has not been dispatched by the component                                                                                                                 |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-89","text":"                   |\n| `assertHasErrors('title')`                            | Assert that validation has failed for the `title` property                                                                                                                           |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-90","text":"                   |\n| `assertHasErrors(['title' => ['required', 'min:6']])`   | Assert that the provided validation rules failed for the `title` property                                                                                                            |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-91","text":"                   |\n| `assertHasNoErrors('title')`                          | Assert that there are no validation errors for the `title` property                                                                                                                  |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-92","text":"                   |\n| `assertHasNoErrors(['title' => ['required', 'min:6']])` | Assert that the provided validation rules haven't failed for the `title` property                                                                                                    |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-93","text":"                   |\n| `assertRedirect()`                                    | Assert that a redirect has been triggered from within the component                                                                                                                  |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-94","text":"                   |\n| `assertRedirect('/posts')`                            | Assert the component triggered a redirect to the `/posts` endpoint                                                                                                                   |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-95","text":"                   |\n| `assertRedirect(ShowPosts::class)`                    | Assert that the component triggered a redirect to the `ShowPosts` component                                                                                                          |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-96","text":"                   |\n| `assertRedirectToRoute('name', ['parameters'])`       | Assert that the component triggered a redirect to the given route                                                                                                                    |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-97","text":"                   |\n| `assertNoRedirect()`                                  | Assert that no redirect has been triggered                                                                                                                                           |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-98","text":"                   |\n| `assertViewHas('posts')`                              | Assert that the `render()` method has passed a `posts` item to the view data                                                                                                         |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-99","text":"                   |\n| `assertViewHas('postCount', 3)`                       | Assert that a `postCount` variable has been passed to the view with a value of `3`                                                                                                   |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-100","text":"                   |\n| `assertViewHas('posts', function ($posts) { ... })`   | Assert that `posts` view data exists and that it passes any assertions declared in the provided callback                                                                         |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-101","text":"                   |\n| `assertViewIs('livewire.show-posts')`                 | Assert that the component's render method returned the provided view name                                                                                                            |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-102","text":"                   |\n| `assertFileDownloaded()`                              | Assert that a file download has been triggered                                                                                                                                       |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-103","text":"                   |\n| `assertFileDownloaded($filename)`                     | Assert that a file download matching the provided file name has been triggered                                                                                                       |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-104","text":"                   |\n| `assertNoFileDownloaded()`                            | Assert that no file download has been triggered                                                                                                                                       |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-105","text":"                   |\n| `assertUnauthorized()`                                | Assert that an authorization exception has been thrown within the component (status code: 401)                                                                                       |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-106","text":"                   |\n| `assertForbidden()`                                   | Assert that an error response was triggered with the status code: 403                                                                                                                |","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"ce084479f14b33de1ff93e2e959a109d-107","text":"                   |\n| `assertStatus(500)`                                   | Assert that the latest response matches the provided status code                                                                                                                     |\n","source":"/Users/fyyx/Documents/livewire/docs/testing.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-0","text":"Livewire allows you to lazy load components that would otherwise slow down the initial page load.\n\nFor example, imagine you have a `Revenue` component which contains a slow database query in `mount()`:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Transaction;\n\nclass Revenue extends Component\n{\n    public $amount;","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-1","text":"\n    public $amount;\n\n    public function mount()\n    {\n        // Slow database query...\n        $this->amount = Transaction::monthToDate()->sum('amount');\n    }\n\n    public function render()\n    {\n        return view('livewire.revenue');\n    }\n}\n```\n\n```blade\n<div>\n    Revenue this month: {{ $amount }}\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-2","text":"amount }}\n</div>\n```\n\nWithout lazy loading, this component would delay the loading of the entire page and make your entire application feel slow.\n\nTo enable lazy loading, you can pass the `lazy` parameter into the component:\n\n```blade\n<livewire:revenue lazy />\n```","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-3","text":":revenue lazy />\n```\n\nNow, instead of loading the component right away, Livewire will skip this component, loading the page without it. Then, when the component is visible in the viewport, Livewire will make a network request to fully load this component on the page.","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-4","text":"mponent on the page.\n\n> [!info] Lazy requests are isolated by default\n> Unlike other network requests in Livewire, lazy loading updates are isolated from each other when sent to the server. This keeps lazy loading fast, by loading each component in parallel when a page loads. [Read more on disabling this behavior here →](#disabling-request-isolation)\n\n## Rendering placeholder HTML","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-5","text":"ing placeholder HTML\n\nBy default, Livewire will insert an empty `<div></div>` for your component before it is fully loaded. As the component will initially be invisible to users, it can be jarring when the component suddenly appears on the page.","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-6","text":"appears on the page.\n\nTo signal to your users that the component is being loaded, you can define a `placeholder()` method to render any kind of placeholder HTML you like, including loading spinners and skeleton placeholders:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Transaction;\n\nclass Revenue extends Component\n{\n    public $amount;","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-7","text":"\n    public $amount;\n\n    public function mount()\n    {\n        // Slow database query...\n        $this->amount = Transaction::monthToDate()->sum('amount');\n    }\n\n    public function placeholder()\n    {\n        return <<<'HTML'\n        <div>\n            <!-- Loading spinner... -->\n            <svg>...</svg>\n        </div>\n        HTML;\n    }","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-8","text":"\n        HTML;\n    }\n\n    public function render()\n    {\n        return view('livewire.revenue');\n    }\n}\n```\n\nBecause the above component specifies a \"placeholder\" by returning HTML from a `placeholder()` method, the user will see an SVG loading spinner on the page until the component is fully loaded.","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-9","text":"ent is fully loaded.\n\n> [!warning] The placeholder and the component must share the same element type\n> For instance, if your placeholder's root element type is a 'div,' your component must also use a 'div' element.\n\n### Rendering a placeholder via a view\n\nFor more complex loaders (such as skeletons) you can return a `view` from the `placeholder()` similar to `render()`.","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-10","text":"milar to `render()`.\n\n```php\npublic function placeholder(array $params = [])\n{\n    return view('livewire.placeholders.skeleton', $params);\n}\n```\n\nAny parameters from the component being lazy loaded will be available as an `$params` argument passed to the `placeholder()` method.\n\n## Lazy loading outside of the viewport","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-11","text":"side of the viewport\n\nBy default, Lazy-loaded components aren't full loaded until they enter the browser's viewport, for example when a user scrolls to one.\n\nIf you'd rather lazy load all components on a page as soon as the page is loaded, without waiting for them to enter the viewport, you can do so by passing \"on-load\" into the `lazy` parameter:\n\n```blade\n<livewire:revenue lazy=\"on-load\" />\n```","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-12","text":"azy=\"on-load\" />\n```\n\nNow this component will load after the page is ready without waiting for it to be inside the viewport.\n\n## Passing in props\n\nIn general, you can treat `lazy` components the same as normal components, since you can still pass data into them from outside.\n\nFor example, here's a scenario where you might pass a time interval into the `Revenue` component from a parent component:","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-13","text":" a parent component:\n\n```blade\n<input type=\"date\" wire:model=\"start\">\n<input type=\"date\" wire:model=\"end\">\n\n<livewire:revenue lazy :$start :$end />\n```\n\nYou can accept this data in `mount()` just like any other component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Transaction;\n\nclass Revenue extends Component\n{\n    public $amount;","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-14","text":"\n    public $amount;\n\n    public function mount($start, $end)\n    {\n        // Expensive database query...\n        $this->amount = Transactions::between($start, $end)->sum('amount');\n    }\n\n    public function placeholder()\n    {\n        return <<<'HTML'\n        <div>\n            <!-- Loading spinner... -->\n            <svg>...</svg>\n        </div>\n        HTML;\n    }","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-15","text":"\n        HTML;\n    }\n\n    public function render()\n    {\n        return view('livewire.revenue');\n    }\n}\n```\n\nHowever, unlike a normal component load, a `lazy` component has to serialize or \"dehydrate\" any passed-in properties and temporarily store them on the client-side until the component is fully loaded.","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-16","text":"ent is fully loaded.\n\nFor example, you might want to pass in an Eloquent model to the `Revenue` component like so:\n\n```blade\n<livewire:revenue lazy :$user />\n```","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-17","text":"e lazy :$user />\n```\n\nIn a normal component, the actual PHP in-memory `$user` model would be passed into the `mount()` method of `Revenue`. However, because we won't run `mount()` until the next network request, Livewire will internally serialize `$user` to JSON and then re-query it from the database before the next request is handled.","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-18","text":" request is handled.\n\nTypically, this serialization should not cause any behavioral differences in your application.\n\n## Lazy load by default\n\nIf you want to enforce that all usages of a component will be lazy-loaded, you can add the `#[Lazy]` attribute above the component class:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse Livewire\\Attributes\\Lazy;","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-19","text":"ire\\Attributes\\Lazy;\n\n#[Lazy]\nclass Revenue extends Component\n{\n    // ...\n}\n```\n\nIf you want to override lazy loading you can set the `lazy` parameter to `false`:\n\n```blade\n<livewire:revenue :lazy=\"false\" />\n```\n\n### Disabling request isolation","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-20","text":"ng request isolation\n\nIf there are multiple lazy-loaded components on the page, each component will make an independent network request, rather than each lazy update being bundled into a single request.\n\nIf you want to disable this isolation behavior and instead bundle all updates together in a single network request you can do so with the `isolate: false` parameter:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-21","text":"meter:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse Livewire\\Attributes\\Lazy;\n\n#[Lazy(isolate: false)] // [tl! highlight]\nclass Revenue extends Component\n{\n    // ...\n}\n```\n\nNow, if there are ten `Revenue` components on the same page, when the page loads, all ten updates will be bundled and sent the server as single network request.\n\n## Full-page lazy loading","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-22","text":"ll-page lazy loading\n\nYou may want to lazy load full-page Livewire components. You can do this by calling `->lazy()` on the route like so:\n\n```php\nRoute::get('/dashboard', \\App\\Livewire\\Dashboard::class)->lazy();\n```\n\nOr alternatively, if there is a component that is lazy-loaded by default, and you would like to opt-out of lazy-loading, you can use the following `enabled: false` parameter:","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-23","text":"d: false` parameter:\n\n```php\nRoute::get('/dashboard', \\App\\Livewire\\Dashboard::class)->lazy(enabled: false);\n```\n\n## Default placeholder view\n\nIf you want to set a default placeholder view for all your components you can do so by referencing the view in the `/config/livewire.php` config file:\n\n```php\n'lazy_placeholder' => 'livewire.placeholder',\n```","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-24","text":"re.placeholder',\n```\n\nNow, when a component is lazy-loaded and no `placeholder()` is defined, Livewire will use the configured Blade view (`livewire.placeholder` in this case.)\n\n## Disabling lazy loading for tests","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-25","text":"zy loading for tests\n\nWhen unit testing a lazy component, or a page with nested lazy components, you may want to disable the \"lazy\" behavior so that you can assert the final rendered behavior. Otherwise, those components would be rendered as their placeholders during your tests.\n\nYou can easily disable lazy loading using the `Livewire::withoutLazyLoading()` testing helper like so:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-26","text":"ke so:\n\n```php\n<?php\n\nnamespace Tests\\Feature\\Livewire;\n\nuse App\\Livewire\\Dashboard;\nuse Livewire\\Livewire;\nuse Tests\\TestCase;\n\nclass DashboardTest extends TestCase\n{\n    public function test_renders_successfully()\n    {\n        Livewire::withoutLazyLoading() // [tl! highlight]\n            ->test(Dashboard::class)\n            ->assertSee(...);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"4ab2e08d0462cafcbeb9a96ee9ae7606-27","text":"ee(...);\n    }\n}\n```\n\nNow, when the dashboard component is rendered for this test, it will skip rendering the `placeholder()` and instead render the full component as if lazy loading wasn't applied at all.\n\n","source":"/Users/fyyx/Documents/livewire/docs/lazy.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-0","text":"\nLivewire makes it easy to persist property values across page refreshes/changes using the `#[Session]` attribute.\n\nBy adding `#[Session]` to a property in your component, Livewire will store that property's value in the session every time it changes. This way, when a page is refreshed, Livewire will fetch the latest value from the session and use it in your component.","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-1","text":"t in your component.\n\nThe `#[Session]` attribute is analogous to the [`#[Url]`](/docs/url) attribute. They are both useful in similar scenarios. The primary difference being `#[Session]` persists values without modifying the URL's query string, which is sometimes desired; sometimes not.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-2","text":"not.\n\n## Basic usage\n\nHere's a `ShowPosts` component that allows users to filter visible posts by a string stored in a `$search` property:\n\n```php\n<?php\n\nuse Livewire\\Attributes\\Session;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    #[Session] // [tl! highlight]\n    public $search;","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-3","text":"\n    public $search;\n\n    protected function posts()\n    {\n        return $this->search === ''\n            ? Post::all()\n            : Post::where('title', 'like', '%'.$this->search.'%');\n    }\n\n    public function render()\n    {\n        return view('livewire.show-posts', [\n            'posts' => $this->posts(),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-4","text":"     ]);\n    }\n}\n```\n\nBecause the `#[Session]` attribute has been added to the `$search` property, after a user enters a search value, they can refresh the page and the search value will be persisted. Every time `$search` is updated, its new value will be stored in the user's session and used across page loads.","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-5","text":"d across page loads.\n\n> [!warning] Performance implications\n> Because Laravel sessions are loaded into memory during every request, you can slow down the performance of your entire application for a given user by storing too much in a user's session.\n\n## Setting a custom key","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-6","text":"Setting a custom key\n\nWhen using `[#Session]`, Livewire will store the property value in the session using a dynamically generated key that consists of the component name combined with the property name.\n\nThis ensures that properties across component instances will use the same session value. It also ensures properties of the same name from different components won't conflict.","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-7","text":"ents won't conflict.\n\nIf you want full control over what session key Livewire uses for a given property, you can pass the `key:` parameter:\n\n```php\n<?php\n\nuse Livewire\\Attributes\\Session;\nuse Livewire\\Component;\n\nclass ShowPosts extends Component\n{\n    #[Session(key: 'search')] // [tl! highlight]\n    public $search;\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-8","text":"h;\n\n    // ...\n}\n```\n\nWhen Livewire stores and retrieves the value of the `$search` property, it will use the given key: \"search\".\n\nAdditionally, if you want to generate the key dynamically from other properties in your component, you can do so using the following curly brace notation:\n\n```php\n<?php\n\nuse Livewire\\Attributes\\Session;\nuse Livewire\\Component;\nuse App\\Models\\Author;","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"ce2e123d4ec5b47cc2fda548a1b32e34-9","text":"e App\\Models\\Author;\n\nclass ShowPosts extends Component\n{\n    public Author $author;\n\n    #[Session(key: 'search-{author.id}')] // [tl! highlight]\n    public $search;\n\n    // ...\n}\n```\n\nIn the above example, if the `$author` model's id is \"4\", the session key will become: `search-4`\n","source":"/Users/fyyx/Documents/livewire/docs/session-properties.md"}
{"id":"4ecd359e67e4f5f0e6d3d2ed5860349d-0","text":"\nLivewire's ability to make updates to the page is what makes it \"live\", however, there are times when you might want to prevent Livewire from updating a portion of the page.\n\nIn these cases, you can use the `wire:ignore` directive to instruct Livewire to ignore the contents of a particular element, even if they change between requests.","source":"/Users/fyyx/Documents/livewire/docs/wire-ignore.md"}
{"id":"4ecd359e67e4f5f0e6d3d2ed5860349d-1","text":"ge between requests.\n\nThis is most useful in the context of working with third-party javascript libraries for custom form inputs and such.\n\nBelow is an example of wrapping an element used by a third-party library in `wire:ignore` so that Livewire doesn't tamper with the HTML generated by the library:\n\n```blade\n<form>\n    <!-- ... -->","source":"/Users/fyyx/Documents/livewire/docs/wire-ignore.md"}
{"id":"4ecd359e67e4f5f0e6d3d2ed5860349d-2","text":"rm>\n    <!-- ... -->\n\n    <div wire:ignore>\n        <!-- This element would be reference by a -->\n        <!-- third-party library for initialization... -->\n        <input id=\"id-for-date-picker-library\">\n    </div>\n\n    <!-- ... -->\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-ignore.md"}
{"id":"4ecd359e67e4f5f0e6d3d2ed5860349d-3","text":" ... -->\n</form>\n```\n\nYou can also instruct Livewire to only ignore changes to attributes of the root element rather than observing changes to its contents using `wire:ignore.self`.\n\n```blade\n<div wire:ignore.self>\n    <!-- ... -->\n</div>\n```\n","source":"/Users/fyyx/Documents/livewire/docs/wire-ignore.md"}
{"id":"7bd7485ec395e5a192bb80afedc7731b-0","text":"```json\n{\n    \"data\": [\n        \"todos\": [[], [\"s\": \"array\"]],\n    ],\n    \"memo\": {\n        \"id\": \"...\",\n        \"name\": \"...\",\n        \"path\": \"...\",\n        \"method\": \"...\",\n        \"locale\": \"...\",\n        \"children\": \"...\"\n    },\n    \"checksum\": \"...\"\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/the-livewire-protocol.md"}
{"id":"7bd7485ec395e5a192bb80afedc7731b-1","text":"ecksum\": \"...\"\n}\n```\n\n```json\n{\n    \"snapshot\": {...},\n    \"updates\": {\n        \"todos.0\": \"hey\",\n    },\n    \"calls\": [\n        [\n            \"path\": \"\",\n            \"method\": \"add\",\n            \"params\": [],\n        ]    \n    ]\n}\n```\n\n```json\n{\n    \"snapshot\": {...},\n    \"effects\": {\n        \"html\": \"...\",\n        \"returns\": []\n    }\n}\n```\n","source":"/Users/fyyx/Documents/livewire/docs/the-livewire-protocol.md"}
{"id":"6a66350113b139901966ef38cf5aeaa3-0","text":"\n`wire:cloak` is a directive that hides elements on page load until Livewire is fully initialized. This is useful for preventing the \"flash of unstyled content\" that can occur when the page loads before Livewire has a chance to initialize.\n\n## Basic usage\n\nTo use `wire:cloak`, add the directive to any element you want to hide during page load:","source":"/Users/fyyx/Documents/livewire/docs/wire-cloak.md"}
{"id":"6a66350113b139901966ef38cf5aeaa3-1","text":"de during page load:\n\n```blade\n<div wire:cloak>\n    This content will be hidden until Livewire is fully loaded\n</div>\n```\n\n### Dynamic content\n\n`wire:cloak` is particularly useful in scenarios where you want to prevent users from seeing uninitialized dynamic content such as element shown or hidden using `wire:show`.","source":"/Users/fyyx/Documents/livewire/docs/wire-cloak.md"}
{"id":"6a66350113b139901966ef38cf5aeaa3-2","text":"n using `wire:show`.\n\n```blade\n<div>\n    <div wire:show=\"starred\" wire:cloak>\n        <!-- Yellow star icon... -->\n    </div>\n\n    <div wire:show=\"!starred\" wire:cloak>\n        <!-- Gray star icon... -->\n    </div>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-cloak.md"}
{"id":"6a66350113b139901966ef38cf5aeaa3-3","text":"   </div>\n</div>\n```\n\nIn the above example, without `wire:cloak`, both icons would be shown before Livewire initializes. However, with `wire:cloak`, both elements will be hidden until initialization.\n","source":"/Users/fyyx/Documents/livewire/docs/wire-cloak.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-0","text":"\nLivewire allows you to stream content to a web page before a request is complete via the `wire:stream` API. This is an extremely useful feature for things like AI chat-bots which stream responses as they are generated.\n\n> [!warning] Not compatible with Laravel Octane\n> Livewire currently does not support using `wire:stream` with Laravel Octane.","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-1","text":"with Laravel Octane.\n\nTo demonstrate the most basic functionality of `wire:stream`, below is a simple CountDown component that when a button is pressed displays a count-down to the user from \"3\" to \"0\":\n\n```php\nuse Livewire\\Component;\n\nclass CountDown extends Component\n{\n    public $start = 3;","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-2","text":"  public $start = 3;\n\n    public function begin()\n    {\n        while ($this->start >= 0) {\n            // Stream the current count to the browser...\n            $this->stream(  // [tl! highlight:4]\n                to: 'count',\n                content: $this->start,\n                replace: true,\n            );\n\n            // Pause for 1 second between numbers...\n            sleep(1);","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-3","text":"           sleep(1);\n\n            // Decrement the counter...\n            $this->start = $this->start - 1;\n        };\n    }\n\n    public function render()\n    {\n        return <<<'HTML'\n        <div>\n            <button wire:click=\"begin\">Start count-down</button>","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-4","text":" count-down</button>\n\n            <h1>Count: <span wire:stream=\"count\">{{ $start }}</span></h1> <!-- [tl! highlight] -->\n        </div>\n        HTML;\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-5","text":"   HTML;\n    }\n}\n```\n\nHere's what's happening from the user's perspective when they press \"Start count-down\":\n* \"Count: 3\" is shown on the page\n* They press the \"Start count-down\" button\n* One second elapses and \"Count: 2\" is shown\n* This process continues until \"Count: 0\" is shown\n\nAll of the above happens while a single network request is out to the server.","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-6","text":"s out to the server.\n\nHere's what's happening from the system's perspective when the button is pressed:\n* A request is sent to Livewire to call the `begin()` method\n* The `begin()` method is called and the `while` loop begins\n* `$this->stream()` is called and immediately starts a \"streamed response\" to the browser","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-7","text":"onse\" to the browser\n* The browser receives a streamed response with instructions to find the element in the component with `wire:stream=\"count\"`, and replace its contents with the received payload (\"3\" in the case of the first streamed number)\n* The `sleep(1)` method causes the server to hang for one second","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-8","text":" hang for one second\n* The `while` loop is repeated and the process of streaming a new number every second continues until the `while` condition is falsy\n* When `begin()` has finished running and all the counts have been streamed to the browser, Livewire finishes it's request lifecycle, rendering the component and sending the final response to the browser","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-9","text":"ponse to the browser\n\n## Streaming chat-bot responses\n\nA common use-case for `wire:stream` is streaming chat-bot responses as they are received from an API that supports streamed responses (like [OpenAI's ChatGPT](https://chat.openai.com/)).\n\nBelow is an example of using `wire:stream` to accomplish a ChatGPT-like interface:\n\n```php\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-10","text":" Livewire\\Component;\n\nclass ChatBot extends Component\n{\n    public $prompt = '';\n\n    public $question = '';\n\n    public $answer = '';\n\n    function submitPrompt()\n    {\n        $this->question = $this->prompt;\n\n        $this->prompt = '';\n\n        $this->js('$wire.ask()');\n    }","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-11","text":"$wire.ask()');\n    }\n\n    function ask()\n    {\n        $this->answer = OpenAI::ask($this->question, function ($partial) {\n            $this->stream(to: 'answer', content: $partial); // [tl! highlight]\n        });\n    }\n\n    public function render()\n    {\n        return <<<'HTML'\n        <div>\n            <section>\n                <div>ChatBot</div>","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-12","text":"  <div>ChatBot</div>\n\n                @if ($question)\n                    <article>\n                        <hgroup>\n                            <h3>User</h3>\n                            <p>{{ $question }}</p>\n                        </hgroup>","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-13","text":"           </hgroup>\n\n                        <hgroup>\n                            <h3>ChatBot</h3>\n                            <p wire:stream=\"answer\">{{ $answer }}</p> <!-- [tl! highlight] -->\n                        </hgroup>\n                    </article>\n                @endif\n            </section>","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-14","text":"          </section>\n\n            <form wire:submit=\"submitPrompt\">\n                <input wire:model=\"prompt\" type=\"text\" placeholder=\"Send a message\" autofocus>\n            </form>\n        </div>\n        HTML;\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-15","text":"   HTML;\n    }\n}\n```\n\nHere's what's going on in the above example:\n* A user types into a text field labeled \"Send a message\" to ask the chat-bot a question.\n* They press the [Enter] key.\n* A network request is sent to the server, sets the message to the `$question` property, and clears the `$prompt` property.","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-16","text":" `$prompt` property.\n* The response is sent back to the browser and the input is cleared. Because `$this->js('...')` was called, a new request is triggered to the server calling the `ask()` method.\n* The `ask()` method calls on the ChatBot API and receives streamed response partials via the `$partial` parameter in the callback.","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-17","text":"ter in the callback.\n* Each `$partial` gets streamed to the browser into the `wire:stream=\"answer\"` element on the page, showing the answer progressively reveal itself to the user.\n* When the entire response is received, the Livewire request finishes and the user receives the full response.","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-18","text":"s the full response.\n\n## Replace vs. append\n\nWhen streaming content to an element using `$this->stream()`, you can tell Livewire to either replace the contents of the target element with the streamed contents or append them to the existing contents.","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-19","text":"e existing contents.\n\nReplacing or appending can both be desirable depending on the scenario. For example, when streaming a response from a chatbot, typically appending is desired (and is therefore the default). However, when showing something like a count-down, replacing is more fitting.\n\nYou can configure either by passing the `replace:` parameter to `$this->stream` with a boolean value:","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-20","text":"ith a boolean value:\n\n```php\n// Append contents...\n$this->stream(to: 'target', content: '...');\n\n// Replace contents...\n$this->stream(to: 'target', content: '...', replace: true);\n```\n\nAppend/replace can also be specified at the target element level by appending or removing the `.replace` modifier:\n\n```blade\n// Append contents...\n<div wire:stream=\"target\">","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"45b60d7ee6d4d832b90a4e826d118537-21","text":"ire:stream=\"target\">\n\n// Replace contents...\n<div wire:stream.replace=\"target\">\n```\n","source":"/Users/fyyx/Documents/livewire/docs/wire-stream.md"}
{"id":"e7e4b22adacb9246e528603740e02719-0","text":"Properties store and manage data inside your Livewire components. They are defined as public properties on component classes and can be accessed and modified on both the server and client-side.\n\n## Initializing properties\n\nYou can set initial values for properties within your component's `mount()` method.\n\nConsider the following example:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-1","text":"espace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\n\nclass TodoList extends Component\n{\n    public $todos = [];\n\n    public $todo = '';\n\n    public function mount()\n    {\n        $this->todos = Auth::user()->todos; // [tl! highlight]\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-2","text":" }\n\n    // ...\n}\n```\n\nIn this example, we've defined an empty `todos` array and initialized it with existing todos from the authenticated user. Now, when the component renders for the first time, all the existing todos in the database are shown to the user.\n\n## Bulk assignment","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-3","text":"\n\n## Bulk assignment\n\nSometimes initializing many properties in the `mount()` method can feel verbose. To help with this, Livewire provides a convenient way to assign multiple properties at once via the `fill()` method. By passing an associative array of property names and their respective values, you can set several properties simultaneously and cut down on repetitive lines of code in `mount()`.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-4","text":"f code in `mount()`.\n\nFor example:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass UpdatePost extends Component\n{\n    public $post;\n\n    public $title;\n\n    public $description;\n\n    public function mount(Post $post)\n    {\n        $this->post = $post;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-5","text":"$this->post = $post;\n\n        $this->fill( // [tl! highlight]\n            $post->only('title', 'description'), // [tl! highlight]\n        ); // [tl! highlight]\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-6","text":" }\n\n    // ...\n}\n```\n\nBecause `$post->only(...)` returns an associative array of model attributes and values based on the names you pass into it, the `$title` and `$description` properties will be initially set to the `title` and `description` of the `$post` model from the database without having to set each one individually.\n\n## Data binding","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-7","text":"ly.\n\n## Data binding\n\nLivewire supports two-way data binding through the `wire:model` HTML attribute. This allows you to easily synchronize data between component properties and HTML inputs, keeping your user interface and component state in sync.\n\nLet's use the `wire:model` directive to bind the `$todo` property in a `TodoList` component to a basic input element:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-8","text":"ement:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass TodoList extends Component\n{\n    public $todos = [];\n\n    public $todo = '';\n\n    public function add()\n    {\n        $this->todos[] = $this->todo;\n\n        $this->todo = '';\n    }\n\n    // ...\n}\n```\n\n```blade\n<div>\n    <input type=\"text\" wire:model=\"todo\" placeholder=\"Todo...\"> <!-- [tl! highlight] -->","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-9","text":" [tl! highlight] -->\n\n    <button wire:click=\"add\">Add Todo</button>\n\n    <ul>\n        @foreach ($todos as $todo)\n            <li>{{ $todo }}</li>\n        @endforeach\n    </ul>\n</div>\n```\n\nIn the above example, the text input's value will synchronize with the `$todo` property on the server when the \"Add Todo\" button is clicked.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-10","text":"\" button is clicked.\n\nThis is just scratching the surface of `wire:model`. For deeper information on data binding, check out our [documentation on forms](/docs/forms).\n\n## Resetting properties","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-11","text":"Resetting properties\n\nSometimes, you may need to reset your properties back to their initial state after an action is performed by the user. In these cases, Livewire provides a `reset()` method that accepts one or more property names and resets their values to their initial state.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-12","text":"their initial state.\n\nIn the example below, we can avoid code duplication by using `$this->reset()` to reset the `todo` field after the \"Add Todo\" button is clicked:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass ManageTodos extends Component\n{\n    public $todos = [];\n\n    public $todo = '';\n\n    public function addTodo()\n    {\n        $this->todos[] = $this->todo;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-13","text":"dos[] = $this->todo;\n\n        $this->reset('todo'); // [tl! highlight]\n    }\n\n    // ...\n}\n```\n\nIn the above example, after a user clicks \"Add Todo\", the input field holding the todo that has just been added will clear, allowing the user to write a new todo.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-14","text":"to write a new todo.\n\n> [!warning] `reset()` won't work on values set in `mount()`\n> `reset()` will reset a property to its state before the `mount()` method was called. If you initialized the property in `mount()` to a different value, you will need to reset the property manually.\n\n## Pulling properties","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-15","text":"# Pulling properties\n\nAlternatively, you can use the `pull()` method to both reset and retrieve the value in one operation.\n\nHere's the same example from above, but simplified with `pull()`:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass ManageTodos extends Component\n{\n    public $todos = [];\n\n    public $todo = '';","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-16","text":"  public $todo = '';\n\n    public function addTodo()\n    {\n        $this->todos[] = $this->pull('todo'); // [tl! highlight]\n    }\n\n    // ...\n}\n```\n\nThe above example is pulling a single value, but `pull()` can also be used to reset and retrieve (as a key-value pair) all or some properties:\n\n```php\n// The same as $this->all() and $this->reset();\n$this->pull();","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-17","text":"et();\n$this->pull();\n\n// The same as $this->only(...) and $this->reset(...);\n$this->pull(['title', 'content']);\n```\n\n## Supported property types\n\nLivewire supports a limited set of property types because of its unique approach to managing component data between server requests.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-18","text":"een server requests.\n\nEach property in a Livewire component is serialized or \"dehydrated\" into JSON between requests, then \"hydrated\" from JSON back into PHP for the next request.\n\nThis two-way conversion process has certain limitations, restricting the types of properties Livewire can work with.\n\n### Primitive types","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-19","text":"\n### Primitive types\n\nLivewire supports primitive types such as strings, integers, etc. These types can be easily converted to and from JSON, making them ideal for use as properties in Livewire components.\n\nLivewire supports the following primitive property types: `Array`, `String`, `Integer`, `Float`, `Boolean`, and `Null`.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-20","text":"oolean`, and `Null`.\n\n```php\nclass TodoList extends Component\n{\n    public $todos = []; // Array\n\n    public $todo = ''; // String\n\n    public $maxTodos = 10; // Integer\n\n    public $showTodos = false; // Boolean\n\n    public $todoFilter; // Null\n}\n```\n\n### Common PHP types","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-21","text":"### Common PHP types\n","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-22","text":"## Common PHP types\n\nIn addition to primitive types, Livewire supports common PHP object types used in Laravel applications. However, it's important to note that these types will be _dehydrated_ into JSON and _hydrated_ back to PHP on each request. This means that the property may not preserve run-time values such as closures","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-23","text":"ues such as closures. Also, information about the object such as class names may be exposed to JavaScript.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-24","text":"posed to JavaScript.\n\nSupported PHP types:\n| Type | Full Class Name |\n|------|-----------------|\n| BackedEnum | `BackedEnum` |\n| Collection | `Illuminate\\Support\\Collection` |\n| Eloquent Collection | `Illuminate\\Database\\Eloquent\\Collection` |\n| Model | `Illuminate\\Database\\Eloquent\\Model` |\n| DateTime | `DateTime` |\n| Carbon | `Carbon\\Carbon` |\n| Stringable | `Illuminate\\Support\\Stringable` |","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-25","text":"upport\\Stringable` |\n\n> [!warning] Eloquent Collections and Models\n> When storing Eloquent Collections and Models in Livewire properties, additional query constraints like select(...) will not be re-applied on subsequent requests.\n>\n> See [Eloquent constraints aren't preserved between requests](#eloquent-constraints-arent-preserved-between-requests) for more details","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-26","text":"ts) for more details\n\nHere's a quick example of setting properties as these various types:\n\n```php\npublic function mount()\n{\n    $this->todos = collect([]); // Collection\n\n    $this->todos = Todos::all(); // Eloquent Collection\n\n    $this->todo = Todos::first(); // Model\n\n    $this->date = new DateTime('now'); // DateTime\n\n    $this->date = new Carbon('now'); // Carbon","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-27","text":"on('now'); // Carbon\n\n    $this->todo = str(''); // Stringable\n}\n```\n\n### Supporting custom types\n\nLivewire allows your application to support custom types through two powerful mechanisms:\n\n* Wireables\n* Synthesizers","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-28","text":"ables\n* Synthesizers\n\nWireables are simple and easy to use for most applications, so we'll explore them below. If you're an advanced user or package author wanting more flexibility, [Synthesizers are the way to go](/docs/synthesizers).\n\n#### Wireables\n\nWireables are any class in your application that implements the `Wireable` interface.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-29","text":"Wireable` interface.\n\nFor example, let's imagine you have a `Customer` object in your application that contains the primary data about a customer:\n\n```php\nclass Customer\n{\n    protected $name;\n    protected $age;\n\n    public function __construct($name, $age)\n    {\n        $this->name = $name;\n        $this->age = $age;\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-30","text":" = $age;\n    }\n}\n```\n\nAttempting to set an instance of this class to a Livewire component property will result in an error telling you that the `Customer` property type isn't supported:\n\n```php\nclass ShowCustomer extends Component\n{\n    public Customer $customer;\n\n    public function mount()\n    {\n        $this->customer = new Customer('Caleb', 29);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-31","text":"b', 29);\n    }\n}\n```\n\nHowever, you can solve this by implementing the `Wireable` interface and adding a `toLivewire()` and `fromLivewire()` method to your class. These methods tell Livewire how to turn properties of this type into JSON and back again:\n\n```php\nuse Livewire\\Wireable;\n\nclass Customer implements Wireable\n{\n    protected $name;\n    protected $age;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-32","text":"\n    protected $age;\n\n    public function __construct($name, $age)\n    {\n        $this->name = $name;\n        $this->age = $age;\n    }\n\n    public function toLivewire()\n    {\n        return [\n            'name' => $this->name,\n            'age' => $this->age,\n        ];\n    }\n\n    public static function fromLivewire($value)\n    {\n        $name = $value['name'];\n        $age = $value['age'];","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-33","text":"age = $value['age'];\n\n        return new static($name, $age);\n    }\n}\n```\n\nNow you can freely set `Customer` objects on your Livewire components and Livewire will know how to convert these objects into JSON and back into PHP.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-34","text":"N and back into PHP.\n\nAs mentioned earlier, if you want to support types more globally and powerfully, Livewire offers Synthesizers, its advanced internal mechanism for handling different property types. [Learn more about Synthesizers](/docs/synthesizers).\n\n## Accessing properties from JavaScript","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-35","text":"ties from JavaScript\n\nBecause Livewire properties are also available in the browser via JavaScript, you can access and manipulate their JavaScript representations from [AlpineJS](https://alpinejs.dev/).","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-36","text":"ps://alpinejs.dev/).\n\nAlpine is a lightweight JavaScript library that is included with Livewire. Alpine provides a way to build lightweight interactions into your Livewire components without making full server roundtrips.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-37","text":"l server roundtrips.\n\nInternally, Livewire's frontend is built on top of Alpine. In fact, every Livewire component is actually an Alpine component under-the-hood. This means that you can freely utilize Alpine inside your Livewire components.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-38","text":"Livewire components.\n\nThe rest of this page assumes a basic familiarity with Alpine. If you're unfamiliar with Alpine, [take a look at the Alpine documentation](https://alpinejs.dev/docs).\n\n### Accessing properties\n\nLivewire exposes a magic `$wire` object to Alpine. You can access the `$wire` object from any Alpine expression inside your Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-39","text":" Livewire component.\n\nThe `$wire` object can be treated like a JavaScript version of your Livewire component. It has all the same properties and methods as the PHP version of your component, but also contains a few dedicated methods to perform specific functions in your template.\n\nFor example, we can use `$wire` to show a live character count of the `todo` input field:","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-40","text":" `todo` input field:\n\n```blade\n<div>\n    <input type=\"text\" wire:model=\"todo\">\n\n    Todo character length: <h2 x-text=\"$wire.todo.length\"></h2>\n</div>\n```\n\nAs the user types in the field, the character length of the current todo being written will be shown and live-updated on the page, all without sending a network request to the server.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-41","text":"quest to the server.\n\nIf you prefer, you can use the more explicit `.get()` method to accomplish the same thing:\n\n```blade\n<div>\n    <input type=\"text\" wire:model=\"todo\">\n\n    Todo character length: <h2 x-text=\"$wire.get('todo').length\"></h2>\n</div>\n```\n\n### Manipulating properties\n\nSimilarly, you can manipulate your Livewire component properties in JavaScript using `$wire`.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-42","text":"cript using `$wire`.\n\nFor example, let's add a \"Clear\" button to the `TodoList` component to allow the user to reset the input field using only JavaScript:\n\n```blade\n<div>\n    <input type=\"text\" wire:model=\"todo\">\n\n    <button x-on:click=\"$wire.todo = ''\">Clear</button>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-43","text":"</button>\n</div>\n```\n\nAfter the user clicks \"Clear\", the input will be reset to an empty string, without sending a network request to the server.\n\nOn the subsequent request, the server-side value of `$todo` will be updated and synchronized.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-44","text":"ed and synchronized.\n\nIf you prefer, you can also use the more explicit `.set()` method for setting properties client-side. However, you should note that using `.set()` by default immediately triggers a network request and synchronizes the state with the server. If that is desired, then this is an excellent API:\n\n```blade\n<button x-on:click=\"$wire.set('todo', '')\">Clear</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-45","text":"\">Clear</button>\n```\n\nIn order to update the property without sending a network request to the server, you can pass a third bool parameter. This will defer the network request and on a subsequent request, the state will be synchronized on the server-side:\n```blade\n<button x-on:click=\"$wire.set('todo', '', false)\">Clear</button>\n```\n\n## Security concerns","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-46","text":"## Security concerns\n\nWhile Livewire properties are a powerful feature, there are a few security considerations that you should be aware of before using them.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-47","text":"f before using them.\n\nIn short, always treat public properties as user input — as if they were request input from a traditional endpoint. In light of this, it's essential to validate and authorize properties before persisting them to a database — just like you would do when working with request input in a controller.\n\n### Don't trust property values","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-48","text":"rust property values\n\nTo demonstrate how neglecting to authorize and validate properties can introduce security holes in your application, the following `UpdatePost` component is vulnerable to attack:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass UpdatePost extends Component\n{\n    public $id;\n    public $title;\n    public $content;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-49","text":"    public $content;\n\n    public function mount(Post $post)\n    {\n        $this->id = $post->id;\n        $this->title = $post->title;\n        $this->content = $post->content;\n    }\n\n    public function update()\n    {\n        $post = Post::findOrFail($this->id);\n\n        $post->update([\n            'title' => $this->title,\n            'content' => $this->content,\n        ]);","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-50","text":"content,\n        ]);\n\n        session()->flash('message', 'Post updated successfully!');\n    }\n\n    public function render()\n    {\n        return view('livewire.update-post');\n    }\n}\n```\n\n```blade\n<form wire:submit=\"update\">\n    <input type=\"text\" wire:model=\"title\">\n    <input type=\"text\" wire:model=\"content\">\n\n    <button type=\"submit\">Update</button>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-51","text":"/button>\n</form>\n```\n\nAt first glance, this component may look completely fine. But, let's walk through how an attacker could use the component to do unauthorized things in your application.\n\nBecause we are storing the `id` of the post as a public property on the component, it can be manipulated on the client just the same as the `title` and `content` properties.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-52","text":"content` properties.\n\nIt doesn't matter that we didn't write an input with `wire:model=\"id\"`. A malicious user can easily change the view to the following using their browser DevTools:\n\n```blade\n<form wire:submit=\"update\">\n    <input type=\"text\" wire:model=\"id\"> <!-- [tl! highlight] -->\n    <input type=\"text\" wire:model=\"title\">\n    <input type=\"text\" wire:model=\"content\">","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-53","text":"ire:model=\"content\">\n\n    <button type=\"submit\">Update</button>\n</form>\n```\n\nNow the malicious user can update the `id` input to the ID of a different post model. When the form is submitted and `update()` is called, `Post::findOrFail()` will return and update a post the user is not the owner of.\n\nTo prevent this kind of attack, we can use one or both of the following strategies:","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-54","text":"ollowing strategies:\n\n* Authorize the input\n* Lock the property from updates\n\n#### Authorizing the input\n\nBecause `$id` can be manipulated client-side with something like `wire:model`, just like in a controller, we can use [Laravel's authorization](https://laravel.com/docs/authorization) to make sure the current user can update the post:","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-55","text":"can update the post:\n\n```php\npublic function update()\n{\n    $post = Post::findOrFail($this->id);\n\n    $this->authorize('update', $post); // [tl! highlight]\n\n    $post->update(...);\n}\n```\n\nIf a malicious user mutates the `$id` property, the added authorization will catch it and throw an error.\n\n#### Locking the property","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-56","text":"Locking the property\n\nLivewire also allows you to \"lock\" properties in order to prevent properties from being modified on the client-side. You can \"lock\" a property from client-side manipulation using the `#[Locked]` attribute:\n\n```php\nuse Livewire\\Attributes\\Locked;\nuse Livewire\\Component;\n\nclass UpdatePost extends Component\n{\n    #[Locked] // [tl! highlight]\n    public $id;\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-57","text":"d;\n\n    // ...\n}\n```\n\nNow, if a user tries to modify `$id` on the front end, an error will be thrown.\n\nBy using `#[Locked]`, you can assume this property has not been manipulated anywhere outside your component's class.\n\nFor more information on locking properties, [consult the Locked properties documentation](/docs/locked).\n\n#### Eloquent models and locking","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-58","text":"t models and locking\n\nWhen an Eloquent model is assigned to a Livewire component property, Livewire will automatically lock the property and ensure the ID isn't changed, so that you are safe from these kinds of attacks:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-59","text":"use App\\Models\\Post;\n\nclass UpdatePost extends Component\n{\n    public Post $post; // [tl! highlight]\n    public $title;\n    public $content;\n\n    public function mount(Post $post)\n    {\n        $this->post = $post;\n        $this->title = $post->title;\n        $this->content = $post->content;\n    }","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-60","text":"post->content;\n    }\n\n    public function update()\n    {\n        $this->post->update([\n            'title' => $this->title,\n            'content' => $this->content,\n        ]);\n\n        session()->flash('message', 'Post updated successfully!');\n    }\n\n    public function render()\n    {\n        return view('livewire.update-post');\n    }\n}\n```\n\n### Properties expose system information to the browser","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-61","text":"ation to the browser\n\nAnother essential thing to remember is that Livewire properties are serialized or \"dehydrated\" before they are sent to the browser. This means that their values are converted to a format that can be sent over the wire and understood by JavaScript. This format can expose information about your application to the browser, including the names and class names of your properties.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-62","text":" of your properties.\n\nFor example, suppose you have a Livewire component that defines a public property named `$post`. This property contains an instance of a `Post` model from your database. In this case, the dehydrated value of this property sent over the wire might look something like this:","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-63","text":"something like this:\n\n```json\n{\n    \"type\": \"model\",\n    \"class\": \"App\\Models\\Post\",\n    \"key\": 1,\n    \"relationships\": []\n}\n```\n\nAs you can see, the dehydrated value of the `$post` property includes the class name of the model (`App\\Models\\Post`) as well as the ID and any relationships that have been eager-loaded.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-64","text":"e been eager-loaded.\n\nIf you don't want to expose the class name of the model, you can use Laravel's \"morphMap\" functionality from a service provider to assign an alias to a model class name:\n\n```php\n<?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-65","text":"\\Relations\\Relation;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    public function boot()\n    {\n        Relation::morphMap([\n            'post' => 'App\\Models\\Post',\n        ]);\n    }\n}\n```\n\nNow, when the Eloquent model is \"dehydrated\" (serialized), the original class name won't be exposed, only the \"post\" alias:","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-66","text":"ly the \"post\" alias:\n\n```json\n{\n    \"type\": \"model\",\n    \"class\": \"App\\Models\\Post\", // [tl! remove]\n    \"class\": \"post\", // [tl! add]\n    \"key\": 1,\n    \"relationships\": []\n}\n```\n\n### Eloquent constraints aren't preserved between requests","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-67","text":"ved between requests\n\nTypically, Livewire is able to preserve and recreate server-side properties between requests; however, there are certain scenarios where preserving values are impossible between requests.\n\nFor example, when storing Eloquent collections as Livewire properties, additional query constraints like `select(...)` will not be re-applied on subsequent requests.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-68","text":"subsequent requests.\n\nTo demonstrate, consider the following `ShowTodos` component with a `select()` constraint applied to the `Todos` Eloquent collection:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\n\nclass ShowTodos extends Component\n{\n    public $todos;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-69","text":"{\n    public $todos;\n\n    public function mount()\n    {\n        $this->todos = Auth::user()\n            ->todos()\n            ->select(['title', 'content']) // [tl! highlight]\n            ->get();\n    }\n\n    public function render()\n    {\n        return view('livewire.show-todos');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-70","text":"todos');\n    }\n}\n```\n\nWhen this component is initially loaded, the `$todos` property will be set to an Eloquent collection of the user's todos; however, only the `title` and `content` fields of each row in the database will have been queried and loaded into each of the models.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-71","text":" each of the models.\n\nWhen Livewire _hydrates_ the JSON of this property back into PHP on a subsequent request, the select constraint will have been lost.\n\nTo ensure the integrity of Eloquent queries, we recommend that you use [computed properties](/docs/computed-properties) instead of properties.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-72","text":"stead of properties.\n\nComputed properties are methods in your component marked with the `#[Computed]` attribute. They can be accessed as a dynamic property that isn't stored as part of the component's state but is instead evaluated on-the-fly.\n\nHere's the above example re-written using a computed property:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-73","text":"espace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Attributes\\Computed;\nuse Livewire\\Component;\n\nclass ShowTodos extends Component\n{\n    #[Computed] // [tl! highlight]\n    public function todos()\n    {\n        return Auth::user()\n            ->todos()\n            ->select(['title', 'content'])\n            ->get();\n    }","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-74","text":"      ->get();\n    }\n\n    public function render()\n    {\n        return view('livewire.show-todos');\n    }\n}\n```\n\nHere's how you would access these _todos_ from the Blade view:\n\n```blade\n<ul>\n    @foreach ($this->todos as $todo)\n        <li>{{ $todo }}</li>\n    @endforeach\n</ul>\n```\n\nNotice, inside your views, you can only access computed properties on the `$this` object like so: `$this->todos`.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-75","text":" so: `$this->todos`.\n\nYou can also access `$todos` from inside your class. For example, if you had a `markAllAsComplete()` action:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Attributes\\Computed;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-76","text":" Livewire\\Component;\n\nclass ShowTodos extends Component\n{\n    #[Computed]\n    public function todos()\n    {\n        return Auth::user()\n            ->todos()\n            ->select(['title', 'content'])\n            ->get();\n    }\n\n    public function markAllComplete() // [tl! highlight:3]\n    {\n        $this->todos->each->complete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-77","text":"h->complete();\n    }\n\n    public function render()\n    {\n        return view('livewire.show-todos');\n    }\n}\n```\n\nYou might wonder why not just call `$this->todos()` as a method directly where you need to? Why use `#[Computed]` in the first place?","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-78","text":" in the first place?\n\nThe reason is that computed properties have a performance advantage, since they are automatically cached after their first usage during a single request. This means you can freely access `$this->todos` within your component and be assured that the actual method will only be called once, so that you don't run an expensive query multiple times in the same request.","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"e7e4b22adacb9246e528603740e02719-79","text":"in the same request.\n\nFor more information, [visit the computed properties documentation](/docs/computed-properties).\n","source":"/Users/fyyx/Documents/livewire/docs/properties.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-0","text":"\nLivewire allows you to nest additional Livewire components inside of a parent component. This feature is immensely powerful, as it allows you to re-use and encapsulate behavior within Livewire components that are shared across your application.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-1","text":"ss your application.\n\n> [!warning] You might not need a Livewire component","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-2","text":"a Livewire component\n> Before you extract a portion of your template into a nested Livewire component, ask yourself: Does this content in this component need to be \"live\"? If not, we recommend that you create a simple [Blade component](https://laravel.com/docs/blade#components) instead","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-3","text":"#components) instead. Only create a Livewire component if the component benefits from Livewire's dynamic nature or if there is a direct performance benefit.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-4","text":"performance benefit.\n\nConsult our [in-depth, technical examination of Livewire component nesting](/docs/understanding-nesting) for more information on the performance, usage implications, and constraints of nested Livewire components.\n\n## Nesting a component","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-5","text":" Nesting a component\n\nTo nest a Livewire component within a parent component, simply include it in the parent component's Blade view. Below is an example of a `Dashboard` parent component that contains a nested `TodoList` component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-6","text":" Livewire\\Component;\n\nclass Dashboard extends Component\n{\n    public function render()\n    {\n        return view('livewire.dashboard');\n    }\n}\n```\n\n```blade\n<div>\n    <h1>Dashboard</h1>\n\n    <livewire:todo-list /> <!-- [tl! highlight] -->\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-7","text":"ight] -->\n</div>\n```\n","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-8","text":"ght] -->\n</div>\n```\n\nOn this page's initial render, the `Dashboard` component will encounter `<livewire:todo-list />` and render it in place. On a subsequent network request to `Dashboard`, the nested `todo-list` component will skip rendering because it is now its own independent component on the page","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-9","text":"omponent on the page. For more information on the technical concepts behind nesting and rendering, consult our documentation on why [nested components are \"islands\"](/docs/understanding-nesting#every-component-is-an-island).","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-10","text":"onent-is-an-island).\n\nFor more information about the syntax for rendering components, consult our documentation on [Rendering Components](/docs/components#rendering-components).\n\n## Passing props to children","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-11","text":"ng props to children\n\nPassing data from a parent component to a child component is straightforward. In fact, it's very much like passing props to a typical [Blade component](https://laravel.com/docs/blade#components).\n\nFor example, let's check out a `TodoList` component that passes a collection of `$todos` to a child component called `TodoCount`:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-12","text":"espace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\n\nclass TodoList extends Component\n{\n    public function render()\n    {\n        return view('livewire.todo-list', [\n            'todos' => Auth::user()->todos,\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    <livewire:todo-count :todos=\"$todos\" />\n\n    <!-- ... -->\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-13","text":"- ... -->\n</div>\n```\n\nAs you can see, we are passing `$todos` into `todo-count` with the syntax: `:todos=\"$todos\"`.\n\nNow that `$todos` has been passed to the child component, you can receive that data through the child component's `mount()` method:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Todo;\n\nclass TodoCount extends Component\n{\n    public $todos;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-14","text":"{\n    public $todos;\n\n    public function mount($todos)\n    {\n        $this->todos = $todos;\n    }\n\n    public function render()\n    {\n        return view('livewire.todo-count', [\n            'count' => $this->todos->count(),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-15","text":"     ]);\n    }\n}\n```\n\n> [!tip] Omit `mount()` as a shorter alternative\n> If the `mount()` method in above example feels like redundant boilerplate code to you, it can be omitted as long as the property and parameter names match:\n> ```php\n> public $todos; // [tl! highlight]\n> ```\n\n### Passing static props","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-16","text":"Passing static props\n\nIn the previous example, we passed props to our child component using Livewire's dynamic prop syntax, which supports PHP expressions like so:\n\n```blade\n<livewire:todo-count :todos=\"$todos\" />\n```\n\nHowever, sometimes you may want to pass a component a simple static value such as a string. In these cases, you may omit the colon from the beginning of the statement:","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-17","text":"ng of the statement:\n\n```blade\n<livewire:todo-count :todos=\"$todos\" label=\"Todo Count:\" />\n```\n\nBoolean values may be provided to components by only specifying the key. For example, to pass an `$inline` variable with a value of `true` to a component, we may simply place `inline` on the component tag:\n\n```blade\n<livewire:todo-count :todos=\"$todos\" inline />\n```\n\n### Shortened attribute syntax","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-18","text":"ned attribute syntax\n\nWhen passing PHP variables into a component, the variable name and the prop name are often the same. To avoid writing the name twice, Livewire allows you to simply prefix the variable with a colon:\n\n```blade\n<livewire:todo-count :todos=\"$todos\" /> <!-- [tl! remove] -->\n\n<livewire:todo-count :$todos /> <!-- [tl! add] -->\n```\n\n## Rendering children in a loop","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-19","text":"g children in a loop\n\nWhen rendering a child component within a loop, you should include a unique `key` value for each iteration.\n\nComponent keys are how Livewire tracks each component on subsequent renders, particularly if a component has already been rendered or if multiple components have been re-arranged on the page.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-20","text":"rranged on the page.\n\nYou can specify the component's key by specifying a `:key` prop on the child component:\n\n```blade\n<div>\n    <h1>Todos</h1>\n\n    @foreach ($todos as $todo)\n        <livewire:todo-item :$todo :key=\"$todo->id\" />\n    @endforeach\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-21","text":"ndforeach\n</div>\n```\n\nAs you can see, each child component will have a unique key set to the ID of each `$todo`. This ensures the key will be unique and tracked if the todos are re-ordered.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-22","text":"odos are re-ordered.\n\n> [!warning] Keys aren't optional\n> If you have used frontend frameworks like Vue or Alpine, you are familiar with adding a key to a nested element in a loop. However, in those frameworks, a key isn't _mandatory_, meaning the items will render, but a re-order might not be tracked properly. However, Livewire relies more heavily on keys and will behave incorrectly without them.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-23","text":"rectly without them.\n\n## Reactive props\n\nDevelopers new to Livewire expect that props are \"reactive\" by default. In other words, they expect that when a parent changes the value of a prop being passed into a child component, the child component will automatically be updated. However, by default, Livewire props are not reactive.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-24","text":"ps are not reactive.\n","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-25","text":"s are not reactive.\n\nWhen using Livewire, [every component is an island](/docs/understanding-nesting#every-component-is-an-island). This means that when an update is triggered on the parent and a network request is dispatched, only the parent component's state is sent to the server to re-render - not the child component's","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-26","text":"he child component's. The intention behind this behavior is to only send the minimal amount of data back and forth between the server and client, making updates as performant as possible.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-27","text":"formant as possible.\n\nBut, if you want or need a prop to be reactive, you can easily enable this behavior using the `#[Reactive]` attribute parameter.\n\nFor example, below is the template of a parent `TodoList` component. Inside, it is rendering a `TodoCount` component and passing in the current list of todos:\n\n```blade\n<div>\n    <h1>Todos:</h1>\n\n    <livewire:todo-count :$todos />","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-28","text":"odo-count :$todos />\n\n    <!-- ... -->\n</div>\n```\n\nNow let's add `#[Reactive]` to the `$todos` prop in the `TodoCount` component. Once we have done so, any todos that are added or removed inside the parent component will automatically trigger an update within the `TodoCount` component:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-29","text":"espace App\\Livewire;\n\nuse Livewire\\Attributes\\Reactive;\nuse Livewire\\Component;\nuse App\\Models\\Todo;\n\nclass TodoCount extends Component\n{\n    #[Reactive] // [tl! highlight]\n    public $todos;\n\n    public function render()\n    {\n        return view('livewire.todo-count', [\n            'count' => $this->todos->count(),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-30","text":"     ]);\n    }\n}\n```\n\nReactive properties are an incredibly powerful feature, making Livewire more similar to frontend component libraries like Vue and React. But, it is important to understand the performance implications of this feature and only add `#[Reactive]` when it makes sense for your particular scenario.\n\n## Binding to child data using `wire:model`","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-31","text":"a using `wire:model`\n\nAnother powerful pattern for sharing state between parent and child components is using `wire:model` directly on a child component via Livewire's `Modelable` feature.\n\nThis behavior is very commonly needed when extracting an input element into a dedicated Livewire component while still accessing its state in the parent component.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-32","text":"he parent component.\n\nBelow is an example of a parent `TodoList` component that contains a `$todo` property which tracks the current todo about to be added by a user:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Todo;\n\nclass TodoList extends Component\n{\n    public $todo = '';","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-33","text":"  public $todo = '';\n\n    public function add()\n    {\n        Todo::create([\n            'content' => $this->pull('todo'),\n        ]);\n    }\n\n    public function render()\n    {\n        return view('livewire.todo-list', [\n            'todos' => Auth::user()->todos,\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-34","text":"     ]);\n    }\n}\n```\n\nAs you can see in the `TodoList` template, `wire:model` is being used to bind the `$todo` property directly to a nested `TodoInput` component:\n\n```blade\n<div>\n    <h1>Todos</h1>\n\n    <livewire:todo-input wire:model=\"todo\" /> <!-- [tl! highlight] -->\n\n    <button wire:click=\"add\">Add Todo</button>","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-35","text":"d\">Add Todo</button>\n\n    <div>\n        @foreach ($todos as $todo)\n            <livewire:todo-item :$todo :key=\"$todo->id\" />\n        @endforeach\n    </div>\n</div>\n```\n\nLivewire provides a `#[Modelable]` attribute you can add to any child component property to make it _modelable_ from a parent component.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-36","text":" a parent component.\n\nBelow is the `TodoInput` component with the `#[Modelable]` attribute added above the `$value` property to signal to Livewire that if `wire:model` is declared on the component by a parent it should bind to this property:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse Livewire\\Attributes\\Modelable;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-37","text":"ttributes\\Modelable;\n\nclass TodoInput extends Component\n{\n    #[Modelable] // [tl! highlight]\n    public $value = '';\n\n    public function render()\n    {\n        return view('livewire.todo-input');\n    }\n}\n```\n\n```blade\n<div>\n    <input type=\"text\" wire:model=\"value\" >\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-38","text":"\"value\" >\n</div>\n```\n\nNow the parent `TodoList` component can treat `TodoInput` like any other input element and bind directly to its value using `wire:model`.\n\n> [!warning]\n> Currently Livewire only supports a single `#[Modelable]` attribute, so only the first one will be bound.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-39","text":"t one will be bound.\n\n\n## Listening for events from children\n\nAnother powerful parent-child component communication technique is Livewire's event system, which allows you to dispatch an event on the server or client that can be intercepted by other components.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-40","text":"by other components.\n\nOur [complete documentation on Livewire's event system](/docs/events) provides more detailed information on events, but below we'll discuss a simple example of using an event to trigger an update in a parent component.\n\nConsider a `TodoList` component with functionality to show and remove todos:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-41","text":"espace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Todo;\n\nclass TodoList extends Component\n{\n    public function remove($todoId)\n    {\n        $todo = Todo::find($todoId);\n\n        $this->authorize('delete', $todo);\n\n        $todo->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-42","text":"odo->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.todo-list', [\n            'todos' => Auth::user()->todos,\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    @foreach ($todos as $todo)\n        <livewire:todo-item :$todo :key=\"$todo->id\" />\n    @endforeach\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-43","text":"ndforeach\n</div>\n```\n\nTo call `remove()` from inside the child `TodoItem` components, you can add an event listener to `TodoList` via the `#[On]` attribute:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Todo;\nuse Livewire\\Attributes\\On;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-44","text":"ewire\\Attributes\\On;\n\nclass TodoList extends Component\n{\n    #[On('remove-todo')] // [tl! highlight]\n    public function remove($todoId)\n    {\n        $todo = Todo::find($todoId);\n\n        $this->authorize('delete', $todo);\n\n        $todo->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-45","text":"odo->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.todo-list', [\n            'todos' => Auth::user()->todos,\n        ]);\n    }\n}\n```\n\nOnce the attribute has been added to the action, you can dispatch the `remove-todo` event from the `TodoList` child component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Todo;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-46","text":"use App\\Models\\Todo;\n\nclass TodoItem extends Component\n{\n    public Todo $todo;\n\n    public function remove()\n    {\n        $this->dispatch('remove-todo', todoId: $this->todo->id); // [tl! highlight]\n    }\n\n    public function render()\n    {\n        return view('livewire.todo-item');\n    }\n}\n```\n\n```blade\n<div>\n    <span>{{ $todo->content }}</span>","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-47","text":"o->content }}</span>\n\n    <button wire:click=\"remove\">Remove</button>\n</div>\n```\n\nNow when the \"Remove\" button is clicked inside a `TodoItem`, the parent `TodoList` component will intercept the dispatched event and perform the todo removal.\n\nAfter the todo is removed in the parent, the list will be re-rendered and the child that dispatched the `remove-todo` event will be removed from the page.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-48","text":"moved from the page.\n\n### Improving performance by dispatching client-side\n\nThough the above example works, it takes two network requests to perform a single action:","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-49","text":"orm a single action:\n\n1. The first network request from the `TodoItem` component triggers the `remove` action, dispatching the `remove-todo` event.\n2. The second network request is after the `remove-todo` event is dispatched client-side and is intercepted by `TodoList` to call its `remove` action.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-50","text":"its `remove` action.\n\nYou can avoid the first request entirely by dispatching the `remove-todo` event directly on the client-side. Below is an updated `TodoItem` component that does not trigger a network request when dispatching the `remove-todo` event:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Todo;\n\nclass TodoItem extends Component\n{\n    public Todo $todo;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-51","text":"  public Todo $todo;\n\n    public function render()\n    {\n        return view('livewire.todo-item');\n    }\n}\n```\n\n```blade\n<div>\n    <span>{{ $todo->content }}</span>\n\n    <button wire:click=\"$dispatch('remove-todo', { todoId: {{ $todo->id }} })\">Remove</button>\n</div>\n```\n\nAs a rule of thumb, always prefer dispatching client-side when possible.\n\n## Directly accessing the parent from the child","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-52","text":"arent from the child\n\nEvent communication adds a layer of indirection. A parent can listen for an event that never gets dispatched from a child, and a child can dispatch an event that is never intercepted by a parent.\n\nThis indirection is sometimes desirable; however, in other cases you may prefer to access a parent component directly from the child component.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-53","text":"the child component.\n\nLivewire allows you to accomplish this by providing a magic `$parent` variable to your Blade template that you can use to access actions and properties directly from the child. Here's the above `TodoItem` template rewritten to call the `remove()` action directly on the parent via the magic `$parent` variable:\n\n```blade\n<div>\n    <span>{{ $todo->content }}</span>","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-54","text":"o->content }}</span>\n\n    <button wire:click=\"$parent.remove({{ $todo->id }})\">Remove</button>\n</div>\n```\n\nEvents and direct parent communication are a few of the ways to communicate back and forth between parent and child components. Understanding their tradeoffs enables you to make more informed decisions about which pattern to use in a particular scenario.\n\n## Dynamic child components","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-55","text":"mic child components\n\nSometimes, you may not know which child component should be rendered on a page until run-time. Therefore, Livewire allows you to choose a child component at run-time via `<livewire:dynamic-component ...>`, which receives an `:is` prop:\n\n```blade\n<livewire:dynamic-component :is=\"$current\" />\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-56","text":"is=\"$current\" />\n```\n\nDynamic child components are useful in a variety of different scenarios, but below is an example of rendering different steps in a multi-step form using a dynamic component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass Steps extends Component\n{\n    public $current = 'step-one';","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-57","text":"urrent = 'step-one';\n\n    protected $steps = [\n        'step-one',\n        'step-two',\n        'step-three',\n    ];\n\n    public function next()\n    {\n        $currentIndex = array_search($this->current, $this->steps);\n\n        $this->current = $this->steps[$currentIndex + 1];\n    }\n\n    public function render()\n    {\n        return view('livewire.todo-list');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-58","text":"-list');\n    }\n}\n```\n\n```blade\n<div>\n    <livewire:dynamic-component :is=\"$current\" :key=\"$current\" />\n\n    <button wire:click=\"next\">Next</button>\n</div>\n```\n\nNow, if the `Steps` component's `$current` prop is set to \"step-one\", Livewire will render a component named \"step-one\" like so:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-59","text":" Livewire\\Component;\n\nclass StepOne extends Component\n{\n    public function render()\n    {\n        return view('livewire.step-one');\n    }\n}\n```\n\nIf you prefer, you can use the alternative syntax:\n\n```blade\n<livewire:is :component=\"$current\" :key=\"$current\" />\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-60","text":"ey=\"$current\" />\n```\n\n> [!warning]\n> Don't forget to assign each child component a unique key. Although Livewire automatically generates a key for `<livewire:dynamic-child />` and `<livewire:is />`, that same key will apply to _all_ your child components, meaning subsequent renders will be skipped.\n> ","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-61","text":" will be skipped.\n> \n> See [forcing a child component to re-render](#forcing-a-child-component-to-re-render) for a deeper understanding of how keys affect component rendering.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-62","text":"component rendering.\n\n## Recursive components\n\nAlthough rarely needed by most applications, Livewire components may be nested recursively, meaning a parent component renders itself as its child.\n\nImagine a survey which contains a `SurveyQuestion` component that can have sub-questions attached to itself:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Question;","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-63","text":"App\\Models\\Question;\n\nclass SurveyQuestion extends Component\n{\n    public Question $question;\n\n    public function render()\n    {\n        return view('livewire.survey-question', [\n            'subQuestions' => $this->question->subQuestions,\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    Question: {{ $question->content }}","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-64","text":"question->content }}\n\n    @foreach ($subQuestions as $subQuestion)\n        <livewire:survey-question :question=\"$subQuestion\" :key=\"$subQuestion->id\" />\n    @endforeach\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-65","text":"ndforeach\n</div>\n```\n\n> [!warning]\n> Of course, the standard rules of recursion apply to recursive components. Most importantly, you should have logic in your template to ensure the template doesn't recurse indefinitely. In the example above, if a `$subQuestion` contained the original question as its own `$subQuestion`, an infinite loop would occur.\n\n## Forcing a child component to re-render","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-66","text":"mponent to re-render\n\nBehind the scenes, Livewire generates a key for each nested Livewire component in its template.\n\nFor example, consider the following nested `todo-count` component:\n\n```blade\n<div>\n    <livewire:todo-count :$todos />\n</div>\n```\n\nLivewire internally attaches a random string key to the component like so:\n\n```blade\n<div>\n    <livewire:todo-count :$todos key=\"lska\" />\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-67","text":"\"lska\" />\n</div>\n```\n\nWhen the parent component is rendering and encounters a child component like the above, it stores the key in a list of children attached to the parent:\n\n```php\n'children' => ['lska'],\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-68","text":"en' => ['lska'],\n```\n","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-69","text":"n' => ['lska'],\n```\n\nLivewire uses this list for reference on subsequent renders in order to detect if a child component has already been rendered in a previous request. If it has already been rendered, the component is skipped. Remember, [nested components are islands](/docs/understanding-nesting#every-component-is-an-island)","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-70","text":"ponent-is-an-island). However, if the child key is not in the list, meaning it hasn't been rendered already, Livewire will create a new instance of the component and render it in place.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-71","text":" render it in place.\n\nThese nuances are all behind-the-scenes behavior that most users don't need to be aware of; however, the concept of setting a key on a child is a powerful tool for controlling child rendering.\n\nUsing this knowledge, if you want to force a component to re-render, you can simply change its key.","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-72","text":"mply change its key.\n\nBelow is an example where we might want to destroy and re-initialize the `todo-count` component if the `$todos` being passed to the component are changed:\n\n```blade\n<div>\n    <livewire:todo-count :todos=\"$todos\" :key=\"$todos->pluck('id')->join('-')\" />\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"f21db8a14228b1b1700e9a421db9065f-73","text":"('-')\" />\n</div>\n```\n\nAs you can see above, we are generating a dynamic `:key` string based on the content of `$todos`. This way, the `todo-count` component will render and exist as normal until the `$todos` themselves change. At that point, the component will be re-initialized entirely from scratch, and the old component will be discarded.\n","source":"/Users/fyyx/Documents/livewire/docs/nesting.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-0","text":"\nIn a traditional HTML page containing a form, the form is only ever submitted when the user presses the \"Submit\" button.\n\nHowever, Livewire is capable of much more than traditional form submissions. You can validate form inputs in real-time or even save the form as a user types.","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-1","text":"orm as a user types.\n\nIn these \"real-time\" update scenarios, it can be helpful to signal to your users when a form or subset of a form has been changed, but hasn't been saved to the database.\n\nWhen a form contains un-saved input, that form is considered \"dirty\". It only becomes \"clean\" when a network request has been triggered to synchronize the server state with the client-side state.","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-2","text":"e client-side state.\n\n## Basic usage\n\nLivewire allows you to easily toggle visual elements on the page using the `wire:dirty` directive.\n\nBy adding `wire:dirty` to an element, you are instructing Livewire to only show the element when the client-side state diverges from the server-side state.","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-3","text":"e server-side state.\n\nTo demonstrate, here is an example of an `UpdatePost` form containing a visual \"Unsaved changes...\" indication that signals to the user that the form contains input that has not been saved:\n\n```blade\n<form wire:submit=\"update\">\n    <input type=\"text\" wire:model=\"title\">\n\n    <!-- ... -->\n\n    <button type=\"submit\">Update</button>","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-4","text":"mit\">Update</button>\n\n    <div wire:dirty>Unsaved changes...</div> <!-- [tl! highlight] -->\n</form>\n```\n\nBecause `wire:dirty` has been added to the \"Unsaved changes...\" message, the message will be hidden by default. Livewire will automatically display the message when the user starts modifying the form inputs.","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-5","text":"ing the form inputs.\n\nWhen the user submits the form, the message will disappear again, since the server / client data is back in sync.\n\n### Removing elements\n\nBy adding the `.remove` modifier to `wire:dirty`, you can instead show an element by default and only hide it when the component has \"dirty\" state:\n\n```blade\n<div wire:dirty.remove>The data is in-sync...</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-6","text":"in-sync...</div>\n```\n\n## Targeting property updates\n\nImagine you are using `wire:model.blur` to update a property on the server immediately after a user leaves an input field. In this scenario, you can provide a \"dirty\" indication for only that property by adding `wire:target` to the element that contains the `wire:dirty` directive.","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-7","text":"re:dirty` directive.\n\nHere is an example of only showing a dirty indication when the title property has been changed:\n\n```blade\n<form wire:submit=\"update\">\n    <input wire:model.blur=\"title\">\n\n    <div wire:dirty wire:target=\"title\">Unsaved title...</div> <!-- [tl! highlight] -->\n\n    <button type=\"submit\">Update</button>\n</form>\n```\n\n## Toggling classes","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-8","text":"\n## Toggling classes\n\nOften, instead of toggling entire elements, you may want to toggle individual CSS classes on an input when its state is \"dirty\".\n\nBelow is an example where a user types into an input field and the border becomes yellow, indicating an \"unsaved\" state. Then, when the user tabs away from the field, the border is removed, indicating that the state has been saved on the server:","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"84aca45a8fbeaee6f564ea94b9496a48-9","text":"saved on the server:\n\n```blade\n<input wire:model.blur=\"title\" wire:dirty.class=\"border-yellow-500\">\n```\n\n","source":"/Users/fyyx/Documents/livewire/docs/dirty.md"}
{"id":"7e0b64e6b1cb0dc0a1293dc99dc9c5ce-0","text":"\nLivewire's `wire:show` directive makes it easy to show and hide elements based on the result of an expression.","source":"/Users/fyyx/Documents/livewire/docs/wire-show.md"}
{"id":"7e0b64e6b1cb0dc0a1293dc99dc9c5ce-1","text":"lt of an expression.\n\nThe `wire:show` directive is different than using `@if` in Blade in that it toggles an element's visibility using CSS (`display: none`) rather than removing the element from the DOM entirely. This means the element remains in the page but is hidden, allowing for smoother transitions without requiring a server round-trip.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/wire-show.md"}
{"id":"7e0b64e6b1cb0dc0a1293dc99dc9c5ce-2","text":"rip.\n\n## Basic usage\n\nHere's a practical example of using `wire:show` to toggle a \"Create Post\" modal:\n\n```php\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    public $showModal = false;\n\n    public $content = '';\n\n    public function save()\n    {\n        Post::create(['content' => $this->content]);\n\n        $this->reset('content');","source":"/Users/fyyx/Documents/livewire/docs/wire-show.md"}
{"id":"7e0b64e6b1cb0dc0a1293dc99dc9c5ce-3","text":"s->reset('content');\n\n        $this->showModal = false;\n    }\n}\n```\n\n```blade\n<div>\n    <button x-on:click=\"$wire.showModal = true\">New Post</button>\n\n    <div wire:show=\"showModal\">\n        <form wire:submit=\"save\">\n            <textarea wire:model=\"content\"></textarea>\n\n            <button type=\"submit\">Save Post</button>\n        </form>\n    </div>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-show.md"}
{"id":"7e0b64e6b1cb0dc0a1293dc99dc9c5ce-4","text":"   </div>\n</div>\n```\n\nWhen the \"Create New Post\" button is clicked, the modal appears without a server roundtrip. After successfully saving the post, the modal is hidden and the form is reset.\n\n## Using transitions","source":"/Users/fyyx/Documents/livewire/docs/wire-show.md"}
{"id":"7e0b64e6b1cb0dc0a1293dc99dc9c5ce-5","text":"## Using transitions\n\nYou can combine `wire:show` with Alpine.js transitions to create smooth show/hide animations. Since `wire:show` only toggles the CSS `display` property, Alpine's `x-transition` directives work perfectly with it:\n\n```blade\n<div>\n    <button x-on:click=\"$wire.showModal = true\">New Post</button>","source":"/Users/fyyx/Documents/livewire/docs/wire-show.md"}
{"id":"7e0b64e6b1cb0dc0a1293dc99dc9c5ce-6","text":"e\">New Post</button>\n\n    <div wire:show=\"showModal\" x-transition.duration.500ms>\n        <form wire:submit=\"save\">\n            <textarea wire:model=\"content\"></textarea>\n            <button type=\"submit\">Save Post</button>\n        </form>\n    </div>\n</div>\n```\n\nThe Alpine.js transition classes above will create a fade and scale effect when the modal shows and hides.","source":"/Users/fyyx/Documents/livewire/docs/wire-show.md"}
{"id":"7e0b64e6b1cb0dc0a1293dc99dc9c5ce-7","text":"dal shows and hides.\n\n[View the full x-transition documentation →](https://alpinejs.dev/directives/transition)\n","source":"/Users/fyyx/Documents/livewire/docs/wire-show.md"}
{"id":"aca55914ef22855f9ca46dcd22d2e0c8-0","text":"Livewire allows you to _teleport_ part of your template to another part of the DOM on the page entirely.","source":"/Users/fyyx/Documents/livewire/docs/teleport.md"}
{"id":"aca55914ef22855f9ca46dcd22d2e0c8-1","text":"n the page entirely.\n\nThis is useful for things like nested dialogs. When nesting one dialog inside of another, the z-index of the parent modal is applied to the nested modal. This can cause problems with styling backdrops and overlays. To avoid this problem, you can use Livewire's `@teleport` directive to render each nested modal as siblings in the rendered DOM.","source":"/Users/fyyx/Documents/livewire/docs/teleport.md"}
{"id":"aca55914ef22855f9ca46dcd22d2e0c8-2","text":"in the rendered DOM.\n\nThis functionality is powered by [Alpine's `x-teleport` directive](https://alpinejs.dev/directives/teleport).\n\n## Basic usage\n\nTo _teleport_ a portion of your template to another part of the DOM, you can wrap it in Livewire's `@teleport` directive.\n\nBelow is an example of using `@teleport` to render a modal dialog's contents at the end of the `<body>` element on the page:","source":"/Users/fyyx/Documents/livewire/docs/teleport.md"}
{"id":"aca55914ef22855f9ca46dcd22d2e0c8-3","text":"element on the page:\n\n```blade\n<div>\n    <!-- Modal -->\n    <div x-data=\"{ open: false }\">\n        <button @click=\"open = ! open\">Toggle Modal</button>\n\n        @teleport('body')\n            <div x-show=\"open\">\n                Modal contents...\n            </div>\n        @endteleport\n    </div>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/teleport.md"}
{"id":"aca55914ef22855f9ca46dcd22d2e0c8-4","text":"   </div>\n</div>\n```\n\n> [!info]\n> The `@teleport` selector can be any string you would normally pass into something like `document.querySelector()`.\n>\n> You can learn more about `document.querySelector()` by consulting its [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector).","source":"/Users/fyyx/Documents/livewire/docs/teleport.md"}
{"id":"aca55914ef22855f9ca46dcd22d2e0c8-5","text":"ment/querySelector).\n\nNow, when the above Livewire template is rendered on the page, the _contents_ portion of the modal will be rendered at the end of `<body>`:\n\n```html\n<body>\n    <!-- ... -->\n\n    <div x-show=\"open\">\n        Modal contents...\n    </div>\n</body>\n```","source":"/Users/fyyx/Documents/livewire/docs/teleport.md"}
{"id":"aca55914ef22855f9ca46dcd22d2e0c8-6","text":"  </div>\n</body>\n```\n\n> [!warning] You must teleport outside the component\n> Livewire only supports teleporting HTML outside your components. For example, teleporting a modal to the `<body>` tag is fine, but teleporting it to another element within your component will not work.","source":"/Users/fyyx/Documents/livewire/docs/teleport.md"}
{"id":"aca55914ef22855f9ca46dcd22d2e0c8-7","text":"onent will not work.\n\n> [!warning] Teleporting only works with a single root element\n> Make sure you only include a single root element inside your `@teleport` statement.\n","source":"/Users/fyyx/Documents/livewire/docs/teleport.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-0","text":"Livewire properties are able to be modified freely on both the frontend and backend using utilities like `wire:model`. If you want to prevent a property — like a model ID — from being modified on the frontend, you can use Livewire's `#[Locked]` attribute.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-1","text":"ute.\n\n## Basic usage\n\nBelow is a `ShowPost` component that stores a `Post` model's ID as a public property named `$id`. To keep this property from being modified by a curious or malicious user, you can add the `#[Locked]` attribute to the property:","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-2","text":"ute to the property:\n\n> [!warning] Make sure you import attribute classes\n> Make sure you import any attribute classes. For example, the below `#[Locked]` attribute requires the following import `use Livewire\\Attributes\\Locked;`.\n\n```php\nuse Livewire\\Attributes\\Locked;\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n\t#[Locked] // [tl! highlight]\n    public $id;","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-3","text":"ght]\n    public $id;\n\n    public function mount($postId)\n    {\n        $this->id = $postId;\n    }\n\n\t// ...\n}\n```\n\nBy adding the `#[Locked]` attribute, you are ensured that the `$id` property will never be tampered with.","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-4","text":"er be tampered with.\n\n> [!tip] Model properties are secure by default\n> If you store an Eloquent model in a public property instead of just the model's ID, Livewire will ensure the ID isn't tampered with, without you needing to explicitly add the `#[Locked]` attribute to the property. For most cases, this is a better approach than using `#[Locked]`:\n> ```php\n> class ShowPost extends Component\n> {","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-5","text":"xtends Component\n> {\n>    public Post $post; // [tl! highlight]\n>\n>    public function mount($postId)\n>    {\n>        $this->post = Post::find($postId);\n>    }\n>\n>\t// ...\n>}\n> ```","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-6","text":"\n>\n>\t// ...\n>}\n> ```\n\n### Why not use protected properties?\n\nYou might ask yourself: why not just use protected properties for sensitive data?","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-7","text":" for sensitive data?\n\nRemember, Livewire only persists public properties between network requests. For static, hard-coded data, protected properties are suitable. However, for data that is stored at runtime, you must use a public property to ensure that the data is persisted properly.\n\n### Can't Livewire do this automatically?","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-8","text":" this automatically?\n\nIn a perfect world, Livewire would lock properties by default, and only allow modifications when `wire:model` is used on that property.\n\nUnfortunately, that would require Livewire to parse all of your Blade templates to understand if a property is modified by `wire:model` or a similar API.","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"425a7102f6e04f1befb6922c5745fdc2-9","text":"l` or a similar API.\n\nNot only would that add technical and performance overhead, it would be impossible to detect if a property is mutated by something like Alpine or any other custom JavaScript.\n\nTherefore, Livewire will continue to make public properties freely mutable by default and give developers the tools to lock them as needed.\n","source":"/Users/fyyx/Documents/livewire/docs/locked.md"}
{"id":"ef4a9d4597795ce84aa67c3222fd0caf-0","text":"\n* CreatePost\n* UpdatePost\n* ShowPosts\n* SearchPosts\n* TodoList","source":"/Users/fyyx/Documents/livewire/docs/rules/examples.md"}
{"id":"ed28cbeda9a2afbdfb1e661d8f5f4ae0-0","text":"A: \"When run, Livewire will create a new file in your app, `app/Livewire/CreatePost.php`, with the following contents:\"\n\nB: \"When run, Livewire will create a new `app/Livewire/CreatePost.php` file in your app, with the following contents:\"\n\nC: \"When run, Livewire will create a file called `app/Livewire/CreatePost.php`, with the following contents:\"\n\nC is preferred\n","source":"/Users/fyyx/Documents/livewire/docs/rules/Referencing file names in a sentance.md"}
{"id":"7892f1d6e40f0c9ba4b6dea745b71d25-0","text":"Title case: \"This Is A Title\"\nSentance case: \"This is a sentance.\"\nBullet case: \"This is a bullet\"\n","source":"/Users/fyyx/Documents/livewire/docs/rules/Casing rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-0","text":"> When do you start a file with \"< ?php\"\n\n> Always use tailwind in examples?  \n\n> Use active voice.\n\n> Use second-person singular (\"You\")\n\n> Sometimes you can introduce a concept with first-person plural (\"We\") and switch to \"You\" when giving step-by-step instructions\n\n> Always include import statements \n\n> Be consistent, but switch it up (tone, filler transition text, using colons)","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-1","text":" text, using colons)\n\n> Optimize for skimming (don't show \"wrong\" example first unless you have visual aid. People ain't reading the words: this is wrong up-front)","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-2","text":"s is wrong up-front)\n\n\n[[Referencing file names in a sentence]]\n[[Casing rules]]","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-3","text":"e]]\n[[Casing rules]]","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-4","text":"e]]\n[[Casing rules]]\n\n\n* Start with H2's, H1 will be the title of the page\n* Have good syntax highlighting, use Torchlight\n* Have good typography, use \"prose\" from tailwind\n* Write code examples first, then structure, then links and inlines, THEN paragraphs\n* Repeat yourself\n    * Write for a user to enter in anywhere and have context.\n* Concept of \"beginning to end\"","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-5","text":"f \"beginning to end\"\n    * Using \"We\" at beginning and transitioning to \"You\"\n    * Using more full code examples at the beginning","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-6","text":"les at the beginning\n\n\n\n\nBlocks:\n* line break\n* tips\n* warnings\n* \"go here to learn more\"\n* check out the screencast here\n* Footer with more links\n\n### Order by:\n* Order from \"generic\" to \"specific\" (broad/niche)\n* Order from happy path to edge cases (or commonness of needs/usage)\n* Need for previous knowledge (one section might rely on another earlier section)","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-7","text":"her earlier section)\n\n## Group by:\n* Type of thing:\n    * ex. `wire:loading.class` is extremely popular. `wire:loading.attr` is not, however it should be placed immediately after `.class` because it's so popular","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"e96774230075dcbaeb894eedab4970cd-8","text":"ause it's so popular\n\n\n","source":"/Users/fyyx/Documents/livewire/docs/rules/rules.md"}
{"id":"d1a8f3a84305f7e4c699e6402e6cac67-0","text":"* What to use as a dummy URL: \n    * ? `https://application.test/?page=2`","source":"/Users/fyyx/Documents/livewire/docs/rules/questions.md"}
{"id":"6fc34c635d996435bd1c050da405a767-0","text":"\n* The component\n    * Counter component\n* Rendering the component\n    * Mount\n        * New up class\n        * Dehydrate state\n        * Embed inside HTML\n        * Return HTML\n* Initializing the component in JS\n    * Finding wire:id elements\n    * Extracting id and snapshot\n    * Newing up object\n* Sending an update\n    * Registering event listeners","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-1","text":"ring event listeners\n    * Sending a fetch request with updates and snapshot\n* Receiving an update\n    * Converting snapshot to component (hydrate)\n    * Applying updates\n    * Rendering component\n    * Returning HTML and new snapshot\n* Processing an update\n    * Replacing with new snapshot\n    * Replacing HTML with new HTML\n        * Morphing","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-2","text":"L\n        * Morphing\n\n## The component\n\n```php\n<?php\n\nuse Livewire\\Component;\n\nclass Counter extends Component\n{\n    public $count = 1;\n\n    public function increment()\n    {\n        $this->count++;\n    }\n\n    public function render()\n    {\n        return view('livewire.counter');\n    }\n}\n```\n\n```blade\n<div>\n    <button wire:click=\"increment\">Increment</button>","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-3","text":"\">Increment</button>\n\n    <span>{{ $count }}</span>\n</div>\n```\n\n## Rendering the component\n\n```blade\n<livewire:counter />\n```\n\n```php\n<?php echo Livewire::mount('counter'); ?>\n```\n\n```php\npublic function mount($name)\n{\n    $class = Livewire::getComponentClassByName();\n\n    $component = new $class;\n\n    $id = str()->random(20);\n\n    $component->setId($id);\n\n    $data = $component->getData();","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-4","text":"omponent->getData();\n\n    $view = $component->render();\n\n    $html = $view->render($data);\n\n    $snapshot = [\n        'data' => $data,\n        'memo' => [\n            'id' => $component->getId(),\n            'name' => $component->getName(),\n        ]\n    ];\n\n    return Livewire::embedSnapshotInsideHtml($html, $snapshot);\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-5","text":"l, $snapshot);\n}\n```\n\n```blade\n<div wire:id=\"123456789\" wire:snapshot=\"{ data: { count: 0 }, memo: { 'id': '123456789', 'name': 'counter' }\">\n    <button wire:click=\"increment\">Increment</button>\n\n    <span>1</span>\n</div>\n```\n\n## JavaScript initialization\n\n```js\nlet el = document.querySelector('wire\\\\:id')","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-6","text":"elector('wire\\\\:id')\n\nlet id = el.getAttribute('wire:id')\nlet jsonSnapshot = el.getAttribute('wire:snapshot')\nlet snapshot = JSON.parse(jsonSnapshot)\n\nlet component = { id, snapshot }\n\nwalk(el, el => {\n    el.hasAttribute('wire:click') {\n        let action = el.getAttribute('wire:click')","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-7","text":"ribute('wire:click')\n\n        el.addEventListener('click', e => {\n            updateComponent(el, component, action)\n        })\n    }\n})","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-8","text":"\n        })\n    }\n})\n\nfunction updateComponent(el, component, action) {\n    let response fetch('/livewire/update', {\n        body: JSON.stringify({\n            \"snapshot\": snapshot,\n            \"calls\": [\n                [\"method\": action, \"params\": []],\n            ]\n        })\n    })\n\n    // To be continued...\n}\n```\n\n## Receiving an update","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-9","text":" Receiving an update\n\n```php\nRoute::post('/livewire/update', function () {\n    $snapshot = request('snapshot');\n    $calls = request('calls');\n\n    $component = Livewire::fromSnapshot($snapshot);\n\n    foreach ($calls as $call) {\n        $component->{$call['method']}(...$call['params']);\n    }\n\n    [$html, $snapshot] = Livewire::snapshot($component);","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-10","text":"napshot($component);\n\n    return [\n        'snapshot' => $snapshot,\n        'html' => $html,\n    ];\n});\n```\n\n## Handling an update","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-11","text":"# Handling an update\n\n```js\nfunction updateComponent(el, component, action) {\n    fetch('/livewire/update', {\n        body: JSON.stringify({\n            \"snapshot\": snapshot,\n            \"calls\": [\n                [\"method\": action, \"params\": []],\n            ]\n        })\n    }).then(i => i.json()).then(response => {\n        let { html, snapshot } = response\n\n        component.snapshot = snapshot","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"6fc34c635d996435bd1c050da405a767-12","text":".snapshot = snapshot\n\n        el.outerHTML = html\n    })\n}\n```\n\n","source":"/Users/fyyx/Documents/livewire/docs/how-livewire-works.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-0","text":"Hi there and welcome to the Livewire contribution guide. In this guide, we are going to take a look at how you can contribute to Livewire by submitting new features, fixing failing tests, or resolving bugs.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-1","text":", or resolving bugs.\n\n## Setting up Livewire and Alpine locally\nTo contribute, the easiest way is to ensure that the Livewire and Alpine repositories are set up on your local machine. This will allow you to make changes and run the test suite with ease.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-2","text":"est suite with ease.\n\n### Forking and cloning the repositories\nTo get started, the first step is to fork and clone the repositories. The easiest way to do this is by using the [GitHub CLI](https://cli.github.com/), but you can also perform these steps manually by clicking the \"Fork\" button on the GitHub [repository page](https://github.com/livewire/livewire).","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-3","text":"/livewire/livewire).\n\n```shell\n# Fork and clone Livewire\ngh repo fork livewire/livewire --default-branch-only --clone=true --remote=false -- livewire\n\n# Switch the working directory to livewire\ncd livewire\n\n# Install all composer dependencies\ncomposer install\n\n# Ensure Dusk is correctly configured\nvendor/bin/dusk-updater detect --no-interaction\n```","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-4","text":"--no-interaction\n```\n\nTo set up Alpine, make sure you have [NPM](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) installed, and then run the following commands. If you prefer to fork manually, you can visit the [repository page](https://github.com/alpinejs/alpine).","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-5","text":"om/alpinejs/alpine).\n\n```shell\n# Fork and clone Alpine\ngh repo fork alpinejs/alpine --default-branch-only --clone=true --remote=false -- alpine\n\n# Switch the working directory to alpine\ncd alpine\n\n# Install all npm dependencies\nnpm install\n\n# Build all Alpine packages\nnpm run build","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-6","text":"ckages\nnpm run build\n\n# Link all Alpine packages locally\ncd packages/alpinejs && npm link && cd ../../\ncd packages/anchor && npm link && cd ../../\ncd packages/collapse && npm link && cd ../../\ncd packages/csp && npm link && cd ../../\ncd packages/docs && npm link && cd ../../\ncd packages/focus && npm link && cd ../../\ncd packages/history && npm link && cd ../../","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-7","text":"pm link && cd ../../\ncd packages/intersect && npm link && cd ../../\ncd packages/mask && npm link && cd ../../\ncd packages/morph && npm link && cd ../../\ncd packages/navigate && npm link && cd ../../\ncd packages/persist && npm link && cd ../../\ncd packages/sort && npm link && cd ../../\ncd packages/ui && npm link && cd ../../","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-8","text":"pm link && cd ../../\n\n# Switch the working directory back to livewire\ncd ../livewire\n\n# Link all packages\nnpm link alpinejs @alpinejs/anchor @alpinejs/collapse @alpinejs/csp @alpinejs/docs @alpinejs/focus @alpinejs/history @alpinejs/intersect @alpinejs/mask @alpinejs/morph @alpinejs/navigate @alpinejs/persist @alpinejs/sort @alpinejs/ui\n\n# Build Livewire\nnpm run build\n```","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-9","text":"re\nnpm run build\n```\n\n## Contributing a Failing Test","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-10","text":"uting a Failing Test\n","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-11","text":"ting a Failing Test\n\nIf you're encountering a bug and are unsure about how to solve it, especially given the complexity of the Livewire core, you might be wondering where to start. In such cases, the easiest approach is to contribute a failing test. This way, someone with more experience can assist in identifying and fixing the bug","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-12","text":"g and fixing the bug. Nonetheless, we do recommend that you also explore the core to gain a better understanding of how Livewire operates.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-13","text":"w Livewire operates.\n\nLet's take a step-by-step approach.\n\n#### 1. Determine where to add your test\nThe Livewire core is divided into different folders, each corresponding to specific Livewire features. For example:","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-14","text":"atures. For example:\n\n```shell\nsrc/Features/SupportAccessingParent\nsrc/Features/SupportAttributes\nsrc/Features/SupportAutoInjectedAssets\nsrc/Features/SupportBladeAttributes\nsrc/Features/SupportChecksumErrorDebugging\nsrc/Features/SupportComputed\nsrc/Features/SupportConsoleCommands\nsrc/Features/SupportDataBinding\n//...\n```","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-15","text":"ataBinding\n//...\n```\n\nTry to locate a feature that is related to the bug you are experiencing. If you can't find an appropriate folder or if you're unsure about which one to select, you can simply choose one and mention in your pull request that you require assistance with placing the test in the correct feature set.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-16","text":"correct feature set.\n\n#### 2. Determine the type of test\nThe Livewire test suite consists of two types of tests:\n\n1. **Unit tests**: These tests focus on the PHP implementation of Livewire.\n2. **Browser tests**: These tests run a series of steps inside a real browser and assert the correct outcome. They mainly focus on the Javascript implementation of Livewire.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-17","text":"ntation of Livewire.\n\nIf you're unsure about which type of test to choose or if you're unfamiliar with writing tests for Livewire, you can start with a browser test. Implement the steps you perform in your application and browser to reproduce the bug.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-18","text":"o reproduce the bug.\n\nUnit tests should be added to the `UnitTest.php` file, and browser tests should be added to `BrowserTest.php`. If one or both of these files do not exist, you can create them yourself.\n\n**Unit test**\n\n```php\nuse Tests\\TestCase;\n\nclass UnitTest extends TestCase\n{\n    public function test_livewire_can_run_action(): void\n    {\n       // ...\n    }\n}\n```\n\n**Browser test**","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-19","text":"``\n\n**Browser test**\n\n```php\nuse Tests\\BrowserTestCase;\n\nclass BrowserTest extends BrowserTestCase\n{\n    public function test_livewire_can_run_action()\n    {\n        // ...\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-20","text":"  // ...\n    }\n}\n```\n\n> [!tip] Not sure how to write tests?\n> You can learn a lot by explore existing Unit and Browser tests to learn how tests are written. Even copying and pasting an existing test is a great starting point for writing your own test.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-21","text":"iting your own test.\n\n#### 3. Preparing your pull request branch\nOnce you have completed your feature or failing test, it's time to submit your Pull Request (PR) to the Livewire repository. First, ensure that you commit your changes to a separate branch (avoid using `main`). To create a new branch, you can use the `git` command:\n\n```shell\ngit checkout -b my-feature\n```","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-22","text":"ut -b my-feature\n```\n\nYou can name your branch anything you want, but for future reference, it's helpful to use a descriptive name that reflects your feature or failing test.\n\nNext, commit your changes to your branch. You can use `git add .` to stage all changes and then `git commit -m \"Add my feature\"` to commit all changes with a descriptive commit message.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-23","text":"tive commit message.\n\nHowever, your branch is currently only available on your local machine. To create a Pull Request, you need to push your branch to your forked Livewire repository using `git push`.\n\n```shell\ngit push origin my-feature\n\nEnumerating objects: 13, done.\nCounting objects: 100% (13/13), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (6/6), done.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-24","text":"s: 100% (6/6), done.\n\nTo github.com:Username/livewire.git\n * [new branch]        my-feature -> my-feature\n```","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-25","text":"re -> my-feature\n```\n\n#### 4. Submitting your pull request","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-26","text":"ng your pull request\nWe're almost there! Open your web browser and navigate to your forked Livewire repository (`https://github.com/<your-username>/livewire`). In the center of your screen, you will see a new notification: \"**my-feature had recent pushes 1 minute ago**\" along with a button that says \"**Compare & pull request**.\" Click the button to open the pull request form.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-27","text":"e pull request form.\n\nIn the form, provide a title that describes your pull request and then proceed to the description section. The text area already contains a predefined template. Try to answer every question:\n\n```\nReview the contribution guide first at: https://livewire.laravel.com/docs/contribution-guide","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-28","text":"s/contribution-guide\n\n1️⃣ Is this something that is wanted/needed? Did you create a discussion about it first?\nYes, you can find the discussion here: https://github.com/livewire/livewire/discussions/999999\n\n2️⃣ Did you create a branch for your fix/feature? (Main branch PR's will be closed)\nYes, the branch is named `my-feature`","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-29","text":"s named `my-feature`\n\n3️⃣ Does it contain multiple, unrelated changes? Please separate the PRs out.\nNo, the changes are only related to my feature.\n\n4️⃣ Does it include tests? (Required)\nYes\n\n5️⃣ Please include a thorough description (including small code snippets if possible) of the improvement and reasons why it's useful.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-30","text":"ons why it's useful.\n\nThese changes will improve memory usage. You can see the benchmark results here:\n\n// ...\n\n```\n\nAll set? Click on **Create pull request** 🚀 Congratulations! You've successfully created your first contribution 🎉\n\nThe maintainers will review your PR and may provide feedback or request changes. Please make an effort to address any feedback as soon as possible.","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"b61292778bf95f75263ce92ec772a8dd-31","text":"as soon as possible.\n\nThank you for contributing to Livewire!\n","source":"/Users/fyyx/Documents/livewire/docs/contribution-guide.md"}
{"id":"72bed56b94067307d7832459283317ab-0","text":"In real-time applications, it can be helpful to provide a visual indication that the user's device is no longer connected to the internet.\n\nLivewire provides the `wire:offline` directive for such cases.\n\nBy adding `wire:offline` to an element inside a Livewire component, it will be hidden by default and become visible when the user loses connection:","source":"/Users/fyyx/Documents/livewire/docs/offline.md"}
{"id":"72bed56b94067307d7832459283317ab-1","text":"er loses connection:\n\n```blade\n<div wire:offline>\n    This device is currently offline.\n</div>\n```\n\n## Toggling classes\n\nAdding the `class` modifier allows you to add a class to an element when the user loses their connection. The class will be removed again, once the user is back online:\n\n```blade\n<div wire:offline.class=\"bg-red-300\">\n```","source":"/Users/fyyx/Documents/livewire/docs/offline.md"}
{"id":"72bed56b94067307d7832459283317ab-2","text":"ss=\"bg-red-300\">\n```\n\nOr, using the `.remove` modifier, you can remove a class when a user loses their connection. In this example, the `bg-green-300` class will be removed from the `<div>` while the user has lost their connection:\n\n```blade\n<div class=\"bg-green-300\" wire:offline.class.remove=\"bg-green-300\">\n```\n\n## Toggling attributes","source":"/Users/fyyx/Documents/livewire/docs/offline.md"}
{"id":"72bed56b94067307d7832459283317ab-3","text":" Toggling attributes\n\nThe `.attr` modifier allows you to add an attribute to an element when the user loses their connection. In this example, the \"Save\" button will be disabled while the user has lost their connection:\n\n```blade\n<button wire:offline.attr=\"disabled\">Save</button>\n```\n\n","source":"/Users/fyyx/Documents/livewire/docs/offline.md"}
{"id":"42f65522051ede4ae7db7f5e02126122-0","text":"\nLivewire provides a simple `wire:click` directive for calling component methods (aka actions) when a user clicks a specific element on the page.\n\nFor example, given the `ShowInvoice` component below:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Invoice;\n\nclass ShowInvoice extends Component\n{\n    public Invoice $invoice;","source":"/Users/fyyx/Documents/livewire/docs/wire-click.md"}
{"id":"42f65522051ede4ae7db7f5e02126122-1","text":"ic Invoice $invoice;\n\n    public function download()\n    {\n        return response()->download(\n            $this->invoice->file_path, 'invoice.pdf'\n        );\n    }\n}\n```\n\nYou can trigger the `download()` method from the class above when a user clicks a \"Download Invoice\" button by adding `wire:click=\"download\"`:","source":"/Users/fyyx/Documents/livewire/docs/wire-click.md"}
{"id":"42f65522051ede4ae7db7f5e02126122-2","text":"e:click=\"download\"`:\n\n```html\n<button type=\"button\" wire:click=\"download\"> <!-- [tl! highlight] -->\n    Download Invoice\n</button>\n```\n\n## Using `wire:click` on links\n\nWhen using `wire:click` on `<a>` tags, you must append `.prevent` to prevent the default handling of a link in the browser. Otherwise, the browser will visit the provided link and update the page's URL.","source":"/Users/fyyx/Documents/livewire/docs/wire-click.md"}
{"id":"42f65522051ede4ae7db7f5e02126122-3","text":"date the page's URL.\n\n```html\n<a href=\"#\" wire:click.prevent=\"...\">\n```\n\n## Going deeper\n\nThe `wire:click` directive is just one of many different available event listeners in Livewire. For full documentation on its (and other event listeners) capabilities, visit [the Livewire actions documentation page](/docs/actions).\n","source":"/Users/fyyx/Documents/livewire/docs/wire-click.md"}
{"id":"a08e0342036b66ca5fbf788eb80bb237-0","text":"\n```blade\n<form wire:submit=\"save\">\n    <label>\n        <span>Title</span>\n\n        <input type=\"text\" wire:model=\"title\">\n\n        @error('title') <span>{{ $message }}</span> @enderror\n    </label>\n\n    <label>\n        <span>Title</span>\n\n        <input type=\"text\" wire:model=\"title\">\n\n        @error('title') <span>{{ $message }}</span> @enderror\n    </label>","source":"/Users/fyyx/Documents/livewire/docs/blade-components.md"}
{"id":"a08e0342036b66ca5fbf788eb80bb237-1","text":"nderror\n    </label>\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\n```blade\n<form wire:submit=\"save\">\n    <x-input-text label=\"Title\" wire:model=\"title\" :error=\"$error->first('title')\" />\n\n    <x-input-text label=\"Content\" wire:model=\"content\" :error=\"$error->first('content')\" />\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\n```blade\n@props(['label', 'error'])","source":"/Users/fyyx/Documents/livewire/docs/blade-components.md"}
{"id":"a08e0342036b66ca5fbf788eb80bb237-2","text":"(['label', 'error'])\n\n<label>\n    <span>{{ $label }}</span>\n\n    <input type=\"text\" {{ $attributes->whereStartsWith('wire:') }}>\n\n    @if($error) <span>{{ $error }}</span> @endif\n</label>\n```\n\n## Injecting and running assets\n\n```blade\n@php $key = str()->uuid(); @endphp\n\n<div>\n    <input type=\"text\" id=\"{{ $key }}\">\n</div>","source":"/Users/fyyx/Documents/livewire/docs/blade-components.md"}
{"id":"a08e0342036b66ca5fbf788eb80bb237-3","text":"\"{{ $key }}\">\n</div>\n\n@assets\n<script src=\"https://cdn.jsdelivr.net/npm/pikaday/pikaday.js\" defer></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css\">\n@endassets\n\n@script\n<script>\n    new Pikaday({ field: document.getElementById('{{ $key }}') });\n</script>\n@endscript\n```\n","source":"/Users/fyyx/Documents/livewire/docs/blade-components.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-0","text":"Livewire actions are methods on your component that can be triggered by frontend interactions like clicking a button or submitting a form. They provide the developer experience of being able to call a PHP method directly from the browser, allowing you to focus on the logic of your application without getting bogged down writing boilerplate code connecting your application's frontend and backend.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-1","text":"rontend and backend.\n\nLet's explore a basic example of calling a `save` action on a `CreatePost` component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    public $title = '';\n\n    public $content = '';","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-2","text":"ublic $content = '';\n\n    public function save()\n    {\n        Post::create([\n            'title' => $this->title,\n            'content' => $this->content,\n        ]);\n\n        return redirect()->to('/posts');\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-3","text":"-post');\n    }\n}\n```\n\n```blade\n<form wire:submit=\"save\"> <!-- [tl! highlight] -->\n    <input type=\"text\" wire:model=\"title\">\n\n    <textarea wire:model=\"content\"></textarea>\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\nIn the above example, when a user submits the form by clicking \"Save\", `wire:submit` intercepts the `submit` event and calls the `save()` action on the server.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-4","text":"ction on the server.\n\nIn essence, actions are a way to easily map user interactions to server-side functionality without the hassle of submitting and handling AJAX requests manually.\n\n## Refreshing a component","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-5","text":"freshing a component\n\nSometimes you may want to trigger a simple \"refresh\" of your component. For example, if you have a component checking the status of something in the database, you may want to show a button to your users allowing them to refresh the displayed results.\n\nYou can do this using Livewire's simple `$refresh` action anywhere you would normally reference your own component method:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-6","text":"wn component method:\n\n```blade\n<button type=\"button\" wire:click=\"$refresh\">...</button>\n```\n\nWhen the `$refresh` action is triggered, Livewire will make a server-roundtrip and re-render your component without calling any methods.\n\nIt's important to note that any pending data updates in your component (for example `wire:model` bindings) will be applied on the server when the component is refreshed.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-7","text":"ponent is refreshed.\n\nInternally, Livewire uses the name \"commit\" to refer to any time a Livewire component is updated on the server. If you prefer this terminology, you can use the `$commit` helper instead of `$refresh`. The two are identical.\n\n```blade\n<button type=\"button\" wire:click=\"$commit\">...</button>\n```\n\nYou can also trigger a component refresh using AlpineJS in your Livewire component:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-8","text":" Livewire component:\n\n```blade\n<button type=\"button\" x-on:click=\"$wire.$refresh()\">...</button>\n```\n\nLearn more by reading the [documentation for using Alpine inside Livewire](/docs/alpine).\n\n## Confirming an action","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-9","text":"Confirming an action\n\nWhen allowing users to perform dangerous actions—such as deleting a post from the database—you may want to show them a confirmation alert to verify that they wish to perform that action.\n\nLivewire makes this easy by providing a simple directive called `wire:confirm`:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-10","text":"lled `wire:confirm`:\n\n```blade\n<button\n    type=\"button\"\n    wire:click=\"delete\"\n    wire:confirm=\"Are you sure you want to delete this post?\"\n>\n    Delete post <!-- [tl! highlight:-2,1] -->\n</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-11","text":"1] -->\n</button>\n```\n\nWhen `wire:confirm` is added to an element containing a Livewire action, when a user tries to trigger that action, they will be presented with a confirmation dialog containing the provided message. They can either press \"OK\" to confirm the action, or press \"Cancel\" or hit the escape key.\n\nFor more information, visit the [`wire:confirm` documentation page](/docs/wire-confirm).","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-12","text":"/docs/wire-confirm).\n\n## Event listeners\n\nLivewire supports a variety of event listeners, allowing you to respond to various types of user interactions:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-13","text":"f user interactions:\n\n| Listener        | Description                               |\n|-----------------|-------------------------------------------|\n| `wire:click`    | Triggered when an element is clicked      |\n| `wire:submit`   | Triggered when a form is submitted        |\n| `wire:keydown`  | Triggered when a key is pressed down      |\n| `wire:keyup`  | Triggered when a key is released","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-14","text":"en a key is released\n| `wire:mouseenter`| Triggered when the mouse enters an element |\n| `wire:*`| Whatever text follows `wire:` will be used as the event name of the listener |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-15","text":"me of the listener |\n\nBecause the event name after `wire:` can be anything, Livewire supports any browser event you might need to listen for. For example, to listen for `transitionend`, you can use `wire:transitionend`.\n\n### Listening for specific keys\n\nYou can use one of Livewire's convenient aliases to narrow down key press event listeners to a specific key or combination of keys.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-16","text":"combination of keys.\n\nFor example, to perform a search when a user hits `Enter` after typing into a search box, you can use `wire:keydown.enter`:\n\n```blade\n<input wire:model=\"query\" wire:keydown.enter=\"searchPosts\">\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-17","text":"r=\"searchPosts\">\n```\n\nYou can chain more key aliases after the first to listen for combinations of keys. For example, if you would like to listen for the `Enter` key only while the `Shift` key is pressed, you may write the following:\n\n```blade\n<input wire:keydown.shift.enter=\"...\">\n```\n\nBelow is a list of all the available key modifiers:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-18","text":"lable key modifiers:\n\n| Modifier      | Key                          |\n|---------------|------------------------------|\n| `.shift`      | Shift                        |\n| `.enter`      | Enter                        |\n| `.space`      | Space                        |\n| `.ctrl`       | Ctrl                         |\n| `.cmd`        | Cmd                          |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-19","text":"                   |\n| `.meta`       | Cmd on Mac, Windows key on Windows |\n| `.alt`        | Alt                          |\n| `.up`         | Up arrow                     |\n| `.down`       | Down arrow                   |\n| `.left`       | Left arrow                   |\n| `.right`      | Right arrow                  |\n| `.escape`     | Escape                       |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-20","text":"                   |\n| `.tab`        | Tab                          |\n| `.caps-lock`  | Caps Lock                    |\n| `.equal`      | Equal, `=`                   |\n| `.period`     | Period, `.`                  |\n| `.slash`      | Forward Slash, `/`           |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-21","text":"ash, `/`           |\n\n### Event handler modifiers\n\nLivewire also includes helpful modifiers to make common event-handling tasks trivial.\n\nFor example, if you need to call `event.preventDefault()` from inside an event listener, you can suffix the event name with `.prevent`:\n\n```blade\n<input wire:keydown.prevent=\"...\">\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-22","text":"n.prevent=\"...\">\n```\n\nHere is a full list of all the available event listener modifiers and their functions:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-23","text":"and their functions:\n\n| Modifier         | Key                                                     |\n|------------------|---------------------------------------------------------|\n| `.prevent`       | Equivalent of calling `.preventDefault()`               |\n| `.stop`          | Equivalent of calling `.stopPropagation()`              |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-24","text":"on()`              |\n| `.window`        | Listens for event on the `window` object                 |\n| `.outside`       | Only listens for clicks \"outside\" the element            |\n| `.document`      | Listens for events on the `document` object              |\n| `.once`          | Ensures the listener is only called once                 |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-25","text":"ce                 |\n| `.debounce`      | Debounce the handler by 250ms as a default               |\n| `.debounce.100ms`| Debounce the handler for a specific amount of time       |\n| `.throttle`      | Throttle the handler to being called every 250ms at minimum |\n| `.throttle.100ms`| Throttle the handler at a custom duration                |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-26","text":"ion                |\n| `.self`          | Only call listener if event originated on this element, not children |\n| `.camel`         | Converts event name to camel case (`wire:custom-event` -> \"customEvent\") |\n| `.dot`           | Converts event name to dot notation (`wire:custom-event` -> \"custom.event\") |\n| `.passive`       | `wire:touchstart.passive` won't block scroll performance |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-27","text":"scroll performance |\n| `.capture`       | Listen for event in the \"capturing\" phase                 |","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-28","text":"se                 |\n\nBecause `wire:` uses [Alpine's](https://alpinejs.dev) `x-on` directive under the hood, these modifiers are made available to you by Alpine. For more context on when you should use these modifiers, consult the [Alpine Events documentation](https://alpinejs.dev/essentials/events).\n\n### Handling third-party events","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-29","text":"g third-party events\n\nLivewire also supports listening for custom events fired by third-party libraries.\n\nFor example, let's imagine you're using the [Trix](https://trix-editor.org/) rich text editor in your project and you want to listen for the `trix-change` event to capture the editor's content. You can accomplish this using the `wire:trix-change` directive:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-30","text":"x-change` directive:\n\n```blade\n<form wire:submit=\"save\">\n    <!-- ... -->\n\n    <trix-editor\n        wire:trix-change=\"setPostContent($event.target.value)\"\n    ></trix-editor>\n\n    <!-- ... -->\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-31","text":" ... -->\n</form>\n```\n\nIn this example, the `setPostContent` action is called whenever the `trix-change` event is triggered, updating the `content` property in the Livewire component with the current value of the Trix editor.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-32","text":" of the Trix editor.\n\n> [!info] You can access the event object using `$event`\n> Within Livewire event handlers, you can access the event object via `$event`. This is useful for referencing information on the event. For example, you can access the element that triggered the event via `$event.target`.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-33","text":"via `$event.target`.\n\n> [!warning]\n> The Trix demo code above is incomplete and only useful as a demonstration of event listeners. If used verbatim, a network request would be fired on every single keystroke. A more performant implementation would be:\n>\n> ```blade\n> <trix-editor\n>    x-on:trix-change=\"$wire.content = $event.target.value\"\n>></trix-editor>\n> ```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-34","text":"</trix-editor>\n> ```\n\n### Listening for dispatched custom events\n\nIf your application dispatches custom events from Alpine, you can also listen for those using Livewire:\n\n```blade\n<div wire:custom-event=\"...\">\n\n    <!-- Deeply nested within this component: -->\n    <button x-on:click=\"$dispatch('custom-event')\">...</button>\n\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-35","text":"/button>\n\n</div>\n```\n\nWhen the button is clicked in the above example, the `custom-event` event is dispatched and bubbles up to the root of the Livewire component where `wire:custom-event` catches it and invokes a given action.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-36","text":"okes a given action.\n\nIf you want to listen for an event dispatched somewhere else in your application, you will need to wait instead for the event to bubble up to the `window` object and listen for it there. Fortunately, Livewire makes this easy by allowing you to add a simple `.window` modifier to any event listener:\n\n```blade\n<div wire:custom-event.window=\"...\">\n    <!-- ... -->\n</div>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-37","text":" <!-- ... -->\n</div>\n\n<!-- Dispatched somewhere on the page outside the component: -->\n<button x-on:click=\"$dispatch('custom-event')\">...</button>\n```\n\n### Disabling inputs while a form is being submitted\n\nConsider the `CreatePost` example we previously discussed:\n\n```blade\n<form wire:submit=\"save\">\n    <input wire:model=\"title\">\n\n    <textarea wire:model=\"content\"></textarea>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-38","text":"content\"></textarea>\n\n    <button type=\"submit\">Save</button>\n</form>\n```\n\nWhen a user clicks \"Save\", a network request is sent to the server to call the `save()` action on the Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-39","text":" Livewire component.\n\nBut, let's imagine that a user is filling out this form on a slow internet connection. The user clicks \"Save\" and nothing happens initially because the network request takes longer than usual. They might wonder if the submission failed and attempt to click the \"Save\" button again while the first request is still being handled.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-40","text":"still being handled.\n\nIn this case, there would be two requests for the same action being processed at the same time.\n\nTo prevent this scenario, Livewire automatically disables the submit button and all form inputs inside the `<form>` element while a `wire:submit` action is being processed. This ensures that a form isn't accidentally submitted twice.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-41","text":"lly submitted twice.\n\nTo further lessen the confusion for users on slower connections, it is often helpful to show some loading indicator such as a subtle background color change or SVG animation.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-42","text":"ge or SVG animation.\n\nLivewire provides a `wire:loading` directive that makes it trivial to show and hide loading indicators anywhere on a page. Here's a short example of using `wire:loading` to show a loading message below the \"Save\" button:\n\n```blade\n<form wire:submit=\"save\">\n    <textarea wire:model=\"content\"></textarea>\n\n    <button type=\"submit\">Save</button>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-43","text":"ubmit\">Save</button>\n\n    <span wire:loading>Saving...</span> <!-- [tl! highlight] -->\n</form>\n```\n\n`wire:loading` is a powerful feature with a variety of more powerful features. [Check out the full loading documentation for more information](/docs/wire-loading).\n\n## Passing parameters","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-44","text":"# Passing parameters\n\nLivewire allows you to pass parameters from your Blade template to the actions in your component, giving you the opportunity to provide an action additional data or state from the frontend when the action is called.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-45","text":"he action is called.\n\nFor example, let's imagine you have a `ShowPosts` component that allows users to delete a post. You can pass the post's ID as a parameter to the `delete()` action in your Livewire component. Then, the action can fetch the relevant post and delete it from the database:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-46","text":"espace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    public function delete($id)\n    {\n        $post = Post::findOrFail($id);\n\n        $this->authorize('delete', $post);\n\n        $post->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-47","text":"ost->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.show-posts', [\n            'posts' => Auth::user()->posts,\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <div wire:key=\"{{ $post->id }}\">\n            <h1>{{ $post->title }}</h1>\n            <span>{{ $post->content }}</span>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-48","text":"t->content }}</span>\n\n            <button wire:click=\"delete({{ $post->id }})\">Delete</button> <!-- [tl! highlight] -->\n        </div>\n    @endforeach\n</div>\n```\n\nFor a post with an ID of 2, the \"Delete\" button in the Blade template above will render in the browser as:\n\n```blade\n<button wire:click=\"delete(2)\">Delete</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-49","text":">Delete</button>\n```\n\nWhen this button is clicked, the `delete()` method will be called and `$id` will be passed in with a value of \"2\".","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-50","text":"with a value of \"2\".\n\n> [!warning] Don't trust action parameters\n> Action parameters should be treated just like HTTP request input, meaning action parameter values should not be trusted. You should always authorize ownership of an entity before updating it in the database.\n>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-51","text":"t in the database.\n>\n> For more information, consult our documentation regarding [security concerns and best practices](/docs/actions#security-concerns).","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-52","text":"#security-concerns).","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-53","text":"#security-concerns).\n\n","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-54","text":"ecurity-concerns).\n\n\nAs an added convenience, you may automatically resolve Eloquent models by a corresponding model ID that is provided to an action as a parameter. This is very similar to [route model binding](/docs/components#using-route-model-binding)","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-55","text":"route-model-binding). To get started, type-hint an action parameter with a model class and the appropriate model will automatically be retrieved from the database and passed to the action instead of the ID:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-56","text":"n instead of the ID:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    public function delete(Post $post) // [tl! highlight]\n    {\n        $this->authorize('delete', $post);\n\n        $post->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-57","text":"ost->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.show-posts', [\n            'posts' => Auth::user()->posts,\n        ]);\n    }\n}\n```\n\n## Dependency injection","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-58","text":"Dependency injection\n\nYou can take advantage of [Laravel's dependency injection](https://laravel.com/docs/controllers#dependency-injection-and-controllers) system by type-hinting parameters in your action's signature. Livewire and Laravel will automatically resolve the action's dependencies from the container:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-59","text":"espace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Repositories\\PostRepository;\n\nclass ShowPosts extends Component\n{\n    public function delete(PostRepository $posts, $postId) // [tl! highlight]\n    {\n        $posts->deletePost($postId);\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-60","text":"Post($postId);\n    }\n\n    public function render()\n    {\n        return view('livewire.show-posts', [\n            'posts' => Auth::user()->posts,\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <div wire:key=\"{{ $post->id }}\">\n            <h1>{{ $post->title }}</h1>\n            <span>{{ $post->content }}</span>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-61","text":"t->content }}</span>\n\n            <button wire:click=\"delete({{ $post->id }})\">Delete</button> <!-- [tl! highlight] -->\n        </div>\n    @endforeach\n</div>\n```\n\nIn this example, the `delete()` method receives an instance of `PostRepository` resolved via [Laravel's service container](https://laravel.com/docs/container#main-content) before receiving the provided `$postId` parameter.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-62","text":"`$postId` parameter.\n\n## Calling actions from Alpine\n\nLivewire integrates seamlessly with [Alpine](https://alpinejs.dev/). In fact, under the hood, every Livewire component is also an Alpine component. This means you can take full advantage of Alpine within your components to add JavaScript powered client-side interactivity.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-63","text":"-side interactivity.\n","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-64","text":"side interactivity.\n\nTo make this pairing even more powerful, Livewire exposes a magic `$wire` object to Alpine that can be treated as a JavaScript representation of your PHP component. In addition to [accessing and mutating public properties via `$wire`](/docs/properties#accessing-properties-from-javascript), you can call actions","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-65","text":"you can call actions. When an action is invoked on the `$wire` object, the corresponding PHP method will be invoked on your backend Livewire component:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-66","text":" Livewire component:\n\n```blade\n<button x-on:click=\"$wire.save()\">Save Post</button>\n```\n\nOr, to illustrate a more complex example, you might use Alpine's [`x-intersect`](https://alpinejs.dev/plugins/intersect) utility to trigger a `incrementViewCount()` Livewire action when a given element is visible on the page:\n\n```blade\n<div x-intersect=\"$wire.incrementViewCount()\">...</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-67","text":"unt()\">...</div>\n```\n\n### Passing parameters\n\nAny parameters you pass to the `$wire` method will also be passed to the PHP class method. For example, consider the following Livewire action:\n\n```php\npublic function addTodo($todo)\n{\n    $this->todos[] = $todo;\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-68","text":"dos[] = $todo;\n}\n```\n\nWithin your component's Blade template, you can invoke this action via Alpine, providing the parameter that should be given to the action:\n\n```blade\n<div x-data=\"{ todo: '' }\">\n    <input type=\"text\" x-model=\"todo\">\n\n    <button x-on:click=\"$wire.addTodo(todo)\">Add Todo</button>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-69","text":"</button>\n</div>\n```\n\nIf a user had typed in \"Take out the trash\" into the text input and the pressed the \"Add Todo\" button, the `addTodo()` method will be triggered with the `$todo` parameter value being \"Take out the trash\".\n\n### Receiving return values","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-70","text":"eiving return values\n\nFor even more power, invoked `$wire` actions return a promise while the network request is processing. When the server response is received, the promise resolves with the value returned by the backend action.\n\nFor example, consider a Livewire component that has the following action:\n\n```php\nuse App\\Models\\Post;\n\npublic function getPostCount()\n{\n    return Post::count();\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-71","text":"Post::count();\n}\n```\n\nUsing `$wire`, the action may be invoked and its returned value resolved:\n\n```blade\n<span x-init=\"$el.innerHTML = await $wire.getPostCount()\"></span>\n```\n\nIn this example, if the `getPostCount()` method returns \"10\", the `<span>` tag will also contain \"10\".","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-72","text":"l also contain \"10\".\n\nAlpine knowledge is not required when using Livewire; however, it's an extremely powerful tool and knowing Alpine will augment your Livewire experience and productivity.\n\n## JavaScript actions\n\nLivewire allows you to define JavaScript actions that run entirely on the client-side without making a server request. This is useful in two scenarios:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-73","text":"ul in two scenarios:\n\n1. When you want to perform simple UI updates that don't require server communication\n2. When you want to optimistically update the UI with JavaScript before making a server request\n\nTo define a JavaScript action, you can use the `$js()` function inside a `<script>` tag in your component.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-74","text":"g in your component.\n\nHere's an example of bookmarking a post that uses a JavaScript action to optimistically update the UI before making a server request. The JavaScript action immediately shows the filled bookmark icon, then makes a request to persist the bookmark in the database:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-75","text":"use App\\Models\\Post;\n\nclass ShowPost extends Component\n{\n    public Post $post;\n\n    public $bookmarked = false;\n\n    public function mount()\n    {\n        $this->bookmarked = $this->post->bookmarkedBy(auth()->user());\n    }\n\n    public function bookmarkPost()\n    {\n        $this->post->bookmark(auth()->user());\n\n        $this->bookmarked = $this->post->bookmarkedBy(auth()->user());\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-76","text":"th()->user());\n    }\n\n    public function render()\n    {\n        return view('livewire.show-post');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-77","text":"-post');\n    }\n}\n```\n\n```blade\n<div>\n    <button wire:click=\"$js.bookmark\" class=\"flex items-center gap-1\">\n        {{-- Outlined bookmark icon... --}}\n        <svg wire:show=\"!bookmarked\" wire:cloak xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"size-6\">","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-78","text":"lor\" class=\"size-6\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M17.593 3.322c1.1.128 1.907 1.077 1.907 2.185V21L12 17.25 4.5 21V5.507c0-1.108.806-2.057 1.907-2.185a48.507 48.507 0 0 1 11.186 0Z\" />\n        </svg>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-79","text":"Z\" />\n        </svg>\n\n        {{-- Solid bookmark icon... --}}\n        <svg wire:show=\"bookmarked\" wire:cloak xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\" class=\"size-6\">","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-80","text":"lor\" class=\"size-6\">\n            <path fill-rule=\"evenodd\" d=\"M6.32 2.577a49.255 49.255 0 0 1 11.36 0c1.497.174 2.57 1.46 2.57 2.93V21a.75.75 0 0 1-1.085.67L12 18.089l-7.165 3.583A.75.75 0 0 1 3.75 21V5.507c0-1.47 1.073-2.756 2.57-2.93Z\" clip-rule=\"evenodd\" />\n        </svg>\n    </button>\n</div>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-81","text":"    </button>\n</div>\n\n@script\n<script>\n    $js('bookmark', () => {\n        $wire.bookmarked = !$wire.bookmarked\n\n        $wire.bookmarkPost()\n    })\n</script>\n@endscript\n```\n\nWhen a user clicks the heart button, the following sequence occurs:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-82","text":"ing sequence occurs:\n\n1. The \"bookmark\" JavaScript action is triggered\n2. The heart icon immediately updates by toggling `$wire.bookmarked` on the client-side\n3. The `bookmarkPost()` method is called to save the change to the database\n\nThis provides instant visual feedback while ensuring the bookmark state is properly persisted.\n\n### Calling from Alpine","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-83","text":" Calling from Alpine\n\nYou can call JavaScript actions directly from Alpine using the `$wire` object. For example, you may use the `$wire` object to invoke the `bookmark` JavaScript action:\n\n```blade\n<button x-on:click=\"$wire.$js.bookmark()\">Bookmark</button>\n```\n\n### Calling from PHP\n\nJavaScript actions can also be called using the `js()` method from PHP:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-84","text":"espace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public $title = '';\n\n    public function save()\n    {\n        // ...\n\n        $this->js('onPostSaved'); // [tl! highlight]\n    }\n}\n```\n\n```blade\n<div>\n    <!-- ... -->\n\n    <button wire:click=\"save\">Save</button>\n</div>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-85","text":"Save</button>\n</div>\n\n@script\n<script>\n    $js('onPostSaved', () => {\n        alert('Your post has been saved successfully!')\n    })\n</script>\n@endscript\n```\n\nIn this example, when the `save()` action is finished, the `postSaved` JavaScript action will be run, triggering the alert dialog.\n\n## Magic actions","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-86","text":"g.\n\n## Magic actions\n\nLivewire provides a set of \"magic\" actions that allow you to perform common tasks in your components without defining custom methods. These magic actions can be used within event listeners defined in your Blade templates.\n\n### `$parent`\n\nThe `$parent` magic variable allows you to access parent component properties and call parent component actions from a child component:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-87","text":"m a child component:\n\n```blade\n<button wire:click=\"$parent.removePost({{ $post->id }})\">Remove</button>\n```\n\nIn the above example, if a parent component has a `removePost()` action, a child can call it directly from its Blade template using `$parent.removePost()`.\n\n### `$set`","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-88","text":"Post()`.\n\n### `$set`\n\nThe `$set` magic action allows you to update a property in your Livewire component directly from the Blade template. To use `$set`, provide the property you want to update and the new value as arguments:\n\n```blade\n<button wire:click=\"$set('query', '')\">Reset Search</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-89","text":" Search</button>\n```\n\nIn this example, when the button is clicked, a network request is dispatched that sets the `$query` property in the component to `''`.\n\n### `$refresh`\n\nThe `$refresh` action triggers a re-render of your Livewire component. This can be useful when updating the component's view without changing any property values:\n\n```blade\n<button wire:click=\"$refresh\">Refresh</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-90","text":"Refresh</button>\n```\n\nWhen the button is clicked, the component will re-render, allowing you to see the latest changes in the view.\n\n### `$toggle`\n\nThe `$toggle` action is used to toggle the value of a boolean property in your Livewire component:\n\n```blade\n<button wire:click=\"$toggle('sortAsc')\">\n    Sort {{ $sortAsc ? 'Descending' : 'Ascending' }}\n</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-91","text":"ng' }}\n</button>\n```\n\nIn this example, when the button is clicked, the `$sortAsc` property in the component will toggle between `true` and `false`.\n\n### `$dispatch`\n\nThe `$dispatch` action allows you to dispatch a Livewire event directly in the browser. Below is an example of a button that, when clicked, will dispatch the `post-deleted` event:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-92","text":"post-deleted` event:\n\n```blade\n<button type=\"submit\" wire:click=\"$dispatch('post-deleted')\">Delete Post</button>\n```\n\n### `$event`\n\nThe `$event` action may be used within event listeners like `wire:click`. This action gives you access to the actual JavaScript event that was triggered, allowing you to reference the triggering element and other relevant information:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-93","text":"elevant information:\n\n```blade\n<input type=\"text\" wire:keydown.enter=\"search($event.target.value)\">\n```\n\nWhen the enter key is pressed while a user is typing in the input above, the contents of the input will be passed as a parameter to the `search()` action.\n\n### Using magic actions from Alpine","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-94","text":" actions from Alpine\n\nYou can also call magic actions from Alpine using the `$wire` object. For example, you may use the `$wire` object to invoke the `$refresh` magic action:\n\n```blade\n<button x-on:click=\"$wire.$refresh()\">Refresh</button>\n```\n\n## Skipping re-renders","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-95","text":" Skipping re-renders\n\nSometimes there might be an action in your component with no side effects that would change the rendered Blade template when the action is invoked. If so, you can skip the `render` portion of Livewire's lifecycle by adding the `#[Renderless]` attribute above the action method.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-96","text":"e the action method.\n\nTo demonstrate, in the `ShowPost` component below, the \"view count\" is logged when the user has scrolled to the bottom of the post:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Attributes\\Renderless;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPost extends Component\n{\n    public Post $post;","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-97","text":"  public Post $post;\n\n    public function mount(Post $post)\n    {\n        $this->post = $post;\n    }\n\n    #[Renderless] // [tl! highlight]\n    public function incrementViewCount()\n    {\n        $this->post->incrementViewCount();\n    }\n\n    public function render()\n    {\n        return view('livewire.show-post');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-98","text":"-post');\n    }\n}\n```\n\n```blade\n<div>\n    <h1>{{ $post->title }}</h1>\n    <p>{{ $post->content }}</p>\n\n    <div x-intersect=\"$wire.incrementViewCount()\"></div>\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-99","text":")\"></div>\n</div>\n```\n\nThe example above uses [`x-intersect`](https://alpinejs.dev/plugins/intersect), an Alpine utility that calls the expression when the element enters the viewport (typically used to detect when a user scrolls to an element further down the page).","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-100","text":"ther down the page).\n\nAs you can see, when a user scrolls to the bottom of the post, `incrementViewCount()` is invoked. Since `#[Renderless]` was added to the action, the view is logged, but the template doesn't re-render and no part of the page is affected.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-101","text":"he page is affected.\n\nIf you prefer to not utilize method attributes or need to conditionally skip rendering, you may invoke the `skipRender()` method in your component action:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPost extends Component\n{\n    public Post $post;\n\n    public function mount(Post $post)\n    {\n        $this->post = $post;\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-102","text":">post = $post;\n    }\n\n    public function incrementViewCount()\n    {\n        $this->post->incrementViewCount();\n\n        $this->skipRender(); // [tl! highlight]\n    }\n\n    public function render()\n    {\n        return view('livewire.show-post');\n    }\n}\n```\n\n## Security concerns","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-103","text":"## Security concerns\n\nRemember that any public method in your Livewire component can be called from the client-side, even without an associated `wire:click` handler that invokes it. In these scenarios, users can still trigger the action from the browser's DevTools.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-104","text":" browser's DevTools.\n\nBelow are three examples of easy-to-miss vulnerabilities in Livewire components. Each will show the vulnerable component first and the secure component after. As an exercise, try spotting the vulnerabilities in the first example before viewing the solution.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-105","text":"iewing the solution.\n","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-106","text":"ewing the solution.\n\nIf you are having difficulty spotting the vulnerabilities and that makes you concerned about your ability to keep your own applications secure, remember all these vulnerabilities apply to standard web applications that use requests and controllers","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-107","text":"ests and controllers. If you use a component method as a proxy for a controller method, and its parameters as a proxy for request input, you should be able to apply your existing application security knowledge to your Livewire code.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-108","text":" your Livewire code.\n\n### Always authorize action parameters\n\nJust like controller request input, it's imperative to authorize action parameters since they are arbitrary user input.\n\nBelow is a `ShowPosts` component where users can view all their posts on one page. They can delete any post they like using one of the post's \"Delete\" buttons.\n\nHere is a vulnerable version of the component:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-109","text":"on of the component:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    public function delete($id)\n    {\n        $post = Post::find($id);\n\n        $post->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-110","text":"ost->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.show-posts', [\n            'posts' => Auth::user()->posts,\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <div wire:key=\"{{ $post->id }}\">\n            <h1>{{ $post->title }}</h1>\n            <span>{{ $post->content }}</span>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-111","text":"t->content }}</span>\n\n            <button wire:click=\"delete({{ $post->id }})\">Delete</button>\n        </div>\n    @endforeach\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-112","text":"ndforeach\n</div>\n```\n\nRemember that a malicious user can call `delete()` directly from a JavaScript console, passing any parameters they would like to the action. This means that a user viewing one of their posts can delete another user's post by passing the un-owned post ID to `delete()`.\n\nTo protect against this, we need to authorize that the user owns the post about to be deleted:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-113","text":"leted:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass ShowPosts extends Component\n{\n    public function delete($id)\n    {\n        $post = Post::find($id);\n\n        $this->authorize('delete', $post); // [tl! highlight]\n\n        $post->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-114","text":"ost->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.show-posts', [\n            'posts' => Auth::user()->posts,\n        ]);\n    }\n}\n```\n\n### Always authorize server-side\n\nLike standard Laravel controllers, Livewire actions can be called by any user, even if there isn't an affordance for invoking the action in the UI.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-115","text":"he action in the UI.\n\nConsider the following `BrowsePosts` component where any user can view all the posts in the application, but only administrators can delete a post:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass BrowsePosts extends Component\n{\n    public function deletePost($id)\n    {\n        $post = Post::find($id);\n\n        $post->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-116","text":"ost->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.browse-posts', [\n            'posts' => Post::all(),\n        ]);\n    }\n}\n```\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <div wire:key=\"{{ $post->id }}\">\n            <h1>{{ $post->title }}</h1>\n            <span>{{ $post->content }}</span>","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-117","text":"t->content }}</span>\n\n            @if (Auth::user()->isAdmin())\n                <button wire:click=\"deletePost({{ $post->id }})\">Delete</button>\n            @endif\n        </div>\n    @endforeach\n</div>\n```\n\nAs you can see, only administrators can see the \"Delete\" button; however, any user can call `deletePost()` on the component from the browser's DevTools.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-118","text":" browser's DevTools.\n\nTo patch this vulnerability, we need to authorize the action on the server like so:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-119","text":"use App\\Models\\Post;\n\nclass BrowsePosts extends Component\n{\n    public function deletePost($id)\n    {\n        if (! Auth::user()->isAdmin) { // [tl! highlight:2]\n            abort(403);\n        }\n\n        $post = Post::find($id);\n\n        $post->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-120","text":"ost->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.browse-posts', [\n            'posts' => Post::all(),\n        ]);\n    }\n}\n```\n\nWith this change, only administrators can delete a post from this component.\n\n### Keep dangerous methods protected or private","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-121","text":"protected or private\n","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-122","text":"rotected or private\n\nEvery public method inside your Livewire component is callable from the client. Even methods you haven't referenced inside a `wire:click` handler. To prevent a user from calling a method that isn't intended to be callable client-side, you should mark them as `protected` or `private`","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-123","text":"tected` or `private`. By doing so, you restrict the visibility of that sensitive method to the component's class and its subclasses, ensuring they cannot be called from the client-side.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-124","text":"rom the client-side.\n","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-125","text":"om the client-side.\n\nConsider the `BrowsePosts` example that we previously discussed, where users can view all posts in your application, but only administrators can delete posts. In the [Always authorize server-side](/docs/actions#always-authorize-server-side) section, we made the action secure by adding server-side authorization","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-126","text":"r-side authorization. Now imagine we refactor the actual deletion of the post into a dedicated method like you might do in order to simplify your code:","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-127","text":" simplify your code:\n\n```php\n// Warning: This snippet demonstrates what NOT to do...\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass BrowsePosts extends Component\n{\n    public function deletePost($id)\n    {\n        if (! Auth::user()->isAdmin) {\n            abort(403);\n        }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-128","text":"bort(403);\n        }\n\n        $this->delete($id); // [tl! highlight]\n    }\n\n    public function delete($postId)  // [tl! highlight:5]\n    {\n        $post = Post::find($postId);\n\n        $post->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.browse-posts', [\n            'posts' => Post::all(),\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-129","text":"     ]);\n    }\n}\n```\n\n```blade\n<div>\n    @foreach ($posts as $post)\n        <div wire:key=\"{{ $post->id }}\">\n            <h1>{{ $post->title }}</h1>\n            <span>{{ $post->content }}</span>\n\n            <button wire:click=\"deletePost({{ $post->id }})\">Delete</button>\n        </div>\n    @endforeach\n</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-130","text":"ndforeach\n</div>\n```\n\nAs you can see, we refactored the post deletion logic into a dedicated method named `delete()`. Even though this method isn't referenced anywhere in our template, if a user gained knowledge of its existence, they would be able to call it from the browser's DevTools because it is `public`.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-131","text":"ause it is `public`.\n\nTo remedy this, we can mark the method as `protected` or `private`. Once the method is marked as `protected` or `private`, an error will be thrown if a user tries to invoke it:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse App\\Models\\Post;","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-132","text":"use App\\Models\\Post;\n\nclass BrowsePosts extends Component\n{\n    public function deletePost($id)\n    {\n        if (! Auth::user()->isAdmin) {\n            abort(403);\n        }\n\n        $this->delete($id);\n    }\n\n    protected function delete($postId) // [tl! highlight]\n    {\n        $post = Post::find($postId);\n\n        $post->delete();\n    }","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-133","text":"ost->delete();\n    }\n\n    public function render()\n    {\n        return view('livewire.browse-posts', [\n            'posts' => Post::all(),\n        ]);\n    }\n}\n```\n\n<!--\n## Applying middleware\n\nBy default, Livewire re-applies authentication and authorization related middleware on subsequent requests if those middleware were applied on the initial page load request.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-134","text":"l page load request.\n\nFor example, imagine your component is loaded inside a route that is assigned the `auth` middleware and a user's session ends. When the user triggers another action, the `auth` middleware will be re-applied and the user will receive an error.","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-135","text":"ll receive an error.\n\nIf there are specific middleware that you would like to apply to a specific action, you may do so with the `#[Middleware]` attribute. For example, we could apply a `LogPostCreation` middleware to an action that creates posts:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Http\\Middleware\\LogPostCreation;\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-136","text":" Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public $title;\n\n    public $content;\n\n    #[Middleware(LogPostCreation::class)] // [tl! highlight]\n    public function save()\n    {\n        // Create the post...\n    }\n\n    // ...\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"5a652beac75d5acf7e72ffeac9dd8dc5-137","text":" }\n\n    // ...\n}\n```\n\nNow, the `LogPostCreation` middleware will be applied only to the `createPost` action, ensuring that the activity is only being logged when users create a new post.\n\n-->\n","source":"/Users/fyyx/Documents/livewire/docs/actions.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-0","text":"\nMany modern web applications are built as \"single page applications\" (SPAs). In these applications, each page rendered by the application no longer requires a full browser page reload, avoiding the overhead of re-downloading JavaScript and CSS assets on every request.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-1","text":"ts on every request.\n\nThe alternative to a *single page application* is a *multi-page application*. In these applications, every time a user clicks a link, an entirely new HTML page is requested and rendered in the browser.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-2","text":"ered in the browser.\n\nWhile most PHP applications have traditionally been multi-page applications, Livewire offers a single page application experience via a simple attribute you can add to links in your application: `wire:navigate`.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-3","text":"te`.\n\n## Basic usage\n\nLet's explore an example of using `wire:navigate`. Below is a typical Laravel routes file (`routes/web.php`) with three Livewire components defined as routes:\n\n```php\nuse App\\Livewire\\Dashboard;\nuse App\\Livewire\\ShowPosts;\nuse App\\Livewire\\ShowUsers;\n\nRoute::get('/', Dashboard::class);\n\nRoute::get('/posts', ShowPosts::class);\n\nRoute::get('/users', ShowUsers::class);\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-4","text":"owUsers::class);\n```\n\nBy adding `wire:navigate` to each link in a navigation menu on each page, Livewire will prevent the standard handling of the link click and replace it with its own, faster version:\n\n```blade\n<nav>\n    <a href=\"/\" wire:navigate>Dashboard</a>\n    <a href=\"/posts\" wire:navigate>Posts</a>\n    <a href=\"/users\" wire:navigate>Users</a>\n</nav>\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-5","text":"Users</a>\n</nav>\n```\n\nBelow is a breakdown of what happens when a `wire:navigate` link is clicked:","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-6","text":"te` link is clicked:\n\n* User clicks a link\n* Livewire prevents the browser from visiting the new page\n* Instead, Livewire requests the page in the background and shows a loading bar at the top of the page\n* When the HTML for the new page has been received, Livewire replaces the current page's URL, `<title>` tag and `<body>` contents with the elements from the new page","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-7","text":"ts from the new page\n\nThis technique results in much faster page load times — often twice as fast — and makes the application \"feel\" like a JavaScript powered single page application.\n\n## Redirects","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-8","text":"ation.\n\n## Redirects\n\nWhen one of your Livewire components redirects users to another URL within your application, you can also instruct Livewire to use its `wire:navigate` functionality to load the new page. To accomplish this, provide the `navigate` argument to the `redirect()` method:\n\n```php\nreturn $this->redirect('/posts', navigate: true);\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-9","text":"navigate: true);\n```\n\nNow, instead of a full page request being used to redirect the user to the new URL, Livewire will replace the contents and URL of the current page with the new one.\n\n## Prefetching links\n\nBy default, Livewire includes a gentle strategy to _prefetch_ pages before a user clicks on a link:","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-10","text":"er clicks on a link:\n\n* A user presses down on their mouse button\n* Livewire starts requesting the page\n* They lift up on the mouse button to complete the _click_\n* Livewire finishes the request and navigates to the new page\n\nSurprisingly, the time between a user pressing down and lifting up on the mouse button is often enough time to load half or even an entire page from the server.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-11","text":"age from the server.\n\nIf you want an even more aggressive approach to prefetching, you may use the `.hover` modifier on a link:\n\n```blade\n<a href=\"/posts\" wire:navigate.hover>Posts</a>\n```\n\nThe `.hover` modifier will instruct Livewire to prefetch the page after a user has hovered over the link for `60` milliseconds.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-12","text":"r `60` milliseconds.\n\n> [!warning] Prefetching on hover increases server usage\n> Because not all users will click a link they hover over, adding `.hover` will request pages that may not be needed, though Livewire attempts to mitigate some of this overhead by waiting `60` milliseconds before prefetching the page.\n\n## Persisting elements across page visits","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-13","text":"s across page visits\n\nSometimes, there are parts of a user interface that you need to persist between page loads, such as audio or video players. For example, in a podcasting application, a user may want to keep listening to an episode as they browse other pages.\n\nYou can achieve this in Livewire with the `@persist` directive.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-14","text":"@persist` directive.\n\nBy wrapping an element with `@persist` and providing it with a name, when a new page is requested using `wire:navigate`, Livewire will look for an element on the new page that has a matching `@persist`. Instead of replacing the element like normal, Livewire will use the existing DOM element from the previous page in the new page, preserving any state within the element.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-15","text":" within the element.\n\nHere is an example of an `<audio>` player element being persisted across pages using `@persist`:\n\n```blade\n@persist('player')\n    <audio src=\"{{ $episode->file }}\" controls></audio>\n@endpersist\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-16","text":"dio>\n@endpersist\n```\n\nIf the above HTML appears on both pages — the current page, and the next one — the original element will be re-used on the new page. In the case of an audio player, the audio playback won't be interrupted when navigating from one page to another.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-17","text":"one page to another.\n\nPlease be aware that the persisted element must be placed outside your Livewire components. A common practice is to position the persisted element in your main layout, such as `resources/views/components/layouts/app.blade.php`.\n\n```html\n<!-- resources/views/components/layouts/app.blade.php -->","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-18","text":"ts/app.blade.php -->\n\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n        <title>{{ $title ?? 'Page Title' }}</title>\n    </head>\n    <body>\n        <main>\n            {{ $slot }}\n        </main>","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-19","text":"t }}\n        </main>\n\n        @persist('player') <!-- [tl! highlight:2] -->\n            <audio src=\"{{ $episode->file }}\" controls></audio>\n        @endpersist\n    </body>\n</html>\n```\n\n### Highlighting active links\n\nYou might be used to highlighting the currently active page link in a navbar using server-side Blade like so:","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-20","text":"-side Blade like so:\n\n```blade\n<nav>\n    <a href=\"/\" class=\"@if (request->is('/')) font-bold text-zinc-800 @endif\">Dashboard</a>\n    <a href=\"/posts\" class=\"@if (request->is('/posts')) font-bold text-zinc-800 @endif\">Posts</a>\n    <a href=\"/users\" class=\"@if (request->is('/users')) font-bold text-zinc-800 @endif\">Users</a>\n</nav>\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-21","text":"Users</a>\n</nav>\n```\n\nHowever, this will not work inside persisted elements as they are re-used between page loads. Instead, you should use Livewire's `wire:current` directive to highlight the currently active link.\n\nSimply pass any CSS classes you want to apply to the currently active link to `wire:current`:","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-22","text":"k to `wire:current`:\n\n```blade\n<nav>\n    <a href=\"/dashboard\" ... wire:current=\"font-bold text-zinc-800\">Dashboard</a>\n    <a href=\"/posts\" ... wire:current=\"font-bold text-zinc-800\">Posts</a>\n    <a href=\"/users\" ... wire:current=\"font-bold text-zinc-800\">Users</a>\n</nav>\n```\n\nNow, when the `/posts` page is visited, the \"Posts\" link will have a stronger font treatment than the other links.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-23","text":"han the other links.\n\nRead more in the [`wire:current` documentation](/docs/wire-current).\n\n### Preserving scroll position\n\nBy default, Livewire will preserve the scroll position of a page when navigating back and forth between pages. However, sometimes you may want to preserve the scroll position of an individual element you are persisting between page loads.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-24","text":" between page loads.\n\nTo do this, you must add `wire:scroll` to the element containing a scrollbar like so:\n\n```html\n@persist('scrollbar')\n<div class=\"overflow-y-scroll\" wire:scroll> <!-- [tl! highlight] -->\n    <!-- ... -->\n</div>\n@endpersist\n```\n\n## JavaScript hooks\n\nEach page navigation triggers three lifecycle hooks:\n\n* `livewire:navigate`\n* `livewire:navigating`\n* `livewire:navigated`","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-25","text":"`livewire:navigated`\n\nIt's important to note that these three hooks events are dispatched on navigations of all types. This includes manual navigation using `Livewire.navigate()`, redirecting with navigation enabled, and back and forward button presses in the browser.\n\nHere's an example of registering listeners for each of these events:","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-26","text":"ach of these events:\n\n```js\ndocument.addEventListener('livewire:navigate', (event) => {\n    // Triggers when a navigation is triggered.\n\n    // Can be \"cancelled\" (prevent the navigate from actually being performed):\n    event.preventDefault()\n\n    // Contains helpful context about the navigation trigger:\n    let context = event.detail","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-27","text":"ntext = event.detail\n\n    // A URL object of the intended destination of the navigation...\n    context.url\n\n    // A boolean [true/false] indicating whether or not this navigation\n    // was triggered by a back/forward (history state) navigation...\n    context.history","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-28","text":"\n    context.history\n\n    // A boolean [true/false] indicating whether or not there is\n    // cached version of this page to be used instead of\n    // fetching a new one via a network round-trip...\n    context.cached\n})\n\ndocument.addEventListener('livewire:navigating', () => {\n    // Triggered when new HTML is about to swapped onto the page...","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-29","text":"ped onto the page...\n\n    // This is a good place to mutate any HTML before the page\n    // is navigated away from...\n})\n\ndocument.addEventListener('livewire:navigated', () => {\n    // Triggered as the final step of any page navigation...\n\n    // Also triggered on page-load instead of \"DOMContentLoaded\"...\n})\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-30","text":"entLoaded\"...\n})\n```\n\n> [!warning] Event listeners will persist across pages\n>","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-31","text":"rsist across pages\n>\n> When you attach an event listener to the document it will not be removed when you navigate to a different page. This can lead to unexpected behaviour if you need code to run only after navigating to a specific page, or if you add the same event listener on every page","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-32","text":"stener on every page. If you do not remove your event listener it may cause exceptions on other pages when it's looking for elements that do not exist, or you may end up with the event listener executing multiple times per navigation.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-33","text":"imes per navigation.\n>\n> An easy method to remove an event listener after it runs is to pass the option `{once: true}` as a third parameter to the `addEventListener` function.\n> ```js\n> document.addEventListener('livewire:navigated', () => {\n>     // ...\n> }, { once: true })\n> ```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-34","text":" once: true })\n> ```\n\n## Manually visiting a new page\n\nIn addition to `wire:navigate`, you can manually call the `Livewire.navigate()` method to trigger a visit to a new page using JavaScript:\n\n```html\n<script>\n    // ...\n\n    Livewire.navigate('/new/url')\n</script>\n```\n\n## Using with analytics software","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-35","text":"h analytics software\n\nWhen navigating pages using `wire:navigate` in your app, any `<script>` tags in the `<head>` only evaluate when the page is initially loaded.\n\nThis creates a problem for analytics software such as [Fathom Analytics](https://usefathom.com/). These tools rely on a `<script>` snippet being evaluated on every single page change, not just the first.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-36","text":" not just the first.\n\nTools like [Google Analytics](https://marketingplatform.google.com/about/analytics/) are smart enough to handle this automatically, however, when using Fathom Analytics, you must add `data-spa=\"auto\"` to your script tag to ensure each page visit is tracked properly:\n\n```blade\n<head>\n    <!-- ... -->","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-37","text":"ad>\n    <!-- ... -->\n\n    <!-- Fathom Analytics -->\n    @if (! config('app.debug'))\n        <script src=\"https://cdn.usefathom.com/script.js\" data-site=\"ABCDEFG\" data-spa=\"auto\" defer></script> <!-- [tl! highlight] -->\n    @endif\n</head>\n```\n\n## Script evaluation","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-38","text":"## Script evaluation\n\nWhen navigating to a new page using `wire:navigate`, it _feels_ like the browser has changed pages; however, from the browser's perspective, you are technically still on the original page.\n\nBecause of this, styles and scripts are executed normally on the first page, but on subsequent pages, you may have to tweak the way you normally write JavaScript.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-39","text":"ly write JavaScript.\n\nHere are a few caveats and scenarios you should be aware of when using `wire:navigate`.\n\n### Don't rely on `DOMContentLoaded`\n\nIt's common practice to place JavaScript inside a `DOMContentLoaded` event listener so that the code you want to run only executes after the page has fully loaded.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-40","text":"ge has fully loaded.\n\nWhen using `wire:navigate`, `DOMContentLoaded` is only fired on the first page visit, not subsequent visits.\n\nTo run code on every page visit, swap every instance of `DOMContentLoaded` with `livewire:navigated`:\n\n```js\ndocument.addEventListener('DOMContentLoaded', () => { // [tl! remove]\ndocument.addEventListener('livewire:navigated', () => { // [tl! add]\n    // ...\n})\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-41","text":"d]\n    // ...\n})\n```\n\nNow, any code placed inside this listener will be run on the initial page visit, and also after Livewire has finished navigating to subsequent pages.\n\nListening to this event is useful for things like initializing third-party libraries.\n\n### Scripts in `<head>` are loaded once","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-42","text":"ad>` are loaded once\n\nIf two pages include the same `<script>` tag in the `<head>`, that script will only be run on the initial page visit and not on subsequent page visits.\n\n```blade\n<!-- Page one -->\n<head>\n    <script src=\"/app.js\"></script>\n</head>\n\n<!-- Page two -->\n<head>\n    <script src=\"/app.js\"></script>\n</head>\n```\n\n### New `<head>` scripts are evaluated","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-43","text":"cripts are evaluated\n\nIf a subsequent page includes a new `<script>` tag in the `<head>` that was not present in the `<head>` of the initial page visit, Livewire will run the new `<script>` tag.\n\nIn the below example, _page two_ includes a new JavaScript library for a third-party tool. When the user navigates to _page two_, that library will be evaluated.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-44","text":"y will be evaluated.\n\n```blade\n<!-- Page one -->\n<head>\n    <script src=\"/app.js\"></script>\n</head>\n\n<!-- Page two -->\n<head>\n    <script src=\"/app.js\"></script>\n    <script src=\"/third-party.js\"></script>\n</head>\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-45","text":"/script>\n</head>\n```\n\n> [!info] Head assets are blocking\n> If you are navigating to a new page that contains an asset like `<script src=\"...\">` in the head tag. That asset will be fetched and processed before the navigation is complete and the new page is swapped in. This might be surprising behavior, but it ensures any scripts that depend on those assets will have immediate access to them.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-46","text":"iate access to them.\n\n### Reloading when assets change\n\nIt's common practice to include a version hash in an application's main JavaScript file name. This ensures that after deploying a new version of your application, users will receive the fresh JavaScript asset, and not an old version served from the browser's cache.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-47","text":"the browser's cache.\n\nBut, now that you are using `wire:navigate` and each page visit is no longer a fresh browser page load, your users may still be receiving stale JavaScript after deployments.\n\nTo prevent this, you may add `data-navigate-track` to a `<script>` tag in `<head>`:\n\n```blade\n<!-- Page one -->\n<head>\n    <script src=\"/app.js?id=123\" data-navigate-track></script>\n</head>","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-48","text":"ck></script>\n</head>\n\n<!-- Page two -->\n<head>\n    <script src=\"/app.js?id=456\" data-navigate-track></script>\n</head>\n```\n\nWhen a user visits _page two_, Livewire will detect a fresh JavaScript asset and trigger a full browser page reload.","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-49","text":"browser page reload.\n\nIf you are using [Laravel's Vite plug-in](https://laravel.com/docs/vite#loading-your-scripts-and-styles) to bundle and serve your assets, Livewire adds `data-navigate-track` to the rendered HTML asset tags automatically. You can continue referencing your assets and scripts like normal:\n\n```blade\n<head>\n    @vite(['resources/css/app.css', 'resources/js/app.js'])\n</head>\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-50","text":"pp.js'])\n</head>\n```\n\nLivewire will automatically inject `data-navigate-track` onto the rendered HTML tags.\n\n> [!warning] Only query string changes are tracked\n> Livewire will only reload a page if a `[data-navigate-track]` element's query string (`?id=\"456\"`) changes, not the URI itself (`/app.js`).\n\n### Scripts in the `<body>` are re-evaluated","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-51","text":"y>` are re-evaluated\n\nBecause Livewire replaces the entire contents of the `<body>` on every new page, all `<script>` tags on the new page will be run:\n\n```blade\n<!-- Page one -->\n<body>\n    <script>\n        console.log('Runs on page one')\n    </script>\n</body>\n\n<!-- Page two -->\n<body>\n    <script>\n        console.log('Runs on page two')\n    </script>\n</body>\n```","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-52","text":"/script>\n</body>\n```\n\nIf you have a `<script>` tag in the body that you only want to be run once, you can add the `data-navigate-once` attribute to the `<script>` tag and Livewire will only run it on the initial page visit:\n\n```blade\n<script data-navigate-once>\n    console.log('Runs only on page one')\n</script>\n```\n\n## Customizing the progress bar","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"64cbfd3fd3b5e24ec70a2b21e93108e2-53","text":"ing the progress bar\n\nWhen a page takes longer than 150ms to load, Livewire will show a progress bar at the top of the page.\n\nYou can customize the color of this bar or disable it all together inside Livewire's config file (`config/livewire.php`):\n\n```php\n'navigate' => [\n    'show_progress_bar' => false,\n    'progress_bar_color' => '#2299dd',\n],\n```\n","source":"/Users/fyyx/Documents/livewire/docs/navigate.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-0","text":"\nFile downloads in Livewire work much the same as in Laravel itself. Typically, you can use any Laravel download utility inside a Livewire component, and it should work as expected.","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-1","text":"ld work as expected.\n\nHowever, behind the scenes, file downloads are handled differently than in a standard Laravel application. When using Livewire, the file's contents are Base64 encoded, sent to the frontend, and decoded back into binary to be downloaded directly from the client.\n\n## Basic usage","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-2","text":"ent.\n\n## Basic usage\n\nTriggering a file download in Livewire is as simple as returning a standard Laravel download response.\n\nBelow is an example of a `ShowInvoice` component that contains a \"Download\" button to download the invoice PDF:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Invoice;\n\nclass ShowInvoice extends Component\n{\n    public Invoice $invoice;","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-3","text":"ic Invoice $invoice;\n\n    public function mount(Invoice $invoice)\n    {\n        $this->invoice = $invoice;\n    }\n\n    public function download()\n    {\n        return response()->download( // [tl! highlight:2]\n            $this->invoice->file_path, 'invoice.pdf'\n        );\n    }\n\n    public function render()\n    {\n        return view('livewire.show-invoice');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-4","text":"voice');\n    }\n}\n```\n\n```blade\n<div>\n    <h1>{{ $invoice->title }}</h1>\n\n    <span>{{ $invoice->date }}</span>\n    <span>{{ $invoice->amount }}</span>\n\n    <button type=\"button\" wire:click=\"download\">Download</button> <!-- [tl! highlight] -->\n</div>\n```\n\nJust like in a Laravel controller, you can also use the `Storage` facade to initiate downloads:","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-5","text":" initiate downloads:\n\n```php\npublic function download()\n{\n    return Storage::disk('invoices')->download('invoice.csv');\n}\n```\n\n## Streaming downloads\n\nLivewire can also stream downloads; however, they aren't truly streamed. The download isn't triggered until the file's contents are collected and delivered to the browser:","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-6","text":"ered to the browser:\n\n```php\npublic function download()\n{\n    return response()->streamDownload(function () {\n        echo '...'; // Echo download contents directly...\n    }, 'invoice.pdf');\n}\n```\n\n## Testing file downloads\n\nLivewire also provides a `->assertFileDownloaded()` method to easily test that a file was downloaded with a given name:\n\n```php\nuse App\\Models\\Invoice;","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-7","text":" App\\Models\\Invoice;\n\npublic function test_can_download_invoice()\n{\n    $invoice = Invoice::factory();\n\n    Livewire::test(ShowInvoice::class)\n        ->call('download')\n        ->assertFileDownloaded('invoice.pdf');\n}\n```\n\nYou can also test to ensure a file was not downloaded using the `->assertNoFileDownloaded()` method:\n\n```php\nuse App\\Models\\Invoice;","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"08fdcbcfbc20b7fa757b7b9a17441835-8","text":" App\\Models\\Invoice;\n\npublic function test_does_not_download_invoice_if_unauthorised()\n{\n    $invoice = Invoice::factory();\n\n    Livewire::test(ShowInvoice::class)\n        ->call('download')\n        ->assertNoFileDownloaded();\n}\n```\n","source":"/Users/fyyx/Documents/livewire/docs/downloads.md"}
{"id":"94532cc43afabc8798910987aea60071-0","text":"\nWhen a Livewire component updates the browser's DOM, it does so in an intelligent way we call \"morphing\". The term _morph_ is in contrast with a word like _replace_.","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-1","text":"word like _replace_.\n\nInstead of _replacing_ a component's HTML with newly rendered HTML every time a component is updated, Livewire dynamically compares the current HTML with the new HTML, identifies differences, and makes surgical changes to the HTML only in the places where changes are needed.","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-2","text":" changes are needed.\n\nThis has the benefit of preserving existing, un-changed elements on a component. For example, event listeners, focus state, and form input values are all preserved between Livewire updates. Of course, morphing also offers increased performance compared to wiping and re-rending new DOM on every update.\n\n## How morphing works","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-3","text":"# How morphing works\n\nTo understand how Livewire determines which elements to update between Livewire requests, consider this simple `Todos` component:\n\n```php\nclass Todos extends Component\n{\n    public $todo = '';\n\n    public $todos = [\n        'first',\n        'second',\n    ];\n\n    public function add()\n    {\n        $this->todos[] = $this->todo;\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-4","text":"s->todo;\n    }\n}\n```\n\n```blade\n<form wire:submit=\"add\">\n    <ul>\n        @foreach ($todos as $item)\n            <li>{{ $item }}</li>\n        @endforeach\n    </ul>\n\n    <input wire:model=\"todo\">\n</form>\n```\n\nThe initial render of this component will output the following HTML:\n\n```html\n<form wire:submit=\"add\">\n    <ul>\n        <li>first</li>\n\n        <li>second</li>\n    </ul>","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-5","text":"econd</li>\n    </ul>\n\n    <input wire:model=\"todo\">\n</form>\n```\n\nNow, imagine you typed \"third\" into the input field and pressed the `[Enter]` key. The newly rendered HTML would be:\n\n```html\n<form wire:submit=\"add\">\n    <ul>\n        <li>first</li>\n\n        <li>second</li>\n\n        <li>third</li> <!-- [tl! add] -->\n    </ul>\n\n    <input wire:model=\"todo\">\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-6","text":"=\"todo\">\n</form>\n```\n\nWhen Livewire processes the component update, it _morphs_ the original DOM into the newly rendered HTML. The following visualization should intuitively give you an understanding of how it works:","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-7","text":"ing of how it works:\n","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-8","text":"ng of how it works:\n\n<div style=\"padding:56.25% 0 0 0;position:relative;\"><iframe src=\"https://player.vimeo.com/video/844600772?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen style=\"position:absolute;top:0;left:0;width:100%;height:100%;\" title=\"morph_basic\"></iframe></div><script","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-9","text":"iframe></div><script src=\"https://player.vimeo.com/api/player.js\"></script>","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-10","text":"player.js\"></script>\n\nAs you can see, Livewire walks both HTML trees simultaneously. As it encounters each element in both trees, it compares them for changes, additions, and removals. If it detects one, it surgically makes the appropriate change.\n\n## Morphing shortcomings","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-11","text":"orphing shortcomings\n\nThe following are scenarios where morphing algorithms fail to correctly identify the change in HTML trees and therefore cause problems in your application.\n\n### Inserting intermediate elements\n\nConsider the following Livewire Blade template for a fictitious `CreatePost` component:\n\n```blade\n<form wire:submit=\"save\">\n    <div>\n        <input wire:model=\"title\">\n    </div>","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-12","text":"=\"title\">\n    </div>\n\n    @if ($errors->has('title'))\n        <div>{{ $errors->first('title') }}</div>\n    @endif\n\n    <div>\n        <button>Save</button>\n    </div>\n</form>\n```\n\nIf a user tries submitting the form, but encounters a validation error, the following problem occurs:","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-13","text":"wing problem occurs:\n","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-14","text":"ing problem occurs:\n\n<div style=\"padding:56.25% 0 0 0;position:relative;\"><iframe src=\"https://player.vimeo.com/video/844600840?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen style=\"position:absolute;top:0;left:0;width:100%;height:100%;\" title=\"morph_problem\"></iframe></div><script","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-15","text":"iframe></div><script src=\"https://player.vimeo.com/api/player.js\"></script>","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-16","text":"player.js\"></script>\n\nAs you can see, when Livewire encounters the new `<div>` for the error message, it doesn't know whether to change the existing `<div>` in-place, or insert the new `<div>` in the middle.\n\nTo re-iterate what's happening more explicitly:","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-17","text":"ing more explicitly:\n\n* Livewire encounters the first `<div>` in both trees. They are the same, so it continues.\n* Livewire encounters the second `<div>` in both trees and thinks they are the same `<div>`, just one has changed contents. So instead of inserting the error message as a new element, it changes the `<button>` into an error message.","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-18","text":"to an error message.\n* Livewire then, after mistakenly modifying the previous element, notices an additional element at the end of the comparison. It then creates and appends the element after the previous one.\n* Therefore, destroying, then re-creating an element that otherwise should have been simply moved.","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-19","text":"e been simply moved.\n\nThis scenario is at the root of almost all morph-related bugs.","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-20","text":" morph-related bugs.\n\nHere are a few specific problematic impacts of these bugs:\n* Event listeners and element state are lost between updates\n* Event listeners and state are misplaced across the wrong elements\n* Entire Livewire components can be reset or duplicated as Livewire components are also simply elements in the DOM tree\n* Alpine components and state can be lost or misplaced","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-21","text":"be lost or misplaced\n\nFortunately, Livewire has worked hard to mitigate these problems using the following approaches:\n\n### Internal look-ahead\n\nLivewire has an additional step in its morphing algorithm that checks subsequent elements and their contents before changing an element.\n\nThis prevents the above scenario from happening in many cases.","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-22","text":"ening in many cases.\n\nHere is a visualization of the \"look-ahead\" algorithm in action:","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-23","text":"algorithm in action:\n","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-24","text":"lgorithm in action:\n\n<div style=\"padding:56.25% 0 0 0;position:relative;\"><iframe src=\"https://player.vimeo.com/video/844600800?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen style=\"position:absolute;top:0;left:0;width:100%;height:100%;\" title=\"morph_lookahead\"></iframe></div><script","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-25","text":"iframe></div><script src=\"https://player.vimeo.com/api/player.js\"></script>","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-26","text":"player.js\"></script>\n\n### Injecting morph markers\n\nOn the backend, Livewire automatically detects conditionals inside Blade templates and wraps them in HTML comment markers that Livewire's JavaScript can use as a guide when morphing.\n\nHere's an example of the previous Blade template but with Livewire's injected markers:","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-27","text":"'s injected markers:\n\n```blade\n<form wire:submit=\"save\">\n    <div>\n        <input wire:model=\"title\">\n    </div>\n\n    <!--[if BLOCK]><![endif]--> <!-- [tl! highlight] -->\n    @if ($errors->has('title'))\n        <div>Error: {{ $errors->first('title') }}</div>\n    @endif\n    <!--[if ENDBLOCK]><![endif]--> <!-- [tl! highlight] -->\n\n    <div>\n        <button>Save</button>\n    </div>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-28","text":"  </div>\n</form>\n```\n\nWith these markers injected into the template, Livewire can now more easily detect the difference between a change and an addition.","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-29","text":"nge and an addition.\n\nThis feature is extremely beneficial to Livewire applications, but because it requires parsing templates via regex, it can sometimes fail to properly detect conditionals. If this feature is more of a hindrance than a help to your application, you can disable it with the following configuration in your application's `config/livewire.php` file:","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-30","text":"/livewire.php` file:\n\n```php\n'inject_morph_markers' => false,\n```\n\n#### Wrapping conditionals\n\nIf the above two solutions don't cover your situation, the most reliable way to avoid morphing problems is to wrap conditionals and loops in their own elements that are always present.\n\nFor example, here's the above Blade template rewritten with wrapping `<div>` elements:","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-31","text":"ng `<div>` elements:\n\n```blade\n<form wire:submit=\"save\">\n    <div>\n        <input wire:model=\"title\">\n    </div>\n\n    <div> <!-- [tl! highlight] -->\n        @if ($errors->has('title'))\n            <div>{{ $errors->first('title') }}</div>\n        @endif\n    </div> <!-- [tl! highlight] -->\n\n    <div>\n        <button>Save</button>\n    </div>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"94532cc43afabc8798910987aea60071-32","text":"  </div>\n</form>\n```\n\nNow that the conditional has been wrapped in a persistent element, Livewire will morph the two different HTML trees properly.\n\n#### Bypassing morphing\n\nIf you need to bypass morphing entirely for an element, you can use [wire:replace](/docs/wire-replace) to instruct livewire to replace all children of an element instead of attempting to morph the existing elements.","source":"/Users/fyyx/Documents/livewire/docs/morph.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-0","text":"\n## Automated upgrade tool\n\nTo save you time upgrading, we've included an Artisan command to automate as many parts of the upgrade process as possible.\n\nAfter [installing Livewire version 3](/docs/upgrading#update-livewire-to-version-3), run the following command, and you will receive prompts to upgrade each breaking change automatically:\n\n```shell\nphp artisan livewire:upgrade\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-1","text":"livewire:upgrade\n```\n\nAlthough the above command can upgrade much of your application, the only way to ensure a complete upgrade is to follow the step-by-step guide on this page.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-2","text":" guide on this page.\n\n> [!tip] Hire us to upgrade your app instead\n> If you have a large Livewire application or just don't want to deal with upgrading from version 2 to version 3, you can hire us to handle it for you. [Learn more about our upgrade service here.](/jumpstart)\n\n## Upgrade PHP\n\nLivewire now requires that your application is running on PHP version 8.1 or greater.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-3","text":"sion 8.1 or greater.\n\n## Update Livewire to version 3\n\nRun the following composer command to upgrade your application's Livewire dependency from version 2 to 3:\n\n```shell\ncomposer require livewire/livewire \"^3.0\"\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-4","text":"/livewire \"^3.0\"\n```\n\n> [!warning] Livewire 3 package compatibility\n> Most of the major third-party Livewire packages either currently support Livewire 3 or are working on supporting it soon. However, there will inevitably be packages that take longer to release support for Livewire 3.\n\n## Clear the view cache","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-5","text":"Clear the view cache\n\nRun the following Artisan command from your application's root directory to clear any cached/compiled Blade views and force Livewire to re-compile them to be Livewire 3 compatible:\n\n```shell\nphp artisan view:clear\n```\n\n## Merge new configuration","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-6","text":"ge new configuration\n\nLivewire 3 has changed multiple configuration options. If your application has a published configuration file (`config/livewire.php`), you will need to update it to account for the following changes.\n\n### New configuration\n\nThe following configuration keys have been introduced in version 3:\n\n```php\n'legacy_model_binding' => false,\n\n'inject_assets' => true,","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-7","text":"ect_assets' => true,\n\n'inject_morph_markers' => true,\n\n'navigate' => false,\n\n'pagination_theme' => 'tailwind',\n```\n\nYou can reference [Livewire's new configuration file on GitHub](https://github.com/livewire/livewire/blob/master/config/livewire.php) for additional option descriptions and copy-pastable code.\n\n### Changed configuration","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-8","text":"hanged configuration\n\nThe following configuration items have been updated with new default values:\n\n#### New class namespace","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-9","text":" New class namespace\n\nLivewire's default `class_namespace` has changed from `App\\Http\\Livewire` to `App\\Livewire`. You are welcome to keep the old namespace configuration value; however, if you choose to update your configuration to the new namespace, you will have to move your Livewire components to `app/Livewire`:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-10","text":"s to `app/Livewire`:\n\n```php\n'class_namespace' => 'App\\\\Http\\\\Livewire', // [tl! remove]\n'class_namespace' => 'App\\\\Livewire', // [tl! add]\n```\n\n#### New layout view path\n\nWhen rendering full-page components in version 2, Livewire would use `resources/views/layouts/app.blade.php` as the default layout Blade component.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-11","text":"out Blade component.\n\nBecause of a growing community preference for anonymous Blade components, Livewire 3 has changed the default location to: `resources/views/components/layouts/app.blade.php`.\n\n```php\n'layout' => 'layouts.app', // [tl! remove]\n'layout' => 'components.layouts.app', // [tl! add]\n```\n\n### Removed configuration\n\nLivewire no longer recognizes the following configuration items.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-12","text":"configuration items.\n\n#### `app_url`\n\nIf your application is served under a non-root URI, in Livewire 2 you could use the `app_url` configuration option to configure the URL Livewire uses to make AJAX requests to.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-13","text":"ke AJAX requests to.\n\nIn this case, we've found a string configuration to be too rigid. Therefore, Livewire 3 has chosen to use runtime configuration instead. You can reference our documentation on [configuring Livewire's update endpoint](/docs/installation#configuring-livewires-update-endpoint) for more information.\n\n#### `asset_url`","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-14","text":"n.\n\n#### `asset_url`\n\nIn Livewire 2, if your application was served under a non-root URI, you would use the `asset_url` configuration option to configure the base URL that Livewire uses to serve its JavaScript assets.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-15","text":"s JavaScript assets.\n\nLivewire 3 has instead chosen a runtime configuration strategy. You can reference our documentation on [configuring Livewire's script asset endpoint](/docs/installation#customizing-the-asset-url) for more information.\n\n#### `middleware_group`","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-16","text":"# `middleware_group`\n\nBecause Livewire now exposes a more flexible way to customize its update endpoint, the `middleware_group` configuration option has been removed.\n\nYou can reference our documentation on [customizing Livewire's update endpoint](/docs/installation#configuring-livewires-update-endpoint) for more information on applying custom middleware to Livewire requests.\n\n#### `manifest_path`","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-17","text":"#### `manifest_path`\n\nLivewire 3 no longer uses a manifest file for component autoloading. Therefore, the `manifest_path` configuration is no longer necessary.\n\n#### `back_button_cache`\n\nBecause Livewire 3 now offers an [SPA experience for your application using `wire:navigate`](/docs/navigate), the `back_button_cache` configuration is no longer necessary.\n\n## Livewire app namespace","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-18","text":"vewire app namespace\n\nIn version 2, Livewire components were generated and recognized automatically under the `App\\Http\\Livewire` namespace.\n\nLivewire 3 has changed this default to: `App\\Livewire`.\n\nYou can either move all of your components to the new location or add the following configuration to your application's `config/livewire.php` configuration file:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-19","text":" configuration file:\n\n```php\n'class_namespace' => 'App\\\\Http\\\\Livewire',\n```\n\n### Discovery\n\nWith Livewire 3, there is no manifest present, and there is therefore nothing to “discover” in relation to Livewire Components, and you can safely remove any livewire:discover references from your build scripts without issue.\n\n## Page component layout view","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-20","text":"omponent layout view\n\nWhen rendering Livewire components as full pages using a syntax like the following:\n\n```php\nRoute::get('/posts', ShowPosts::class);\n```\n\nThe Blade layout file used by Livewire to render the component has changed from `resources/views/layouts/app.blade.php` to `resources/views/components/layouts/app.blade.php`:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-21","text":"outs/app.blade.php`:\n\n```shell\nresources/views/layouts/app.blade.php #[tl! remove]\nresources/views/components/layouts/app.blade.php #[tl! add]\n```\n\nYou can either move your layout file to the new location or apply the following configuration inside your application's `config/livewire.php` configuration file:\n\n```php\n'layout' => 'layouts.app',\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-22","text":"> 'layouts.app',\n```\n\nFor more information, check out the documentation on [creating and using a page-component layout](/docs/components#layout-files).","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-23","text":"nents#layout-files).\n\n\n## Eloquent model binding\n\nLivewire 2 supported `wire:model` binding directly to Eloquent model properties. For example, the following was a common pattern:\n\n```php\npublic Post $post;\n\nprotected $rules = [\n    'post.title' => 'required',\n    'post.description' => 'required',\n];\n```\n\n```html\n<input wire:model=\"post.title\">\n<input wire:model=\"post.description\">\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-24","text":"st.description\">\n```\n\nIn Livewire 3, binding directly to Eloquent models has been disabled in favor of using individual properties, or extracting [Form Objects](/docs/forms#extracting-a-form-object).\n\nHowever, because this behavior is so heavily relied upon in Livewire applications, version 3 maintains support for this behavior via a configuration item in `config/livewire.php`:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-25","text":"onfig/livewire.php`:\n\n```php\n'legacy_model_binding' => true,\n```\n\nBy setting `legacy_model_binding` to `true`, Livewire will handle Eloquent model properties exactly as it did in version 2.\n\n## AlpineJS\n\nLivewire 3 ships with [AlpineJS](https://alpinejs.dev) by default.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-26","text":"ejs.dev) by default.\n\nIf you manually include Alpine in your Livewire application, you will need to remove it, so that Livewire's built-in version doesn't conflict.\n\n### Including Alpine via a script tag\n\nIf you include Alpine into your application via a script tag like the following, you can remove it entirely and Livewire will load its internal version instead:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-27","text":"nal version instead:\n\n```html\n<script defer src=\"https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js\"></script> <!-- [tl! remove] -->\n```\n\n### Including plugins via a script tag\n\nLivewire 3 now ships with the following Alpine plugins out-of-the-box:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-28","text":"gins out-of-the-box:\n\n* [Anchor](https://alpinejs.dev/plugins/anchor)\n* [Collapse](https://alpinejs.dev/plugins/collapse)\n* [Focus](https://alpinejs.dev/plugins/focus)\n* [Intersect](https://alpinejs.dev/plugins/intersect)\n* [Mask](https://alpinejs.dev/plugins/mask)\n* [Morph](https://alpinejs.dev/plugins/morph)\n* [Persist](https://alpinejs.dev/plugins/persist)","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-29","text":"dev/plugins/persist)\n\nIt is worth keeping an eye on changes to the [package.json](https://github.com/livewire/livewire/blob/main/package.json) file, as new Alpine plugins may be added!\n\nIf you have previously included any of these in your application via `<script>` tags like below, you should remove them along with Alpine's core:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-30","text":" with Alpine's core:\n\n```html\n<script defer src=\"https://cdn.jsdelivr.net/npm/@alpinejs/intersect@3.x.x/dist/cdn.min.js\"></script> <!-- [tl! remove:1] -->\n<!-- ... -->\n```\n\n### Accessing the Alpine global via a script tag\n\nIf you are currently accessing the `Alpine` global object from a script tag like so:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-31","text":" script tag like so:\n\n```html\n<script>\n    document.addEventListener('alpine:init', () => {\n        Alpine.data(...)\n    })\n</script>\n```\n\nYou may continue to do so, as Livewire internally includes and registers Alpine's global object like before.\n\n### Including via JS bundle","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-32","text":"luding via JS bundle\n\nIf you have included Alpine or any of the popular core Alpine plugins mentioned above via NPM into your applications JavaScript bundle like so:\n\n```js\n// Warning: this is a snippet of the Livewire 2 approach to including Alpine\n\nimport Alpine from 'alpinejs'\nimport intersect from '@alpinejs/intersect'\n\nAlpine.plugin(intersect)\n\nAlpine.start()\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-33","text":"\n\nAlpine.start()\n```\n\nYou can remove them entirely, because Livewire includes Alpine and many popular Alpine plugins by default.\n\n#### Accessing Alpine via JS bundle\n\nIf you are registering custom Alpine plugins or components inside your application's JavaScript bundle like so:\n\n```js\n// Warning: this is a snippet of the Livewire 2 approach to including Alpine","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-34","text":" to including Alpine\n\nimport Alpine from 'alpinejs'\nimport customPlugin from './plugins/custom-plugin'\n\nAlpine.plugin(customPlugin)\n\nAlpine.start()\n```\n\nYou can still accomplish this by importing the Livewire core ESM module into your bundle and accessing `Alpine` from there.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-35","text":"`Alpine` from there.\n\nTo import Livewire into your bundle, you must first disable Livewire's normal JavaScript injection and provide the necessary configuration to Livewire by replacing `@livewireScripts` with `@livewireScriptConfig` in your application's primary layout:\n\n```blade\n    <!-- ... -->\n\n    @livewireScripts <!-- [tl! remove] -->\n    @livewireScriptConfig <!-- [tl! add] -->\n</body>\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-36","text":"add] -->\n</body>\n```\n\nNow, you can import `Alpine` and `Livewire` into your application's bundle like so:\n\n```js\nimport { Livewire, Alpine } from '../../vendor/livewire/livewire/dist/livewire.esm';\nimport customPlugin from './plugins/custom-plugin'\n\nAlpine.plugin(customPlugin)\n\nLivewire.start()\n```\n\nNotice you no longer need to call `Alpine.start()`. Livewire will start Alpine automatically.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-37","text":"lpine automatically.\n\nFor more information, please consult our documentation on [manually bundling Livewire's JavaScript](/docs/installation#manually-bundling-livewire-and-alpine).\n\n## `wire:model`\n\nIn Livewire 3, `wire:model` is \"deferred\" by default (instead of by `wire:model.defer`). To achieve the same behavior as `wire:model` from Livewire 2, you must use `wire:model.live`.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-38","text":"e `wire:model.live`.\n\nBelow is a list of the necessary substitutions you will need to make in your templates to keep your application's behavior consistent:\n\n```html\n<input wire:model=\"...\"> <!-- [tl! remove] -->\n<input wire:model.live=\"...\"> <!-- [tl! add] -->\n\n<input wire:model.defer=\"...\"> <!-- [tl! remove] -->\n<input wire:model=\"...\"> <!-- [tl! add] -->","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-39","text":"> <!-- [tl! add] -->\n\n<input wire:model.lazy=\"...\"> <!-- [tl! remove] -->\n<input wire:model.blur=\"...\"> <!-- [tl! add] -->\n```\n\n## `@entangle`\n\nSimilar to the changes to `wire:model`, Livewire 3 defers all data binding by default. To match this behavior, `@entangle` has been updated as well.\n\nTo keep your application running as expected, make the following `@entangle` substitutions:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-40","text":"ngle` substitutions:\n\n```blade\n@entangle(...) <!-- [tl! remove] -->\n@entangle(...).live <!-- [tl! add] -->\n\n@entangle(...).defer <!-- [tl! remove] -->\n@entangle(...) <!-- [tl! add] -->\n```\n\n## Events\n\nIn Livewire 2, Livewire had two different PHP methods for triggering events:\n\n* `emit()`\n* `dispatchBrowserEvent()`\n\nLivewire 3 has unified these two methods into a single method:\n\n* `dispatch()`","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-41","text":"hod:\n\n* `dispatch()`\n\nHere is a basic example of dispatching and listening for an event in Livewire 3:\n\n```php\n// Dispatching...\nclass CreatePost extends Component\n{\n    public Post $post;\n\n    public function save()\n    {\n        $this->dispatch('post-created', postId: $this->post->id);\n    }\n}","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-42","text":"->post->id);\n    }\n}\n\n// Listening...\nclass Dashboard extends Component\n{\n    #[On('post-created')]\n    public function postAdded($postId)\n    {\n        //\n    }\n}\n```\n\nThe three main changes from Livewire 2 are:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-43","text":"from Livewire 2 are:\n\n1. `emit()` has been renamed to `dispatch()` (Likewise `emitTo()` and `emitSelf()` are now `dispatchTo()` and `dispatchSelf()`)\n2. `dispatchBrowserEvent()` has been renamed to `dispatch()`\n3. All event parameters must be named\n\nFor more information, check out the new [events documentation page](/docs/events).","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-44","text":"page](/docs/events).\n\nHere are the \"find and replace\" differences that should be applied to your application:\n\n```php\n$this->emit('post-created'); // [tl! remove]\n$this->dispatch('post-created'); // [tl! add]\n\n$this->emitTo('foo', 'post-created'); // [tl! remove]\n$this->dispatch('post-created')->to('foo'); // [tl! add]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-45","text":"'foo'); // [tl! add]\n\n$this->emitSelf('post-created'); // [tl! remove]\n$this->dispatch('post-created')->self(); // [tl! add]\n\n$this->emit('post-created', $post->id); // [tl! remove]\n$this->dispatch('post-created', postId: $post->id); // [tl! add]\n\n$this->dispatchBrowserEvent('post-created'); // [tl! remove]\n$this->dispatch('post-created'); // [tl! add]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-46","text":"ated'); // [tl! add]\n\n$this->dispatchBrowserEvent('post-created', ['postId' => $post->id]); // [tl! remove]\n$this->dispatch('post-created', postId: $post->id); // [tl! add]\n```\n\n```html\n<button wire:click=\"$emit('post-created')\">...</button> <!-- [tl! remove] -->\n<button wire:click=\"$dispatch('post-created')\">...</button> <!-- [tl! add] -->","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-47","text":"> <!-- [tl! add] -->\n\n<button wire:click=\"$emit('post-created', 1)\">...</button> <!-- [tl! remove] -->\n<button wire:click=\"$dispatch('post-created', { postId: 1 })\">...</button> <!-- [tl! add] -->\n\n<button wire:click=\"$emitTo('foo', post-created', 1)\">...</button> <!-- [tl! remove] -->\n<button wire:click=\"$dispatchTo('foo', 'post-created', { postId: 1 })\">...</button> <!-- [tl! add] -->","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-48","text":"> <!-- [tl! add] -->\n\n<button x-on:click=\"$wire.emit('post-created', 1)\">...</button> <!-- [tl! remove] -->\n<button x-on:click=\"$dispatch('post-created', { postId: 1 })\">...</button> <!-- [tl! add] -->\n```\n\n### `emitUp()`\n\nThe concept of `emitUp` has been removed entirely. Events are now dispatched using browser events and therefore will \"bubble up\" by default.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-49","text":"bble up\" by default.\n\nYou can remove any instances of `$this->emitUp(...)` or `$emitUp(...)` from your components.\n\n### Testing events\n\nLivewire has also changed event assertions to match the new unified terminology regarding dispatching events:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-50","text":" dispatching events:\n\n```php\nLivewire::test(Component::class)->assertEmitted('post-created'); // [tl! remove]\nLivewire::test(Component::class)->assertDispatched('post-created'); // [tl! add]\n\nLivewire::test(Component::class)->assertEmittedTo(Foo::class, 'post-created'); // [tl! remove]\nLivewire::test(Component::class)->assertDispatchedTo(Foo:class, 'post-created'); // [tl! add]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-51","text":"ated'); // [tl! add]\n\nLivewire::test(Component::class)->assertNotEmitted('post-created'); // [tl! remove]\nLivewire::test(Component::class)->assertNotDispatched('post-created'); // [tl! add]\n\nLivewire::test(Component::class)->assertEmittedUp() // [tl! remove]\n```\n\n### URL query string","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-52","text":"### URL query string\n\nIn previous Livewire versions, if you bound a property to the URL's query string, the property value would always be present in the query string, unless you used the `except` option.\n\nIn Livewire 3, all properties bound to the query string will only show up if their value has been changed after the page load. This default removes the need for the `except` option:","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-53","text":"the `except` option:\n\n```php\npublic $search = '';\n\nprotected $queryString = [\n    'search' => ['except' => ''], // [tl! remove]\n    'search', // [tl! add]\n];\n```\n\nIf you'd like to revert back to the Livewire 2 behavior of always showing a property in the query string no matter its value, you can use the `keep` option:\n\n```php\npublic $search = '';","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-54","text":"public $search = '';\n\nprotected $queryString = [\n    'search' => ['keep' => true], // [tl! highlight]\n];\n```\n\n## Pagination\n\nThe pagination system has been updated in Livewire 3 to better support multiple paginators within the same component.\n\n### Update published pagination views","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-55","text":"hed pagination views\n\nIf you've published Livewire's pagination views, you can reference the new ones in the [pagination directory on GitHub](https://github.com/livewire/livewire/tree/master/src/Features/SupportPagination/views) and update your application accordingly.\n\n### Accessing `$this->page` directly","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-56","text":"this->page` directly\n\nBecause Livewire now supports multiple paginators per component, it has removed the `$page` property from the component class and replaced it with a `$paginators` property that stores an array of paginators:\n\n```php\n$this->page = 2; // [tl! remove]\n$this->paginators['page'] = 2; // [tl! add]\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-57","text":" 2; // [tl! add]\n```\n\nHowever, it is recommended that you use the provided `getPage` and `setPage` methods to modify and access the current page:\n\n```php\n// Getter...\n$this->getPage();\n\n// Setter...\n$this->setPage(2);\n```\n\n### `wire:click.prefetch`","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-58","text":"wire:click.prefetch`\n\nLivewire's prefetching feature (`wire:click.prefetch`) has been removed entirely. If you depended on this feature, your application will still work, it will just be slightly less performant in the instances where you were previously benefiting from `.prefetch`.\n\n```html\n<button wire:click.prefetch=\"\"> <!-- [tl! remove] -->\n<button wire:click=\"...\"> <!-- [tl! add] -->\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-59","text":"-- [tl! add] -->\n```\n\n## Component class changes\n\nThe following changes have been made to Livewire's base `Livewire\\Component` class that your application's components may have relied on.\n\n### The component `$id` property\n\nIf you accessed the component's ID directly via `$this->id`, you should instead use `$this->getId()`:\n\n```php\n$this->id; // [tl! remove]\n\n$this->getId(); // [tl! add]\n```","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-60","text":"(); // [tl! add]\n```\n\n### Duplicate method and property names\n\nPHP allows you to use the same name for both a class property and method. In Livewire 3, this will cause problems when calling methods from the frontend via `wire:click`.\n\nIt is strongly recommended that you use distinct names for all public methods and properties in a component:\n\n```php\npublic $search = ''; // [tl! remove]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-61","text":" ''; // [tl! remove]\n\npublic function search() {\n    // ...\n}\n```\n\n```php\npublic $query = ''; // [tl! add]\n\npublic function search() {\n    // ...\n}\n```\n\n## JavaScript API changes\n\n### `livewire:load`\n\nIn previous versions of Livewire, you could listen for the `livewire:load` event to execute JavaScript code immediately before Livewire initialized the page.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-62","text":"nitialized the page.\n\nIn Livewire 3, that event name has been changed to `livewire:init` to match Alpine's `alpine:init`:\n\n```js\ndocument.addEventListener('livewire:load', () => {...}) // [tl! remove]\ndocument.addEventListener('livewire:init', () => {...}) // [tl! add]\n```\n\n### Page expired hook","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-63","text":"## Page expired hook\n\nIn version 2, Livewire exposed a dedicated JavaScript method for customizing the page expiration behavior: `Livewire.onPageExpired()`. This method has been removed in favor of using the more powerful `request` hooks directly:\n\n```js\nLivewire.onPageExpired(() => {...}) // [tl! remove]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-64","text":"..}) // [tl! remove]\n\nLivewire.hook('request', ({ fail }) => { // [tl! add:8]\n    fail(({ status, preventDefault }) => {\n        if (status === 419) {\n            preventDefault()\n\n            confirm('Your custom page expiration behavior...')\n        }\n    })\n})\n```\n\n### New lifecycle hooks\n\nMany of Livewire's internal JavaScript lifecycle hooks have been changed in Livewire 3.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-65","text":"anged in Livewire 3.\n\nHere is a comparison of the old hooks and their new syntaxes for you to find/replace in your application:\n\n```js\nLivewire.hook('component.initialized', (component) => {}) // [tl! remove]\nLivewire.hook('component.init', ({ component, cleanup }) => {}) // [tl! add]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-66","text":" => {}) // [tl! add]\n\nLivewire.hook('element.initialized', (el, component) => {}) // [tl! remove]\nLivewire.hook('element.init', ({ el, component }) => {}) // [tl! add]\n\nLivewire.hook('element.updating', (fromEl, toEl, component) => {}) // [tl! remove]\nLivewire.hook('morph.updating', ({ el, toEl, component }) => {}) // [tl! add]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-67","text":" => {}) // [tl! add]\n\nLivewire.hook('element.updated', (el, component) => {}) // [tl! remove]\nLivewire.hook('morph.updated', ({ el, component }) => {}) // [tl! add]\n\nLivewire.hook('element.removed', (el, component) => {}) // [tl! remove]\nLivewire.hook('morph.removed', ({ el, component }) => {}) // [tl! add]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-68","text":" => {}) // [tl! add]\n\nLivewire.hook('message.sent', (message, component) => {}) // [tl! remove]\nLivewire.hook('message.failed', (message, component) => {}) // [tl! remove]\nLivewire.hook('message.received', (message, component) => {}) // [tl! remove]\nLivewire.hook('message.processed', (message, component) => {}) // [tl! remove]","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-69","text":" {}) // [tl! remove]\n\nLivewire.hook('commit', ({ component, commit, respond, succeed, fail }) => { // [tl! add:14]\n    // Equivalent of 'message.sent'\n\n    succeed(({ snapshot, effects }) => {\n        // Equivalent of 'message.received'\n\n        queueMicrotask(() => {\n            // Equivalent of 'message.processed'\n        })\n    })","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-70","text":"d'\n        })\n    })\n\n    fail(() => {\n        // Equivalent of 'message.failed'\n    })\n})\n```\n\nYou may consult the new [JavaScript hook documentation](/docs/javascript) for a more thorough understanding of the new hook system.\n\n## Localization","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-71","text":"em.\n\n## Localization\n\nIf your application uses a locale prefix in the URI such as `https://example.com/en/...`, Livewire 2 automatically preserved this URL prefix when making component updates via `https://example.com/en/livewire/update`.","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-72","text":"en/livewire/update`.\n\nLivewire 3 has stopped supporting this behavior automatically. Instead, you can override Livewire's update endpoint with any URI prefixes you need using `setUpdateRoute()`:\n\n```php\nRoute::group(['prefix' => LaravelLocalization::setLocale()], function ()\n{\n    // Your other localized routes...","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"3a6e48a8d9267042c498cc630cb9adcb-73","text":" localized routes...\n\n    Livewire::setUpdateRoute(function ($handle) {\n        return Route::post('/livewire/update', $handle);\n    });\n});\n```\n\nFor more information, please consult our documentation on [configuring Livewire's update endpoint](/docs/installation#configuring-livewires-update-endpoint).\n","source":"/Users/fyyx/Documents/livewire/docs/upgrading.md"}
{"id":"69b74c6fa74e1aa444a0bd64b02061a4-0","text":"Every component update in Livewire triggers a network request. By default, when multiple components trigger updates at the same time, they are bundled into a single request.\n\nThis results in fewer network connections to the server and can drastically reduce server load.","source":"/Users/fyyx/Documents/livewire/docs/bundling.md"}
{"id":"69b74c6fa74e1aa444a0bd64b02061a4-1","text":" reduce server load.\n\nIn addition to the performance gains, this also unlocks features internally that require collaboration between multiple components ([Reactive Properties](/docs/nesting#reactive-props), [Modelable Properties](/docs/nesting#binding-to-child-data-using-wiremodel), etc.)","source":"/Users/fyyx/Documents/livewire/docs/bundling.md"}
{"id":"69b74c6fa74e1aa444a0bd64b02061a4-2","text":"ng-wiremodel), etc.)\n\nHowever, there are times when disabling this bundling is desired for performance reasons. The following page outlines various ways to customize this behavior in Livewire.\n\n## Isolating component requests","source":"/Users/fyyx/Documents/livewire/docs/bundling.md"}
{"id":"69b74c6fa74e1aa444a0bd64b02061a4-3","text":"g component requests\n\nBy using Livewire's `#[Isolate]` class attribute, you can mark a component as \"isolated\". This means that whenever that component makes a server roundtrip, it will attempt to isolate itself from other component requests.","source":"/Users/fyyx/Documents/livewire/docs/bundling.md"}
{"id":"69b74c6fa74e1aa444a0bd64b02061a4-4","text":" component requests.\n\nThis is useful if the update is expensive and you'd rather execute this component's update in parallel with others. For example, if multiple components are using `wire:poll` or listening for an event on the page, you may want to isolate specific component whose updates are expensive and would otherwise hold up the entire request.","source":"/Users/fyyx/Documents/livewire/docs/bundling.md"}
{"id":"69b74c6fa74e1aa444a0bd64b02061a4-5","text":" the entire request.\n\n```php\nuse Livewire\\Attributes\\Isolate;\nuse Livewire\\Component;\n\n#[Isolate] // [tl! highlight]\nclass ShowPost extends Component\n{\n    // ...\n}\n```\n\nBy adding the `#[Isolate]` attribute, this component's requests will no longer be bundled with other component updates.\n\n## Lazy components are isolated by default","source":"/Users/fyyx/Documents/livewire/docs/bundling.md"}
{"id":"69b74c6fa74e1aa444a0bd64b02061a4-6","text":" isolated by default\n\nWhen many components on a single page are \"lazy\" loaded (using the `#[Lazy]` attribute), it is often desired that their requests are isolated and sent in parallel. Therefore, Livewire isolates lazy updates by default.\n\nIf you wish to disable this behavior, you can pass an `isolate: false` parameter into the `#[Lazy]` attribute like so:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/bundling.md"}
{"id":"69b74c6fa74e1aa444a0bd64b02061a4-7","text":"espace App\\Livewire;\n\nuse Livewire\\Component;\nuse Livewire\\Attributes\\Lazy;\n\n#[Lazy(isolate: false)] // [tl! highlight]\nclass Revenue extends Component\n{\n    // ...\n}\n```\n\nNow, if there are multiple `Revenue` components on the same page, all ten updates will be bundled and sent the server as single, lazy-load, network request.\n","source":"/Users/fyyx/Documents/livewire/docs/bundling.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-0","text":"Livewire is a Laravel package, so you will need to have a Laravel application up and running before you can install and use Livewire. If you need help setting up a new Laravel application, please see the [official Laravel documentation](https://laravel.com/docs/installation).","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-1","text":"/docs/installation).\n\nTo install Livewire, open your terminal and navigate to your Laravel application directory, then run the following command:\n\n```shell\ncomposer require livewire/livewire\n```\n\nThat's it — really. If you want more customization options, keep reading. Otherwise, you can jump right into using Livewire.","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-2","text":"into using Livewire.\n\n> [!warning] `/livewire/livewire.js` returning a 404 status code","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-3","text":"ng a 404 status code\n> By default, Livewire exposes a route in your application to serve its JavaScript assets from: `/livewire/livewire.js`. This is fine for most applications, however, if you are using Nginx with a custom configuration, you may receive a 404 from this endpoint","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-4","text":"4 from this endpoint. To fix this issue, you can either [compile Livewire's JavaScript assets yourself](#manually-bundling-livewire-and-alpine), or [configure Nginx to allow for this](https://benjamincrozat.com/livewire-js-404-not-found).","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-5","text":"e-js-404-not-found).\n\n## Publishing the configuration file\n\nLivewire is \"zero-config\", meaning you can use it by following conventions, without any additional configuration. However, if needed, you can publish and customize Livewire's configuration file by running the following Artisan command:\n\n```shell\nphp artisan livewire:publish --config\n```","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-6","text":"publish --config\n```\n\nThis will create a new `livewire.php` file in your Laravel application's `config` directory.\n\n## Manually including Livewire's frontend assets\n\nBy default, Livewire injects the JavaScript and CSS assets it needs into each page that includes a Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-7","text":" Livewire component.\n\nIf you want more control over this behavior, you can manually include the assets on a page using the following Blade directives:\n\n```blade\n<html>\n<head>\n\t...\n\t@livewireStyles\n</head>\n<body>\n\t...\n\t@livewireScripts\n</body>\n</html>\n```\n\nBy including these assets manually on a page, Livewire knows not to inject the assets automatically.","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-8","text":"ssets automatically.\n\n> [!warning] AlpineJS is bundled with Livewire\n> Because Alpine is bundled with Livewire's JavaScript assets, you must include @verbatim`@livewireScripts`@endverbatim on every page you wish to use Alpine. Even if you're not using Livewire on that page.","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-9","text":"vewire on that page.\n\nThough rarely required, you may disable Livewire's auto-injecting asset behavior by updating the `inject_assets` [configuration option](#publishing-the-configuration-file) in your application's `config/livewire.php` file:\n\n```php\n'inject_assets' => false,\n```","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-10","text":"ssets' => false,\n```\n\nIf you'd rather force Livewire to inject its assets on a single page or multiple pages, you can call the following global method from the current route or from a service provider.\n\n```php\n\\Livewire\\Livewire::forceAssetInjection();\n```\n\n## Configuring Livewire's update endpoint","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-11","text":"re's update endpoint\n\nEvery update in a Livewire component sends a network request to the server at the following endpoint: `https://example.com/livewire/update`\n\nThis can be a problem for some applications that use localization or multi-tenancy.","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-12","text":"on or multi-tenancy.\n\nIn those cases, you can register your own endpoint however you like, and as long as you do it inside `Livewire::setUpdateRoute()`,  Livewire will know to use this endpoint for all component updates:\n\n```php\nLivewire::setUpdateRoute(function ($handle) {\n\treturn Route::post('/custom/livewire/update', $handle);\n});\n```","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-13","text":"', $handle);\n});\n```\n\nNow, instead of using `/livewire/update`, Livewire will send component updates to `/custom/livewire/update`.\n\nBecause Livewire allows you to register your own update route, you can declare any additional middleware you want Livewire to use directly inside `setUpdateRoute()`:","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-14","text":" `setUpdateRoute()`:\n\n```php\nLivewire::setUpdateRoute(function ($handle) {\n\treturn Route::post('/custom/livewire/update', $handle)\n        ->middleware([...]); // [tl! highlight]\n});\n```\n\n## Customizing the asset URL","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-15","text":"mizing the asset URL\n\nBy default, Livewire will serve its JavaScript assets from the following URL: `https://example.com/livewire/livewire.js`. Additionally, Livewire will reference this asset from a script tag like so:\n\n```blade\n<script src=\"/livewire/livewire.js\" ...\n```","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-16","text":"livewire.js\" ...\n```\n\nIf your application has global route prefixes due to localization or multi-tenancy, you can register your own endpoint that Livewire should use internally when fetching its JavaScript.\n\nTo use a custom JavaScript asset endpoint, you can register your own route inside `Livewire::setScriptRoute()`:","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-17","text":"::setScriptRoute()`:\n\n```php\nLivewire::setScriptRoute(function ($handle) {\n    return Route::get('/custom/livewire/livewire.js', $handle);\n});\n```\n\nNow, Livewire will load its JavaScript like so:\n\n```blade\n<script src=\"/custom/livewire/livewire.js\" ...\n```\n\n## Manually bundling Livewire and Alpine","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-18","text":" Livewire and Alpine\n\nBy default, Alpine and Livewire are loaded using the `<script src=\"livewire.js\">` tag, which means you have no control over the order in which these libraries are loaded. Consequently, importing and registering Alpine plugins, as shown in the example below, will no longer function:\n\n```js\n// Warning: This snippet demonstrates what NOT to do...","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-19","text":"es what NOT to do...\n\nimport Alpine from 'alpinejs'\nimport Clipboard from '@ryangjchandler/alpine-clipboard'\n\nAlpine.plugin(Clipboard)\nAlpine.start()\n```","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-20","text":")\nAlpine.start()\n```\n\nTo address this issue, we need to inform Livewire that we want to use the ESM (ECMAScript module) version ourselves and prevent the injection of the `livewire.js` script tag. To achieve this, we must add the `@livewireScriptConfig` directive to our layout file (`resources/views/components/layouts/app.blade.php`):","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-21","text":"uts/app.blade.php`):\n\n```blade\n<html>\n<head>\n    <!-- ... -->\n    @livewireStyles\n    @vite(['resources/js/app.js'])\n</head>\n<body>\n    {{ $slot }}\n\n    @livewireScriptConfig <!-- [tl! highlight] -->\n</body>\n</html>\n```","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-22","text":"\n</body>\n</html>\n```\n\nWhen Livewire detects the `@livewireScriptConfig` directive, it will refrain from injecting the Livewire and Alpine scripts. If you are using the `@livewireScripts` directive to manually load Livewire, be sure to remove it. Make sure to add the `@livewireStyles` directive if it is not already present.","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-23","text":"not already present.\n\nThe final step is importing Alpine and Livewire in our `app.js` file, allowing us to register any custom resources, and ultimately starting Livewire and Alpine:\n\n```js\nimport { Livewire, Alpine } from '../../vendor/livewire/livewire/dist/livewire.esm';\nimport Clipboard from '@ryangjchandler/alpine-clipboard'\n\nAlpine.plugin(Clipboard)\n\nLivewire.start()\n```","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-24","text":"Livewire.start()\n```\n\n> [!tip] Rebuild your assets after composer update\n> Make sure that if you are manually bundling Livewire and Alpine, that you rebuild your assets whenever you run `composer update`.","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-25","text":"n `composer update`.\n\n> [!warning] Not compatible with Laravel Mix\n> Laravel Mix will not work if you are manually bundling Livewire and AlpineJS. Instead, we recommend that you [switch to Vite](https://laravel.com/docs/vite).\n\n## Publishing Livewire's frontend assets","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-26","text":"re's frontend assets\n\n> [!warning] Publishing assets isn't necessary\n> Publishing Livewire's assets isn't necessary for Livewire to run. Only do this if you have a specific need for it.\n\nIf you prefer the JavaScript assets to be served by your web server not through Laravel, use the `livewire:publish` command:\n\n```bash\nphp artisan livewire:publish --assets\n```","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"603c96b03367fba5153b2745e2ba99d1-27","text":"publish --assets\n```\n\nTo keep assets up-to-date and avoid issues in future updates, we strongly recommend that you add the following command to your composer.json file:\n\n```json\n{\n    \"scripts\": {\n        \"post-update-cmd\": [\n            // Other scripts\n            \"@php artisan vendor:publish --tag=livewire:assets --ansi --force\"\n        ]\n    }\n}\n```\n\n","source":"/Users/fyyx/Documents/livewire/docs/installation.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-0","text":"Livewire offers a robust event system that you can use to communicate between different components on the page. Because it uses browser events under the hood, you can also use Livewire's event system to communicate with Alpine components or even plain, vanilla JavaScript.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-1","text":" vanilla JavaScript.\n\nTo trigger an event, you may use the `dispatch()` method from anywhere inside your component and listen for that event from any other component on the page.\n\n## Dispatching events\n\nTo dispatch an event from a Livewire component, you can call the `dispatch()` method, passing it the event name and any additional data you want to send along with the event.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-2","text":"long with the event.\n\nBelow is an example of dispatching a `post-created` event from a `CreatePost` component:\n\n```php\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public function save()\n    {\n\t\t// ...\n\n\t\t$this->dispatch('post-created'); // [tl! highlight]\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-3","text":"ghlight]\n    }\n}\n```\n\nIn this example, when the `dispatch()` method is called, the `post-created` event will be dispatched, and every other component on the page that is listening for this event will be notified.\n\nYou can pass additional data with the event by passing the data as the second parameter to the `dispatch()` method:\n\n```php\n$this->dispatch('post-created', title: $post->title);\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-4","text":": $post->title);\n```\n\n## Listening for events\n\nTo listen for an event in a Livewire component, add the `#[On]` attribute above the method you want to be called when a given event is dispatched:\n\n> [!warning] Make sure you import attribute classes\n> Make sure you import any attribute classes. For example, the below `#[On()]` attributes requires the following import `use Livewire\\Attributes\\On;`.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-5","text":"ire\\Attributes\\On;`.\n\n```php\nuse Livewire\\Component;\nuse Livewire\\Attributes\\On; // [tl! highlight]\n\nclass Dashboard extends Component\n{\n\t#[On('post-created')] // [tl! highlight]\n    public function updatePostList($title)\n    {\n\t\t// ...\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-6","text":"\t\t// ...\n    }\n}\n```\n\nNow, when the `post-created` event is dispatched from `CreatePost`, a network request will be triggered and the `updatePostList()` action will be invoked.\n\nAs you can see, additional data sent with the event will be provided to the action as its first argument.\n\n### Listening for dynamic event names","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-7","text":" dynamic event names\n\nOccasionally, you may want to dynamically generate event listener names at run-time using data from your component.\n\nFor example, if you wanted to scope an event listener to a specific Eloquent model, you could append the model's ID to the event name when dispatching like so:\n\n```php\nuse Livewire\\Component;","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-8","text":" Livewire\\Component;\n\nclass UpdatePost extends Component\n{\n    public function update()\n    {\n        // ...\n\n        $this->dispatch(\"post-updated.{$post->id}\"); // [tl! highlight]\n    }\n}\n```\n\nAnd then listen for that specific model:\n\n```php\nuse Livewire\\Component;\nuse App\\Models\\Post;\nuse Livewire\\Attributes\\On; // [tl! highlight]\n\nclass ShowPost extends Component\n{\n    public Post $post;","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-9","text":"  public Post $post;\n\n\t#[On('post-updated.{post.id}')] // [tl! highlight]\n    public function refreshPost()\n    {\n\t\t// ...\n    }\n}\n```\n\nIf the above `$post` model had an ID of `3`, the `refreshPost()` method would only be triggered by an event named: `post-updated.3`.\n\n### Listening for events from specific child components","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-10","text":"fic child components\n\nLivewire allows you to listen for events directly on individual child components in your Blade template like so:\n\n```blade\n<div>\n    <livewire:edit-post @saved=\"$refresh\">\n\n    <!-- ... -->\n</div>\n```\n\nIn the above scenario, if the `edit-post` child component dispatches a `saved` event, the parent's `$refresh` will be called and the parent will be refreshed.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-11","text":"t will be refreshed.\n\nInstead of passing `$refresh`, you can pass any method you normally would to something like `wire:click`. Here's an example of calling a `close()` method that might do something like close a modal dialog:\n\n```blade\n<livewire:edit-post @saved=\"close\">\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-12","text":" @saved=\"close\">\n```\n\nIf the child dispatched parameters along with the request, for example `$this->dispatch('saved', postId: 1)`, you can forward those values to the parent method using the following syntax:\n\n```blade\n<livewire:edit-post @saved=\"close($event.detail.postId)\">\n```\n\n## Using JavaScript to interact with events","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-13","text":"interact with events\n\nLivewire's event system becomes much more powerful when you interact with it from JavaScript inside your application. This unlocks the ability for any other JavaScript in your app to communicate with Livewire components on the page.\n\n### Listening for events inside component scripts","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-14","text":"de component scripts\n\nYou can easily listen for the `post-created` event inside your component's template from a `@script` directive like so:\n\n```html\n@script\n<script>\n    $wire.on('post-created', () => {\n        //\n    });\n</script>\n@endscript\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-15","text":"ript>\n@endscript\n```\n\nThe above snippet would listen for the `post-created` from the component it's registered within. If the component is no longer on the page, the event listener will no longer be triggered.\n\n[Read more about using JavaScript inside your Livewire components →](/docs/javascript#using-javascript-in-livewire-components)\n\n### Dispatching events from component scripts","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-16","text":"om component scripts\n\nAdditionally, you can dispatch events from within a component's `@script` like so:\n\n```html\n@script\n<script>\n    $wire.dispatch('post-created');\n</script>\n@endscript\n```\n\nWhen the above `@script` is run, the `post-created` event will be dispatched to the component it's defined within.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-17","text":"it's defined within.\n\nTo dispatch the event only to the component where the script resides and not other components on the page (preventing the event from \"bubbling\" up), you can use `dispatchSelf()`:\n\n```js\n$wire.dispatchSelf('post-created');\n```\n\nYou can pass any additional parameters to the event by passing an object as a second argument to `dispatch()`:","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-18","text":"ent to `dispatch()`:\n\n```html\n@script\n<script>\n    $wire.dispatch('post-created', { refreshPosts: true });\n</script>\n@endscript\n```\n\nYou can now access those event parameters from both your Livewire class and also other JavaScript event listeners.\n\nHere's an example of receiving the `refreshPosts` parameter within a Livewire class:\n\n```php\nuse Livewire\\Attributes\\On;\n\n// ...","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-19","text":"tributes\\On;\n\n// ...\n\n#[On('post-created')]\npublic function handleNewPost($refreshPosts = false)\n{\n    //\n}\n```\n\nYou can also access the `refreshPosts` parameter from a JavaScript event listener from the event's `detail` property:\n\n```html\n@script\n<script>\n    $wire.on('post-created', (event) => {\n        let refreshPosts = event.detail.refreshPosts\n\n        // ...\n    });\n</script>\n@endscript\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-20","text":"ript>\n@endscript\n```\n\n[Read more about using JavaScript inside your Livewire components →](/docs/javascript#using-javascript-in-livewire-components)\n\n### Listening for Livewire events from global JavaScript\n\nAlternatively, you can listen for Livewire events globally using `Livewire.on` from any script in your application:","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-21","text":"in your application:\n\n```html\n<script>\n    document.addEventListener('livewire:init', () => {\n       Livewire.on('post-created', (event) => {\n           //\n       });\n    });\n</script>\n```\n\nThe above snippet would listen for the `post-created` event dispatched from any component on the page.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-22","text":"mponent on the page.\n\nIf you wish to remove this event listener for any reason, you can do so using the returned `cleanup` function:\n\n```html\n<script>\n    document.addEventListener('livewire:init', () => {\n        let cleanup = Livewire.on('post-created', (event) => {\n            //\n        });","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-23","text":"      //\n        });\n\n        // Calling \"cleanup()\" will un-register the above event listener...\n        cleanup();\n    });\n</script>\n```\n\n## Events in Alpine\n\nBecause Livewire events are plain browser events under the hood, you can use Alpine to listen for them or even dispatch them.\n\n### Listening for Livewire events in Alpine","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-24","text":"ire events in Alpine\n\nFor example, we may easily listen for the `post-created` event using Alpine:\n\n```blade\n<div x-on:post-created=\"...\"></div>\n```\n\nThe above snippet would listen for the `post-created` event from any Livewire components that are children of the HTML element that the `x-on` directive is assigned to.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-25","text":"tive is assigned to.\n\nTo listen for the event from any Livewire component on the page, you can add `.window` to the listener:\n\n```blade\n<div x-on:post-created.window=\"...\"></div>\n```\n\nIf you want to access additional data that was sent with the event, you can do so using `$event.detail`:\n\n```blade\n<div x-on:post-created=\"notify('New post: ' + $event.detail.title)\"></div>\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-26","text":"l.title)\"></div>\n```\n\nThe Alpine documentation provides further information on [listening for events](https://alpinejs.dev/directives/on).\n\n### Dispatching Livewire events from Alpine\n\nAny event dispatched from Alpine is capable of being intercepted by a Livewire component.\n\nFor example, we may easily dispatch the `post-created` event from Alpine:","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-27","text":"` event from Alpine:\n\n```blade\n<button @click=\"$dispatch('post-created')\">...</button>\n```\n\nLike Livewire's `dispatch()` method, you can pass additional data along with the event by passing the data as the second parameter to the method:\n\n```blade\n<button @click=\"$dispatch('post-created', { title: 'Post Title' })\">...</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-28","text":"})\">...</button>\n```\n\nTo learn more about dispatching events using Alpine, consult the [Alpine documentation](https://alpinejs.dev/magics/dispatch).","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-29","text":"ev/magics/dispatch).\n\n> [!tip] You might not need events\n> If you are using events to call behavior on a parent from a child, you can instead call the action directly from the child using `$parent` in your Blade template. For example:\n>\n> ```blade\n> <button wire:click=\"$parent.showCreatePostForm()\">Create Post</button>\n> ```\n>","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-30","text":"ost</button>\n> ```\n>\n> [Learn more about $parent](/docs/nesting#directly-accessing-the-parent-from-the-child).","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-31","text":"ent-from-the-child).\n\n## Dispatching directly to another component\n\nIf you want to use events for communicating directly between two components on the page, you can use the `dispatch()->to()` modifier.\n\nBelow is an example of the `CreatePost` component dispatching the `post-created` event directly to the `Dashboard` component, skipping any other components listening for that specific event:","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-32","text":"that specific event:\n\n```php\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public function save()\n    {\n\t\t// ...\n\n\t\t$this->dispatch('post-created')->to(Dashboard::class);\n    }\n}\n```\n\n## Dispatching a component event to itself\n\nUsing the `dispatch()->self()` modifier, you can restrict an event to only being intercepted by the component it was triggered from:","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-33","text":" was triggered from:\n\n```php\nuse Livewire\\Component;\n\nclass CreatePost extends Component\n{\n    public function save()\n    {\n\t\t// ...\n\n\t\t$this->dispatch('post-created')->self();\n    }\n}\n```\n\n## Dispatching events from Blade templates","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-34","text":"from Blade templates\n\nYou can dispatch events directly from your Blade templates using the `$dispatch` JavaScript function. This is useful when you want to trigger an event from a user interaction, such as a button click:\n\n```blade\n<button wire:click=\"$dispatch('show-post-modal', { id: {{ $post->id }} })\">\n    EditPost\n</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-35","text":"itPost\n</button>\n```\n\nIn this example, when the button is clicked, the `show-post-modal` event will be dispatched with the specified data.\n\nIf you want to dispatch an event directly to another component you can use the `$dispatchTo()` JavaScript function:\n\n```blade\n<button wire:click=\"$dispatchTo('posts', 'show-post-modal', { id: {{ $post->id }} })\">\n    EditPost\n</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-36","text":"itPost\n</button>\n```\n\nIn this example, when the button is clicked, the `show-post-modal` event will be dispatched directly to the `Posts` component.\n\n## Testing dispatched events\n\nTo test events dispatched by your component, use the `assertDispatched()` method in your Livewire test. This method checks that a specific event has been dispatched during the component's lifecycle:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-37","text":"cycle:\n\n```php\n<?php\n\nnamespace Tests\\Feature;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse App\\Livewire\\CreatePost;\nuse Livewire\\Livewire;\n\nclass CreatePostTest extends TestCase\n{\n    use RefreshDatabase;","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-38","text":"use RefreshDatabase;\n\n    public function test_it_dispatches_post_created_event()\n    {\n        Livewire::test(CreatePost::class)\n            ->call('save')\n            ->assertDispatched('post-created');\n    }\n}\n```\n\nIn this example, the test ensures that the `post-created` event is dispatched with the specified data when the `save()` method is called on the `CreatePost` component.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-39","text":"eatePost` component.\n\n### Testing Event Listeners\n\nTo test event listeners, you can dispatch events from the test environment and assert that the expected actions are performed in response to the event:\n\n```php\n<?php\n\nnamespace Tests\\Feature;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse App\\Livewire\\Dashboard;\nuse Livewire\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-40","text":"e Livewire\\Livewire;\n\nclass DashboardTest extends TestCase\n{\n    use RefreshDatabase;\n\n    public function test_it_updates_post_count_when_a_post_is_created()\n    {\n        Livewire::test(Dashboard::class)\n            ->assertSee('Posts created: 0')\n            ->dispatch('post-created')\n            ->assertSee('Posts created: 1');\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-41","text":"ed: 1');\n    }\n}\n```\n\nIn this example, the test dispatches the `post-created` event, then checks that the `Dashboard` component properly handles the event and displays the updated count.\n\n## Real-time events using Laravel Echo","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-42","text":"s using Laravel Echo\n\nLivewire pairs nicely with [Laravel Echo](https://laravel.com/docs/broadcasting#client-side-installation) to provide real-time functionality on your web-pages using WebSockets.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-43","text":"es using WebSockets.\n\n> [!warning] Installing Laravel Echo is a prerequisite\n> This feature assumes you have installed Laravel Echo and the `window.Echo` object is globally available in your application. For more information on installing echo, check out the [Laravel Echo documentation](https://laravel.com/docs/broadcasting#client-side-installation).\n\n### Listening for Echo events","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-44","text":"ning for Echo events\n\nImagine you have an event in your Laravel application named `OrderShipped`:\n\n```php\n<?php\n\nnamespace App\\Events;\n\nuse App\\Models\\Order;\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-45","text":"ue\\SerializesModels;\n\nclass OrderShipped implements ShouldBroadcast\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n\n    public Order $order;\n\n    public function broadcastOn()\n    {\n        return new Channel('orders');\n    }\n}\n```\n\nYou might dispatch this event from another part of your application like so:\n\n```php\nuse App\\Events\\OrderShipped;\n\nOrderShipped::dispatch();\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-46","text":"ped::dispatch();\n```\n\nIf you were to listen for this event in JavaScript using only Laravel Echo, it would look something like this:\n\n```js\nEcho.channel('orders')\n    .listen('OrderShipped', e => {\n        console.log(e.order)\n    })\n```\n\nAssuming you have Laravel Echo installed and configured, you can listen for this event from inside a Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-47","text":" Livewire component.\n\nBelow is an example of an `OrderTracker` component that is listening for the `OrderShipped` event in order to show users a visual indication of a new order:\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Attributes\\On; // [tl! highlight]\nuse Livewire\\Component;\n\nclass OrderTracker extends Component\n{\n    public $showNewOrderNotification = false;","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-48","text":"otification = false;\n\n    #[On('echo:orders,OrderShipped')]\n    public function notifyNewOrder()\n    {\n        $this->showNewOrderNotification = true;\n    }\n\n    // ...\n}\n```\n\nIf you have Echo channels with variables embedded in them (such as an Order ID), you can define listeners via the `getListeners()` method instead of the `#[On]` attribute:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-49","text":"espace App\\Livewire;\n\nuse Livewire\\Attributes\\On; // [tl! highlight]\nuse Livewire\\Component;\nuse App\\Models\\Order;\n\nclass OrderTracker extends Component\n{\n    public Order $order;\n\n    public $showOrderShippedNotification = false;\n\n    public function getListeners()\n    {\n        return [\n            \"echo:orders.{$this->order->id},OrderShipped\" => 'notifyShipped',\n        ];\n    }","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-50","text":"d',\n        ];\n    }\n\n    public function notifyShipped()\n    {\n        $this->showOrderShippedNotification = true;\n    }\n\n    // ...\n}\n```\n\nOr, if you prefer, you can use the dynamic event name syntax:\n\n```php\n#[On('echo:orders.{order.id},OrderShipped')]\npublic function notifyNewOrder()\n{\n    $this->showNewOrderNotification = true;\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-51","text":"cation = true;\n}\n```\n\nIf you need to access the event payload, you can do so via the passed in `$event` parameter:\n\n```php\n#[On('echo:orders.{order.id},OrderShipped')]\npublic function notifyNewOrder($event)\n{\n    $order = Order::find($event['orderId']);\n\n    //\n}\n```\n\n### Private & presence channels\n\nYou may also listen to events broadcast to private and presence channels:","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-52","text":"d presence channels:\n\n> [!info]\n> Before proceeding, ensure you have defined <a href=\"https://laravel.com/docs/master/broadcasting#defining-authorization-callbacks\">Authentication Callbacks</a> for your broadcast channels.\n\n```php\n<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass OrderTracker extends Component\n{\n    public $showNewOrderNotification = false;","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-53","text":"otification = false;\n\n    public function getListeners()\n    {\n        return [\n            // Public Channel\n            \"echo:orders,OrderShipped\" => 'notifyNewOrder',\n\n            // Private Channel\n            \"echo-private:orders,OrderShipped\" => 'notifyNewOrder',","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-54","text":"=> 'notifyNewOrder',\n\n            // Presence Channel\n            \"echo-presence:orders,OrderShipped\" => 'notifyNewOrder',\n            \"echo-presence:orders,here\" => 'notifyNewOrder',\n            \"echo-presence:orders,joining\" => 'notifyNewOrder',\n            \"echo-presence:orders,leaving\" => 'notifyNewOrder',\n        ];\n    }","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"4460939802670d6b5e1f40e658bed7ac-55","text":"r',\n        ];\n    }\n\n    public function notifyNewOrder()\n    {\n        $this->showNewOrderNotification = true;\n    }\n}\n```\n","source":"/Users/fyyx/Documents/livewire/docs/events.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-0","text":"\nIn a traditional HTML page containing a form, the form is only ever submitted when the user presses the \"Submit\" button.\n\nHowever, Livewire is capable of much more than traditional form submissions. You can validate form inputs in real-time or even save the form as a user types.","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-1","text":"orm as a user types.\n\nIn these \"real-time\" update scenarios, it can be helpful to signal to your users when a form or subset of a form has been changed, but hasn't been saved to the database.\n\nWhen a form contains un-saved input, that form is considered \"dirty\". It only becomes \"clean\" when a network request has been triggered to synchronize the server state with the client-side state.","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-2","text":"e client-side state.\n\n## Basic usage\n\nLivewire allows you to easily toggle visual elements on the page using the `wire:dirty` directive.\n\nBy adding `wire:dirty` to an element, you are instructing Livewire to only show the element when the client-side state diverges from the server-side state.","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-3","text":"e server-side state.\n\nTo demonstrate, here is an example of an `UpdatePost` form containing a visual \"Unsaved changes...\" indication that signals to the user that the form contains input that has not been saved:\n\n```blade\n<form wire:submit=\"update\">\n    <input type=\"text\" wire:model=\"title\">\n\n    <!-- ... -->\n\n    <button type=\"submit\">Update</button>","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-4","text":"mit\">Update</button>\n\n    <div wire:dirty>Unsaved changes...</div> <!-- [tl! highlight] -->\n</form>\n```\n\nBecause `wire:dirty` has been added to the \"Unsaved changes...\" message, the message will be hidden by default. Livewire will automatically display the message when the user starts modifying the form inputs.","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-5","text":"ing the form inputs.\n\nWhen the user submits the form, the message will disappear again, since the server / client data is back in sync.\n\n### Removing elements\n\nBy adding the `.remove` modifier to `wire:dirty`, you can instead show an element by default and only hide it when the component has \"dirty\" state:\n\n```blade\n<div wire:dirty.remove>The data is in-sync...</div>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-6","text":"in-sync...</div>\n```\n\n## Targeting property updates\n\nImagine you are using `wire:model.blur` to update a property on the server immediately after a user leaves an input field. In this scenario, you can provide a \"dirty\" indication for only that property by adding `wire:target` to the element that contains the `wire:dirty` directive.","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-7","text":"re:dirty` directive.\n\nHere is an example of only showing a dirty indication when the title property has been changed:\n\n```blade\n<form wire:submit=\"update\">\n    <input wire:model.blur=\"title\">\n\n    <div wire:dirty wire:target=\"title\">Unsaved title...</div> <!-- [tl! highlight] -->\n\n    <button type=\"submit\">Update</button>\n</form>\n```\n\n## Toggling classes","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-8","text":"\n## Toggling classes\n\nOften, instead of toggling entire elements, you may want to toggle individual CSS classes on an input when its state is \"dirty\".\n\nBelow is an example where a user types into an input field and the border becomes yellow, indicating an \"unsaved\" state. Then, when the user tabs away from the field, the border is removed, indicating that the state has been saved on the server:","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"5751882bbee3fcde6fec6562aec99f59-9","text":"saved on the server:\n\n```blade\n<input wire:model.blur=\"title\" wire:dirty.class=\"border-yellow-500\">\n```\n\n","source":"/Users/fyyx/Documents/livewire/docs/wire-dirty.md"}
{"id":"32eb031cf1319b79402318fbb718a2f7-0","text":"\nLivewire's DOM diffing is useful for updating existing elements on your page, but occasionally you may need to force some elements to render from scratch to reset internal state.\n\nIn these cases, you can use the `wire:replace` directive to instruct Livewire to skip DOM diffing on the children of an element, and instead completely replace the content with the new elements from the server.","source":"/Users/fyyx/Documents/livewire/docs/wire-replace.md"}
{"id":"32eb031cf1319b79402318fbb718a2f7-1","text":"nts from the server.\n\nThis is most useful in the context of working with third-party javascript libraries and custom web components, or when element re-use could cause problems when keeping state.\n\nBelow is an example of wrapping a web component with a shadow DOM `wire:replace` so that Livewire completely replaces the element allowing the custom element to handle its own life-cycle:","source":"/Users/fyyx/Documents/livewire/docs/wire-replace.md"}
{"id":"32eb031cf1319b79402318fbb718a2f7-2","text":" its own life-cycle:\n\n```blade\n<form>\n    <!-- ... -->\n\n    <div wire:replace>\n        <!-- This custom element would have its own internal state -->\n        <json-viewer>@json($someProperty)</json-viewer>\n    </div>\n\n    <!-- ... -->\n</form>\n```\n\nYou can also instruct Livewire to replace the target element as well as all children with `wire:replace.self`.","source":"/Users/fyyx/Documents/livewire/docs/wire-replace.md"}
{"id":"32eb031cf1319b79402318fbb718a2f7-3","text":"`wire:replace.self`.\n\n```blade\n<div x-data=\"{open: false}\" wire:replace.self>\n  <!-- Ensure that the \"open\" state is reset to false on each render -->\n</div>\n```\n","source":"/Users/fyyx/Documents/livewire/docs/wire-replace.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-0","text":"It's important to make sure your Livewire apps are secure and don't expose any application vulnerabilities. Livewire has internal security features to handle many cases, however, there are times when it's up to your application code to keep your components secure.\n\n## Authorizing action parameters","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-1","text":"ng action parameters\n\nLivewire actions are extremely powerful, however, any parameters passed to Livewire actions are mutable on the client and should be treated as un-trusted user input.\n\nArguably the most common security pitfall in Livewire is failing to validate and authorize Livewire action calls before persisting changes to the database.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-2","text":"ges to the database.\n\nHere is an example of an insecurity resulting from a lack of authorization:\n\n```php\n<?php\n\nuse App\\Models\\Post;\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    // ...\n\n    public function delete($id)\n    {\n        // INSECURE!\n\n        $post = Post::find($id);\n\n        $post->delete();\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-3","text":"elete();\n    }\n}\n```\n\n```html\n<button wire:click=\"delete({{ $post->id }})\">Delete Post</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-4","text":"te Post</button>\n```\n\n\nThe reason the above example is insecure is that `wire:click=\"delete(...)\"` can be modified in the browser to pass ANY post ID a malicious user wishes.\n\nAction parameters (like `$id` in this case) should be treated the same as any untrusted input from the browser.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-5","text":"ut from the browser.\n\nTherefore, to keep this application secure and prevent a user from deleting another user's post, we must add authorization to the `delete()` action.\n\nFirst, let's create a [Laravel Policy](https://laravel.com/docs/authorization#creating-policies) for the Post model by running the following command:\n\n```bash\nphp artisan make:policy PostPolicy --model=Post\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-6","text":"icy --model=Post\n```\n\nAfter running the above command, a new Policy will be created inside `app/Policies/PostPolicy.php`. We can then update its contents with a `delete` method like so:\n\n```php\n<?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\Post;\nuse App\\Models\\User;","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-7","text":"use App\\Models\\User;\n\nclass PostPolicy\n{\n    /**\n     * Determine if the given post can be deleted by the user.\n     */\n    public function delete(?User $user, Post $post): bool\n    {\n        return $user?->id === $post->user_id;\n    }\n}\n```\n\nNow, we can use the `$this->authorize()` method from the Livewire component to ensure the user owns the post before deleting it:","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-8","text":" before deleting it:\n\n```php\npublic function delete($id)\n{\n    $post = Post::find($id);\n\n    // If the user doesn't own the post,\n    // an AuthorizationException will be thrown...\n    $this->authorize('delete', $post); // [tl! highlight]\n\n    $post->delete();\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-9","text":"ost->delete();\n}\n```\n\nFurther reading:\n* [Laravel Gates](https://laravel.com/docs/authorization#gates)\n* [Laravel Policies](https://laravel.com/docs/authorization#creating-policies)\n\n## Authorizing public properties\n\nSimilar to action parameters, public properties in Livewire should be treated as un-trusted input from the user.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-10","text":"input from the user.\n\nHere is the same example from above about deleting a post, written insecurely in a different manner:\n\n```php\n<?php\n\nuse App\\Models\\Post;\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    public $postId;\n\n    public function mount($postId)\n    {\n        $this->postId = $postId;\n    }\n\n    public function delete()\n    {\n        // INSECURE!","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-11","text":"        // INSECURE!\n\n        $post = Post::find($this->postId);\n\n        $post->delete();\n    }\n}\n```\n\n```html\n<button wire:click=\"delete\">Delete Post</button>\n```\n\nAs you can see, instead of passing the `$postId` as a parameter to the `delete` method from `wire:click`, we are storing it as a public property on the Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-12","text":" Livewire component.\n\nThe problem with this approach is that any malicious user can inject a custom element onto the page such as:\n\n```html\n<input type=\"text\" wire:model=\"postId\">\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-13","text":":model=\"postId\">\n```\n\nThis would allow them to freely modify the `$postId` before pressing \"Delete Post\". Because the `delete` action doesn't authorize the value of `$postId`, the user can now delete any post in the database, whether they own it or not.\n\nTo protect against this risk, there are two possible solutions:\n\n### Using model properties","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-14","text":"ing model properties\n\nWhen setting public properties, Livewire treats models differently than plain values such as strings and integers. Because of this, if we instead store the entire post model as a property on the component, Livewire will ensure the ID is never tampered with.\n\nHere is an example of storing a `$post` property instead of a simple `$postId` property:\n\n```php\n<?php","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-15","text":"perty:\n\n```php\n<?php\n\nuse App\\Models\\Post;\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    public Post $post;\n\n    public function mount($postId)\n    {\n        $this->post = Post::find($postId);\n    }\n\n    public function delete()\n    {\n        $this->post->delete();\n    }\n}\n```\n\n```html\n<button wire:click=\"delete\">Delete Post</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-16","text":"te Post</button>\n```\n\nThis component is now secured because there is no way for a malicious user to change the `$post` property to a different Eloquent model.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-17","text":"rent Eloquent model.\n\n### Locking the property\nAnother way to prevent properties from being set to unwanted values is to use [locked properties](https://livewire.laravel.com/docs/locked). Locking properties is done by applying the `#[Locked]` attribute. Now if users attempt to tamper with this value an error will be thrown.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-18","text":"rror will be thrown.\n\nNote that properties with the Locked attribute can still be changed in the back-end, so care still needs to taken that untrusted user input is not passed to the property in your own Livewire functions.\n\n```php\n<?php\n\nuse App\\Models\\Post;\nuse Livewire\\Component;\nuse Livewire\\Attributes\\Locked;","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-19","text":"e\\Attributes\\Locked;\n\nclass ShowPost extends Component\n{\n    #[Locked] // [tl! highlight]\n    public $postId;\n\n    public function mount($postId)\n    {\n        $this->postId = $postId;\n    }\n\n    public function delete()\n    {\n        $post = Post::find($this->postId);\n\n        $post->delete();\n    }\n}\n```\n\n### Authorizing the property","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-20","text":"orizing the property\n\nIf using a model property is undesired in your scenario, you can of course fall-back to manually authorizing the deletion of the post inside the `delete` action:\n\n```php\n<?php\n\nuse App\\Models\\Post;\nuse Livewire\\Component;\n\nclass ShowPost extends Component\n{\n    public $postId;\n\n    public function mount($postId)\n    {\n        $this->postId = $postId;\n    }","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-21","text":"tId = $postId;\n    }\n\n    public function delete()\n    {\n        $post = Post::find($this->postId);\n\n        $this->authorize('delete', $post); // [tl! highlight]\n\n        $post->delete();\n    }\n}\n```\n\n```html\n<button wire:click=\"delete\">Delete Post</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-22","text":"te Post</button>\n```\n\nNow, even though a malicious user can still freely modify the value of `$postId`, when the `delete` action is called, `$this->authorize()` will throw an `AuthorizationException` if the user does not own the post.\n\nFurther reading:\n* [Laravel Gates](https://laravel.com/docs/authorization#gates)\n* [Laravel Policies](https://laravel.com/docs/authorization#creating-policies)","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-23","text":"n#creating-policies)\n\n## Middleware\n\nWhen a Livewire component is loaded on a page containing route-level [Authorization Middleware](https://laravel.com/docs/authorization#via-middleware), like so:\n\n```php\nRoute::get('/post/{post}', App\\Livewire\\UpdatePost::class)\n    ->middleware('can:update,post'); // [tl! highlight]\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-24","text":" [tl! highlight]\n```\n\nLivewire will ensure those middlewares are re-applied to subsequent Livewire network requests. This is referred to as \"Persistent Middleware\" in Livewire's core.\n\nPersistent middleware protects you from scenarios where the authorization rules or user permissions have changed after the initial page-load.\n\nHere's a more in-depth example of such a scenario:","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-25","text":" of such a scenario:\n\n```php\nRoute::get('/post/{post}', App\\Livewire\\UpdatePost::class)\n    ->middleware('can:update,post'); // [tl! highlight]\n```\n\n```php\n<?php\n\nuse App\\Models\\Post;\nuse Livewire\\Component;\nuse Livewire\\Attributes\\Validate;\n\nclass UpdatePost extends Component\n{\n    public Post $post;\n\n    #[Validate('required|min:5')]\n    public $title = '';\n\n    public $content = '';","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-26","text":"ublic $content = '';\n\n    public function mount()\n    {\n        $this->title = $this->post->title;\n        $this->content = $this->post->content;\n    }\n\n    public function update()\n    {\n        $this->post->update([\n            'title' => $this->title,\n            'content' => $this->content,\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-27","text":"     ]);\n    }\n}\n```\n\nAs you can see, the `can:update,post` middleware is applied at the route-level. This means that a user who doesn't have permission to update a post cannot view the page.\n\nHowever, consider a scenario where a user:\n* Loads the page\n* Loses permission to update after the page loads\n* Tries updating the post after losing permission","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-28","text":"er losing permission\n\nBecause Livewire has already successfully loaded the page you might ask yourself: \"When Livewire makes a subsequent request to update the post, will the `can:update,post` middleware be re-applied? Or instead, will the un-authorized user be able to update the post successfully?\"","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-29","text":" post successfully?\"\n\nBecause Livewire has internal mechanisms to re-apply middleware from the original endpoint, you are protected in this scenario.\n\n### Configuring persistent middleware\n\nBy default, Livewire persists the following middleware across network requests:","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-30","text":"ss network requests:\n\n```php\n\\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class,\n\\Laravel\\Jetstream\\Http\\Middleware\\AuthenticateSession::class,\n\\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\n\\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n\\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\n\\Illuminate\\Auth\\Middleware\\Authenticate::class,","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-31","text":"Authenticate::class,\n\\Illuminate\\Auth\\Middleware\\Authorize::class,\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-32","text":"uthorize::class,\n```\n\nIf any of the above middlewares are applied to the initial page-load, they will be persisted (re-applied) to any future network requests.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-33","text":"re network requests.\n\nHowever, if you are applying a custom middleware from your application on the initial page-load, and want it persisted between Livewire requests, you will need to add it to this list from a [Service Provider](https://laravel.com/docs/providers#main-content) in your app like so:\n\n```php\n<?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse Livewire;","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-34","text":"vider;\nuse Livewire;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Bootstrap any application services.\n     */\n    public function boot(): void\n    {\n        Livewire::addPersistentMiddleware([ // [tl! highlight:2]\n            App\\Http\\Middleware\\EnsureUserHasRole::class,\n        ]);\n    }\n}\n```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-35","text":"     ]);\n    }\n}\n```\n\nIf a Livewire component is loaded on a page that uses the `EnsureUserHasRole` middleware from your application, it will now be persisted and re-applied to any future network requests to that Livewire component.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-36","text":" Livewire component.\n\n> [!warning] Middleware arguments are not supported\n> Livewire currently doesn't support middleware arguments for persistent middleware definitions.\n>\n> ```php\n> // Bad...\n> Livewire::addPersistentMiddleware(AuthorizeResource::class.':admin');\n>\n> // Good...\n> Livewire::addPersistentMiddleware(AuthorizeResource::class);\n> ```","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-37","text":"ource::class);\n> ```\n\n\n### Applying global Livewire middleware\n\nAlternatively, if you wish to apply specific middleware to every single Livewire update network request, you can do so by registering your own Livewire update route with any middleware you wish:","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-38","text":"middleware you wish:\n\n```php\nLivewire::setUpdateRoute(function ($handle) {\n\treturn Route::post('/livewire/update', $handle)\n        ->middleware(App\\Http\\Middleware\\LocalizeViewPaths::class);\n});\n```\n\nAny Livewire AJAX/fetch requests made to the server will use the above endpoint and apply the `LocalizeViewPaths` middleware before handling the component update.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-39","text":"he component update.\n\nLearn more about [customizing the update route on the Installation page](https://livewire.laravel.com/docs/installation#configuring-livewires-update-endpoint).\n\n## Snapshot checksums\n\nBetween every Livewire request, a snapshot is taken of the Livewire component and sent to the browser. This snapshot is used to re-build the component during the next server round-trip.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-40","text":"t server round-trip.\n\n[Learn more about Livewire snapshots in the Hydration documentation.](https://livewire.laravel.com/docs/hydration#the-snapshot)\n\nBecause fetch requests can be intercepted and tampered with in a browser, Livewire generates a \"checksum\" of each snapshot to go along with it.","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"b667eceb14a82c68d3e710b230dfdbbc-41","text":"to go along with it.\n\nThis checksum is then used on the next network request to verify that the snapshot hasn't changed in any way.\n\nIf Livewire finds a checksum mismatch, it will throw a `CorruptComponentPayloadException` and the request will fail.\n\nThis protects against any form of malicious tampering that would otherwise result in granting users the ability to execute or modify unrelated code.\n","source":"/Users/fyyx/Documents/livewire/docs/security.md"}
{"id":"4fc25c4ac340ba7c82e1071c38c92ab7-0","text":"\nLivewire makes it easy to handle form submissions via the `wire:submit` directive. By adding `wire:submit` to a `<form>` element, Livewire will intercept the form submission, prevent the default browser handling, and call any Livewire component method.\n\nHere's a basic example of using `wire:submit` to handle a \"Create Post\" form submission:\n\n```php\n<?php\n\nnamespace App\\Livewire;","source":"/Users/fyyx/Documents/livewire/docs/wire-submit.md"}
{"id":"4fc25c4ac340ba7c82e1071c38c92ab7-1","text":"espace App\\Livewire;\n\nuse Livewire\\Component;\nuse App\\Models\\Post;\n\nclass CreatePost extends Component\n{\n    public $title = '';\n\n    public $content = '';\n\n    public function save()\n    {\n        Post::create([\n            'title' => $this->title,\n            'content' => $this->content,\n        ]);\n\n        $this->redirect('/posts');\n    }","source":"/Users/fyyx/Documents/livewire/docs/wire-submit.md"}
{"id":"4fc25c4ac340ba7c82e1071c38c92ab7-2","text":"ect('/posts');\n    }\n\n    public function render()\n    {\n        return view('livewire.create-post');\n    }\n}\n```\n\n```blade\n<form wire:submit=\"save\"> <!-- [tl! highlight] -->\n    <input type=\"text\" wire:model=\"title\">\n\n    <textarea wire:model=\"content\"></textarea>\n\n    <button type=\"submit\">Save</button>\n</form>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-submit.md"}
{"id":"4fc25c4ac340ba7c82e1071c38c92ab7-3","text":"/button>\n</form>\n```\n\nIn the above example, when a user submits the form by clicking \"Save\", `wire:submit` intercepts the `submit` event and calls the `save()` action on the server.","source":"/Users/fyyx/Documents/livewire/docs/wire-submit.md"}
{"id":"4fc25c4ac340ba7c82e1071c38c92ab7-4","text":"ction on the server.\n\n> [!info] Livewire automatically calls `preventDefault()`","source":"/Users/fyyx/Documents/livewire/docs/wire-submit.md"}
{"id":"4fc25c4ac340ba7c82e1071c38c92ab7-5","text":"s `preventDefault()`\n> `wire:submit` is different than other Livewire event handlers in that it internally calls `event.preventDefault()` without the need for the `.prevent` modifier. This is because there are very few instances you would be listening for the `submit` event and NOT want to prevent it's default browser handling (performing a full form submission to an endpoint).","source":"/Users/fyyx/Documents/livewire/docs/wire-submit.md"}
{"id":"4fc25c4ac340ba7c82e1071c38c92ab7-6","text":"ion to an endpoint).\n\n> [!info] Livewire automatically disables forms while submitting\n> By default, when Livewire is sending a form submission to the server, it will disable form submit buttons and mark all form inputs as `readonly`. This way a user cannot submit the same form again until the initial submission is complete.\n\n## Going deeper","source":"/Users/fyyx/Documents/livewire/docs/wire-submit.md"}
{"id":"4fc25c4ac340ba7c82e1071c38c92ab7-7","text":"te.\n\n## Going deeper\n\n`wire:submit` is just one of many event listeners that Livewire provides. The following two pages provide much more complete documentation on using `wire:submit` in your application:\n\n* [Responding to browser events with Livewire](/docs/actions)\n* [Creating forms in Livewire](/docs/forms)\n","source":"/Users/fyyx/Documents/livewire/docs/wire-submit.md"}
{"id":"9dc1579c72c4edd0f1233620c5fc285e-0","text":"\nBefore performing dangerous actions in Livewire, you may want to provide your users with some sort of visual confirmation.\n\nLivewire makes this easy to do by adding `wire:confirm` in addition to any action (`wire:click`, `wire:submit`, etc.).\n\nHere's an example of adding a confirmation dialog to a \"Delete post\" button:","source":"/Users/fyyx/Documents/livewire/docs/wire-confirm.md"}
{"id":"9dc1579c72c4edd0f1233620c5fc285e-1","text":"Delete post\" button:\n\n```blade\n<button\n    type=\"button\"\n    wire:click=\"delete\"\n    wire:confirm=\"Are you sure you want to delete this post?\"\n>\n    Delete post <!-- [tl! highlight:-2,1] -->\n</button>\n```","source":"/Users/fyyx/Documents/livewire/docs/wire-confirm.md"}
{"id":"9dc1579c72c4edd0f1233620c5fc285e-2","text":"1] -->\n</button>\n```\n\nWhen a user clicks \"Delete post\", Livewire will trigger a confirmation dialog (The default browser confirmation alert). If the user hits escape or presses cancel, the action won't be performed. If they press \"OK\", the action will be completed.\n\n## Prompting users for input","source":"/Users/fyyx/Documents/livewire/docs/wire-confirm.md"}
{"id":"9dc1579c72c4edd0f1233620c5fc285e-3","text":"ting users for input\n\nFor even more dangerous actions such as deleting a user's account entirely, you may want to present them with a confirmation prompt which they would need to type in a specific string of characters to confirm the action.","source":"/Users/fyyx/Documents/livewire/docs/wire-confirm.md"}
{"id":"9dc1579c72c4edd0f1233620c5fc285e-4","text":" confirm the action.\n\nLivewire provides a helpful `.prompt` modifier, that when applied to `wire:confirm`, it will prompt the user for input and only confirm the action if the input matches (case-sensitive) the provided string (designated by a \"|\" (pipe) character at the end if the `wire:confirm` value):","source":"/Users/fyyx/Documents/livewire/docs/wire-confirm.md"}
{"id":"9dc1579c72c4edd0f1233620c5fc285e-5","text":"ire:confirm` value):\n\n```blade\n<button\n    type=\"button\"\n    wire:click=\"delete\"\n    wire:confirm.prompt=\"Are you sure?\\n\\nType DELETE to confirm|DELETE\"\n>\n    Delete account <!-- [tl! highlight:-2,1] -->\n</button>\n```\n\nWhen a user presses \"Delete account\", the action will only be performed if \"DELETE\" is entered into the prompt, otherwise, the action will be cancelled.\n\n","source":"/Users/fyyx/Documents/livewire/docs/wire-confirm.md"}
