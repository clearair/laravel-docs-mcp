{"id":"7b6288b0ba7e5fa44b3be8a480308e95-0","text":"Pingora proxy phases without caching\n```mermaid\n graph TD;\n    start(\"new request\")-->early_request_filter;\n    early_request_filter-->request_filter;\n    request_filter-->upstream_peer;\n\n    upstream_peer-->Connect{{IO: connect to upstream}};\n\n    Connect--connection success-->connected_to_upstream;\n    Connect--connection failure-->fail_to_connect;","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase_chart.md"}
{"id":"7b6288b0ba7e5fa44b3be8a480308e95-1","text":"e-->fail_to_connect;\n\n    connected_to_upstream-->upstream_request_filter;\n    upstream_request_filter --> request_body_filter;\n    request_body_filter --> SendReq{{IO: send request to upstream}};\n    SendReq-->RecvResp{{IO: read response from upstream}};","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase_chart.md"}
{"id":"7b6288b0ba7e5fa44b3be8a480308e95-2","text":"nse from upstream}};\n    RecvResp-->upstream_response_filter-->response_filter-->upstream_response_body_filter-->response_body_filter-->logging-->endreq(\"request done\");","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase_chart.md"}
{"id":"7b6288b0ba7e5fa44b3be8a480308e95-3","text":"req(\"request done\");\n\n    fail_to_connect --can retry-->upstream_peer;\n    fail_to_connect --can't retry-->fail_to_proxy--send error response-->logging;\n\n    RecvResp--failure-->IOFailure;\n    SendReq--failure-->IOFailure;\n    error_while_proxy--can retry-->upstream_peer;\n    error_while_proxy--can't retry-->fail_to_proxy;\n\n    request_filter --send response-->logging","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase_chart.md"}
{"id":"7b6288b0ba7e5fa44b3be8a480308e95-4","text":"d response-->logging\n\n\n    Error>any response filter error]-->error_while_proxy\n    IOFailure>IO error]-->error_while_proxy\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase_chart.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-0","text":"# `Peer`: how to connect to upstream\n\nIn the `upstream_peer()` phase the user should return a `Peer` object which defines how to connect to a certain upstream.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-1","text":" a certain upstream.\n\n## `Peer`\nA `HttpPeer` defines which upstream to connect to.\n| attribute      | meaning        |\n| ------------- |-------------|\n|address: `SocketAddr`| The IP:Port to connect to |\n|scheme: `Scheme`| Http or Https |\n|sni: `String`| The SNI to use, Https only |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-2","text":"to use, Https only |\n|proxy: `Option<Proxy>`| The setting to proxy the request through a [CONNECT proxy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT) |\n|client_cert_key: `Option<Arc<CertKey>>`| The client certificate to use in mTLS connections to upstream |\n|options: `PeerOptions`| See below |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-3","text":"ptions`| See below |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-4","text":"ptions`| See below |\n\n\n## `PeerOptions`\nA `PeerOptions` defines how to connect to the upstream.\n| attribute      | meaning        |\n| ------------- |-------------|\n|bind_to: `Option<InetSocketAddr>`| Which local address to bind to as the client IP |\n|connection_timeout: `Option<Duration>`| How long to wait before giving up *establishing* a TCP connection |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-5","text":"* a TCP connection |\n|total_connection_timeout: `Option<Duration>`| How long to wait before giving up *establishing* a connection including TLS handshake time |\n|read_timeout: `Option<Duration>`| How long to wait before each individual `read()` from upstream. The timer is reset after each `read()` |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-6","text":"fter each `read()` |\n|idle_timeout: `Option<Duration>`| How long to wait before closing a idle connection waiting for connection reuse |\n|write_timeout: `Option<Duration>`| How long to wait before a `write()` to upstream finishes |\n|verify_cert: `bool`| Whether to check if upstream' server cert is valid and validated |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-7","text":"alid and validated |\n|verify_hostname: `bool`| Whether to check if upstream server cert's CN matches the SNI |\n|alternative_cn: `Option<String>`| Accept the cert if the CN matches this name |\n|alpn: `ALPN`| Which HTTP protocol to advertise during ALPN, http1.1 and/or http2 |\n|ca: `Option<Arc<Box<[X509]>>>`| Which Root CA to use to validate the server's cert |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-8","text":" the server's cert |\n|tcp_keepalive: `Option<TcpKeepalive>`| TCP keepalive settings to upstream |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"ed34c51cc1cabcade41e095c68eca2d6-9","text":"ttings to upstream |\n\n## Examples\nTBD\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/peer.md"}
{"id":"2e4c9a89a4b02b5c6aa407e88e5f0129-0","text":"# Daemonization\n\nWhen a Pingora server is configured to run as a daemon, after its bootstrapping, it will move itself to the background and optionally change to run under the configured user and group. The `pid_file` option comes handy in this case for the user to track the PID of the daemon in the background.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/daemon.md"}
{"id":"2e4c9a89a4b02b5c6aa407e88e5f0129-1","text":"n in the background.\n\nDaemonization also allows the server to perform privileged actions like loading secrets and then switch to an unprivileged user before accepting any requests from the network.\n\nThis process happens in the `run_forever()` call. Because daemonization involves `fork()`, certain things like threads created before this call are likely lost.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/daemon.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-0","text":"# How to return errors\n\nFor easy error handling, the `pingora-error` crate exports a custom `Result` type used throughout other Pingora crates.\n\nThe `Error` struct used in this `Result`'s error variant is a wrapper around arbitrary error types. It allows the user to tag the source of the underlying error and attach other custom context info.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-1","text":"custom context info.\n\nUsers will often need to return errors by propagating an existing error or creating a wholly new one. `pingora-error` makes this easy with its error building functions.\n\n## Examples\n\nFor example, one could return an error when an expected header is not present:","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-2","text":"ader is not present:\n\n```rust\nfn validate_req_header(req: &RequestHeader) -> Result<()> {\n    // validate that the `host` header exists\n    req.headers()\n        .get(http::header::HOST)\n        .ok_or_else(|| Error::explain(InvalidHTTPHeader, \"No host header detected\"))\n}","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-3","text":"header detected\"))\n}\n\nimpl MyServer {\n    pub async fn handle_request_filter(\n        &self,\n        http_session: &mut Session,\n        ctx: &mut CTX,\n    ) -> Result<bool> {\n        validate_req_header(session.req_header()?).or_err(HTTPStatus(400), \"Missing required headers\")?;\n        Ok(true)\n    }\n}\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-4","text":"Ok(true)\n    }\n}\n```\n\n`validate_req_header` returns an `Error` if the `host` header is not found, using `Error::explain` to create a new `Error` along with an associated type (`InvalidHTTPHeader`) and helpful context that may be logged in an error log.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-5","text":"ged in an error log.\n\nThis error will eventually propagate to the request filter, where it is returned as a new `HTTPStatus` error using `or_err`. (As part of the default pingora-proxy `fail_to_proxy()` phase, not only will this error be logged, but it will result in sending a `400 Bad Request` response downstream.)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-6","text":"esponse downstream.)\n\nNote that the original causing error will be visible in the error logs as well. `or_err` wraps the original causing error in a new one with additional context, but `Error`'s `Display` implementation also prints the chain of causing errors.\n\n## Guidelines","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-7","text":"rors.\n\n## Guidelines\n\nAn error has a _type_ (e.g. `ConnectionClosed`), a _source_ (e.g. `Upstream`, `Downstream`, `Internal`), and optionally, a _cause_ (another wrapped error) and a _context_ (arbitrary user-provided string details).\n\nA minimal error can be created using functions like `new_in` / `new_up` / `new_down`, each of which specifies a source and asks the user to provide a type.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-8","text":"r to provide a type.\n\nGenerally speaking:\n* To create a new error, without a direct cause but with more context, use `Error::explain`. You can also use `explain_err` on a `Result` to replace the potential error inside it with a new one.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-9","text":"e it with a new one.\n* To wrap a causing error in a new one with more context, use `Error::because`. You can also use `or_err` on a `Result` to replace the potential error inside it by wrapping the original one.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-10","text":"ng the original one.\n\n## Retry\n\nErrors can be \"retry-able.\" If the error is retry-able, pingora-proxy will be allowed to retry the upstream request. Some errors are only retry-able on [reused connections](pooling.md), e.g. to handle situations where the remote end has dropped a connection we attempted to reuse.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"2705d9ed4dda658b3f362f831d575ebc-11","text":" attempted to reuse.\n\nBy default a newly created `Error` either takes on its direct causing error's retry status, or, if left unspecified, is considered not retry-able.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/errors.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-0","text":"# Sharing state across phases with `CTX`","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-1","text":"ss phases with `CTX`\n\n## Using `CTX`","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-2","text":"CTX`\n\n## Using `CTX`\nThe custom filters users implement in different phases of the request don't interact with each other directly. In order to share information and state across the filters, users can define a `CTX` struct. Each request owns a single `CTX` object. All the filters are able to read and update members of the `CTX` object. The CTX object will be dropped at the end of the request.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-3","text":" end of the request.\n\n### Example\n\nIn the following example, the proxy parses the request header in the `request_filter` phase, it stores the boolean flag so that later in the `upstream_peer` phase the flag is used to decide which server to route traffic to. (Technically, the header can be parsed in `upstream_peer` phase, but we just do it in an earlier phase just for the demonstration.)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-4","text":" the demonstration.)\n\n```Rust\npub struct MyProxy();\n\npub struct MyCtx {\n    beta_user: bool,\n}\n\nfn check_beta_user(req: &pingora_http::RequestHeader) -> bool {\n    // some simple logic to check if user is beta\n    req.headers.get(\"beta-flag\").is_some()\n}\n\n#[async_trait]\nimpl ProxyHttp for MyProxy {\n    type CTX = MyCtx;\n    fn new_ctx(&self) -> Self::CTX {\n        MyCtx { beta_user: false }\n    }","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-5","text":"_user: false }\n    }\n\n    async fn request_filter(&self, session: &mut Session, ctx: &mut Self::CTX) -> Result<bool> {\n        ctx.beta_user = check_beta_user(session.req_header());\n        Ok(false)\n    }","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-6","text":"     Ok(false)\n    }\n\n    async fn upstream_peer(\n        &self,\n        _session: &mut Session,\n        ctx: &mut Self::CTX,\n    ) -> Result<Box<HttpPeer>> {\n        let addr = if ctx.beta_user {\n            info!(\"I'm a beta user\");\n            (\"1.0.0.1\", 443)\n        } else {\n            (\"1.1.1.1\", 443)\n        };","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-7","text":".1\", 443)\n        };\n\n        let peer = Box::new(HttpPeer::new(addr, true, \"one.one.one.one\".to_string()));\n        Ok(peer)\n    }\n}\n```\n\n## Sharing state across requests\nSharing state such as a counter, cache and other info across requests is common. There is nothing special needed for sharing resources and data across requests in Pingora. `Arc`, `static` or any other mechanism can be used.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-8","text":"chanism can be used.\n\n\n### Example\nLet's modify the example above to track the number of beta visitors as well as the number of total visitors. The counters can either be defined in the `MyProxy` struct itself or defined as a global variable. Because the counters can be concurrently accessed, Mutex is used here.\n\n```Rust\n// global counter\nstatic REQ_COUNTER: Mutex<usize> = Mutex::new(0);","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-9","text":"ze> = Mutex::new(0);\n\npub struct MyProxy {\n    // counter for the service\n    beta_counter: Mutex<usize>, // AtomicUsize works too\n}\n\npub struct MyCtx {\n    beta_user: bool,\n}\n\nfn check_beta_user(req: &pingora_http::RequestHeader) -> bool {\n    // some simple logic to check if user is beta\n    req.headers.get(\"beta-flag\").is_some()\n}","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-10","text":"a-flag\").is_some()\n}\n\n#[async_trait]\nimpl ProxyHttp for MyProxy {\n    type CTX = MyCtx;\n    fn new_ctx(&self) -> Self::CTX {\n        MyCtx { beta_user: false }\n    }\n\n    async fn request_filter(&self, session: &mut Session, ctx: &mut Self::CTX) -> Result<bool> {\n        ctx.beta_user = check_beta_user(session.req_header());\n        Ok(false)\n    }","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-11","text":"     Ok(false)\n    }\n\n    async fn upstream_peer(\n        &self,\n        _session: &mut Session,\n        ctx: &mut Self::CTX,\n    ) -> Result<Box<HttpPeer>> {\n        let mut req_counter = REQ_COUNTER.lock().unwrap();\n        *req_counter += 1;","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-12","text":"  *req_counter += 1;\n\n        let addr = if ctx.beta_user {\n            let mut beta_count = self.beta_counter.lock().unwrap();\n            *beta_count += 1;\n            info!(\"I'm a beta user #{beta_count}\");\n            (\"1.0.0.1\", 443)\n        } else {\n            info!(\"I'm an user #{req_counter}\");\n            (\"1.1.1.1\", 443)\n        };","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"31eaaec7d8e657306916d6d7271d51a6-13","text":".1\", 443)\n        };\n\n        let peer = Box::new(HttpPeer::new(addr, true, \"one.one.one.one\".to_string()));\n        Ok(peer)\n    }\n}\n```\n\nThe complete example can be found under [`pingora-proxy/examples/ctx.rs`](../../pingora-proxy/examples/ctx.rs). You can run it using `cargo`:\n```\nRUST_LOG=INFO cargo run --example ctx\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/ctx.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-0","text":"# Pingora Internals\n\n(Special thanks to [James Munns](https://github.com/jamesmunns) for writing this section)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-1","text":"riting this section)\n\n\n## Starting the `Server`\n\nThe pingora system starts by spawning a *server*. The server is responsible for starting *services*, and listening for termination events.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-2","text":" termination events.\n\n```\n                               ┌───────────┐\n                    ┌─────────>│  Service  │\n                    │          └───────────┘\n┌────────┐          │          ┌───────────┐","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-3","text":"       ┌───────────┐\n│ Server │──Spawns──┼─────────>│  Service  │\n└────────┘          │          └───────────┘\n                    │          ┌───────────┐\n                    └─────────>│  Service  │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-4","text":"──────>│  Service  │\n                               └───────────┘\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-5","text":"   └───────────┘\n```\n\nAfter spawning the *services*, the server continues to listen to a termination event, which it will propagate to the created services.\n\n## Services\n\n*Services* are entities that handle listening to given sockets, and perform the core functionality. A *service* is tied to a particular protocol and set of options.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-6","text":" and set of options.\n\n> NOTE: there are also \"background\" services, which just do *stuff*, and aren't necessarily listening to a socket. For now we're just talking about listener services.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-7","text":"t listener services.\n\nEach service has its own threadpool/tokio runtime, with a number of threads based on the configured value. Worker threads are not shared cross-service. Service runtime threadpools may be work-stealing (tokio-default), or non-work-stealing (N isolated single threaded runtimes).","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-8","text":" threaded runtimes).\n\n```\n┌─────────────────────────┐\n│ ┌─────────────────────┐ │\n│ │┌─────────┬─────────┐│ │\n│ ││  Conn   │  Conn   ││ │\n│ │├─────────┼─────────┤│ │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-9","text":"──────┼─────────┤│ │\n│ ││Endpoint │Endpoint ││ │\n│ │├─────────┴─────────┤│ │\n│ ││     Listeners     ││ │\n│ │├─────────┬─────────┤│ │\n│ ││ Worker  │ Worker  ││ │\n│ ││ Thread  │ Thread  ││ │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-10","text":"read  │ Thread  ││ │\n│ │├─────────┴─────────┤│ │\n│ ││  Tokio Executor   ││ │\n│ │└───────────────────┘│ │\n│ └─────────────────────┘ │\n│ ┌───────┐               │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-11","text":"───┐               │\n└─┤Service├───────────────┘\n  └───────┘\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-12","text":"───┘\n  └───────┘\n```\n\n## Service Listeners\n\nAt startup, each Service is assigned a set of downstream endpoints that they listen to. A single service may listen to more than one endpoint. The Server also passes along any relevant configuration, including TLS settings if relevant.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-13","text":"ettings if relevant.\n\nThese endpoints are converted into listening sockets, called `TransportStack`s. Each `TransportStack` is assigned to an async task within that service's executor.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-14","text":" service's executor.\n\n```\n                                 ┌───────────────────┐\n                                 │┌─────────────────┐│    ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-15","text":" ─ ─ ─ ─ ─ ─ ─ ─ ─ ─\n ┌─────────┐                     ││ TransportStack  ││                                ┌────────────────────┐│\n┌┤Listeners├────────┐            ││                 ││    │                       │  ││                    │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-16","text":"                   │\n│└─────────┘        │            ││ (Listener, TLS  │├──────spawn(run_endpoint())────>│ Service<ServerApp> ││\n│┌─────────────────┐│            ││    Acceptor,    ││    │                       │  ││                    │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-17","text":"                   │\n││    Endpoint     ││            ││   UpgradeFDs)   ││                                └────────────────────┘│\n││   addr/ports    ││            │├─────────────────┤│    │                       │  │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-18","text":"                │  │\n││ + TLS Settings  ││            ││ TransportStack  ││                                ┌────────────────────┐│\n│├─────────────────┤│            ││                 ││    │                       │  ││                    │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-19","text":"                   │\n││    Endpoint     ││──build()─> ││ (Listener, TLS  │├──────spawn(run_endpoint())────>│ Service<ServerApp> ││\n││   addr/ports    ││            ││    Acceptor,    ││    │                       │  ││                    │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-20","text":"                   │\n││ + TLS Settings  ││            ││   UpgradeFDs)   ││                                └────────────────────┘│\n│├─────────────────┤│            │├─────────────────┤│    │                       │  │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-21","text":"                │  │\n││    Endpoint     ││            ││ TransportStack  ││                                ┌────────────────────┐│\n││   addr/ports    ││            ││                 ││    │                       │  ││                    │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-22","text":"                   │\n││ + TLS Settings  ││            ││ (Listener, TLS  │├──────spawn(run_endpoint())────>│ Service<ServerApp> ││\n│└─────────────────┘│            ││    Acceptor,    ││    │                       │  ││                    │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-23","text":"                   │\n└───────────────────┘            ││   UpgradeFDs)   ││                                └────────────────────┘│","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-24","text":"──────────────────┘│\n                                 │└─────────────────┘│    │ ┌───────────────┐     │  │ ┌──────────────┐","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-25","text":"  │ ┌──────────────┐\n                                 └───────────────────┘     ─│start_service()│─ ─ ─    ─│ Worker Tasks ├ ─ ─ ┘\n                                                            └───────────────┘          └──────────────┘","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-26","text":"    └──────────────┘\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-27","text":"└──────────────┘\n```\n\n## Downstream connection lifecycle\n\nEach service processes incoming connections by spawning a task-per-connection. These connections are held open\nas long as there are new events to be handled.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-28","text":"vents to be handled.\n\n```\n                                  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-29","text":" ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐\n\n                                  │  ┌───────────────┐   ┌────────────────┐   ┌─────────────────┐    ┌─────────────┐  │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-30","text":"  ┌─────────────┐  │\n┌────────────────────┐               │ UninitStream  │   │    Service     │   │       App       │    │  Task Ends  │\n│                    │            │  │ ::handshake() │──>│::handle_event()│──>│ ::process_new() │──┬>│             │  │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-31","text":"┬>│             │  │\n│ Service<ServerApp> │──spawn()──>   └───────────────┘   └────────────────┘   └─────────────────┘  │ └─────────────┘","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-32","text":"┘  │ └─────────────┘\n│                    │            │                                                    ▲           │                  │\n└────────────────────┘                                                                 │         while","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-33","text":"     │         while\n                                  │                                                    └─────────reuse                │\n                                     ┌───────────────────────────┐","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-34","text":"───────────────────┐\n                                  └ ─│  Task on Service Runtime  │─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n                                     └───────────────────────────┘\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-35","text":"───────────────┘\n```\n\n## What is a proxy then?\n\nInterestingly, the `pingora` `Server` itself has no particular notion of a Proxy.\n\nInstead, it only thinks in terms of `Service`s, which are expected to contain a particular implementor of the `ServiceApp` trait.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-36","text":" `ServiceApp` trait.\n\nFor example, this is how an `HttpProxy` struct, from the `pingora-proxy` crate, \"becomes\" a `Service` spawned by the `Server`:","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-37","text":"ned by the `Server`:\n\n```\n┌─────────────┐\n│  HttpProxy  │\n│  (struct)   │\n└─────────────┘\n       │\n   implements   ┌─────────────┐\n       │        │HttpServerApp│\n       └───────>│   (trait)   │\n                └─────────────┘","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-38","text":"     └─────────────┘\n                       │\n                   implements   ┌─────────────┐\n                       │        │  ServerApp  │\n                       └───────>│   (trait)   │\n                                └─────────────┘\n                                       │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-39","text":"                   │\n                                   contained    ┌─────────────────────┐\n                                     within     │                     │\n                                       └───────>│ Service<ServiceApp> │\n                                                │                     │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-40","text":"                   │\n                                                └─────────────────────┘\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-41","text":"───────────────┘\n```\n\nDifferent functionalities and helpers are provided at different layers in this representation.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-42","text":"this representation.\n\n```\n┌─────────────┐        ┌──────────────────────────────────────┐\n│  HttpProxy  │        │Handles high level Proxying workflow, │\n│  (struct)   │─ ─ ─ ─ │   customizable via ProxyHttp trait   │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-43","text":" ProxyHttp trait   │\n└──────┬──────┘        └──────────────────────────────────────┘\n       │\n┌──────▼──────┐        ┌──────────────────────────────────────┐","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-44","text":"───────────────────┐\n│HttpServerApp│        │ Handles selection of H1 vs H2 stream │\n│   (trait)   │─ ─ ─ ─ │     handling, incl H2 handshake      │\n└──────┬──────┘        └──────────────────────────────────────┘\n       │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-45","text":"──────────┘\n       │\n┌──────▼──────┐        ┌──────────────────────────────────────┐\n│  ServerApp  │        │ Handles dispatching of App instances │\n│   (trait)   │─ ─ ─ ─ │   as individual tasks, per Session   │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-46","text":"sks, per Session   │\n└──────┬──────┘        └──────────────────────────────────────┘\n       │\n┌──────▼──────┐        ┌──────────────────────────────────────┐","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-47","text":"───────────────────┐\n│ Service<A>  │        │ Handles dispatching of App instances │\n│  (struct)   │─ ─ ─ ─ │  as individual tasks, per Listener   │\n└─────────────┘        └──────────────────────────────────────┘\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-48","text":"───────────────┘\n```\n\nThe `HttpProxy` struct handles the high level workflow of proxying an HTTP connection\n\nIt uses the `ProxyHttp` (note the flipped wording order!) **trait** to allow customization\nat each of the following steps (note: taken from [the phase chart](./phase_chart.md) doc):","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-49","text":"hase_chart.md) doc):\n\n```mermaid\n graph TD;\n    start(\"new request\")-->request_filter;\n    request_filter-->upstream_peer;\n\n    upstream_peer-->Connect{{IO: connect to upstream}};\n\n    Connect--connection success-->connected_to_upstream;\n    Connect--connection failure-->fail_to_connect;","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-50","text":"e-->fail_to_connect;\n\n    connected_to_upstream-->upstream_request_filter;\n    upstream_request_filter --> SendReq{{IO: send request to upstream}};\n    SendReq-->RecvResp{{IO: read response from upstream}};\n    RecvResp-->upstream_response_filter-->response_filter-->upstream_response_body_filter-->response_body_filter-->logging-->endreq(\"request done\");","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-51","text":"req(\"request done\");\n\n    fail_to_connect --can retry-->upstream_peer;\n    fail_to_connect --can't retry-->fail_to_proxy--send error response-->logging;\n\n    RecvResp--failure-->IOFailure;\n    SendReq--failure-->IOFailure;\n    error_while_proxy--can retry-->upstream_peer;\n    error_while_proxy--can't retry-->fail_to_proxy;\n\n    request_filter --send response-->logging","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-52","text":"d response-->logging\n\n\n    Error>any response filter error]-->error_while_proxy\n    IOFailure>IO error]-->error_while_proxy\n\n```\n\n## Zooming out\n\nBefore we zoom in, it's probably good to zoom out and remind ourselves how\na proxy generally works:","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-53","text":"oxy generally works:\n\n```\n┌────────────┐          ┌─────────────┐         ┌────────────┐\n│ Downstream │          │    Proxy    │         │  Upstream  │\n│   Client   │─────────>│             │────────>│   Server   │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-54","text":"─────>│   Server   │\n└────────────┘          └─────────────┘         └────────────┘\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-55","text":"  └────────────┘\n```\n\nThe proxy will be taking connections from the **Downstream** client, and (if\neverything goes right), establishing a connection with the appropriate\n**Upstream** server. This selected upstream server is referred to as\nthe **Peer**.\n\nOnce the connection is established, the Downstream and Upstream can communicate\nbidirectionally.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-56","text":"ate\nbidirectionally.\n\nSo far, the discussion of Server, Services, and Listeners have focused on the LEFT\nhalf of this diagram, handling incoming Downstream connections, and getting it TO\nthe proxy component.\n\nNext, we'll look at the RIGHT half of this diagram, connecting to Upstreams.\n\n## Managing the Upstream","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-57","text":"anaging the Upstream\n\nConnections to Upstream Peers are made through `Connector`s. This is not a specific type or trait, but more\nof a \"style\".\n\nConnectors are responsible for a few things:","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-58","text":"le for a few things:\n\n* Establishing a connection with a Peer\n* Maintaining a connection pool with the Peer, allowing for connection reuse across:\n    * Multiple requests from a single downstream client\n    * Multiple requests from different downstream clients\n* Measuring health of connections, for connections like H2, which perform regular pings","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-59","text":"erform regular pings\n* Handling protocols with multiple poolable layers, like H2\n* Caching, if relevant to the protocol and enabled\n* Compression, if relevant to the protocol and enabled","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-60","text":"protocol and enabled\n\nNow in context, we can see how each end of the Proxy is handled:","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-61","text":"he Proxy is handled:\n\n```\n┌────────────┐          ┌─────────────┐         ┌────────────┐\n│ Downstream │       ┌ ─│─   Proxy  ┌ ┼ ─       │  Upstream  │\n│   Client   │─────────>│ │           │──┼─────>│   Server   │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-62","text":"─────>│   Server   │\n└────────────┘       │  └───────────┼─┘         └────────────┘\n                      ─ ─ ┘          ─ ─ ┘\n                        ▲              ▲\n                     ┌──┘              └──┐\n                     │                    │","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-63","text":"                   │\n                ┌ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─\n                 Listeners           Connectors│\n                └ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"cf72ce174f1df5eb76670bdcbf5cee09-64","text":"     └ ─ ─ ─ ─ ─\n```\n\n## What about multiple peers?\n\n`Connectors` only handle the connection to a single peer, so selecting one of potentially multiple Peers\nis actually handled one level up, in the `upstream_peer()` method of the `ProxyHttp` trait.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/internals.md"}
{"id":"7163169874a7297045cc03f4bc04c9b9-0","text":"# User Guide\n\nIn this guide, we will cover the most used features, operations and settings of Pingora.\n\n## Running Pingora servers\n* [Start and stop](start_stop.md)\n* [Graceful restart and graceful shutdown](graceful.md)\n* [Configuration](conf.md)\n* [Daemonization](daemon.md)\n* [Systemd integration](systemd.md)\n* [Handling panics](panic.md)\n* [Error logging](error_log.md)\n* [Prometheus](prom.md)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/index.md"}
{"id":"7163169874a7297045cc03f4bc04c9b9-1","text":"Prometheus](prom.md)\n\n## Building HTTP proxies\n* [Life of a request: `pingora-proxy` phases and filters](phase.md)\n* [`Peer`: how to connect to upstream](peer.md)\n* [Sharing state across phases with `CTX`](ctx.md)\n* [How to return errors](errors.md)\n* [Examples: take control of the request](modify_filter.md)\n* [Connection pooling and reuse](pooling.md)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/index.md"}
{"id":"7163169874a7297045cc03f4bc04c9b9-2","text":"d reuse](pooling.md)\n* [Handling failures and failover](failover.md)\n* [RateLimiter quickstart](rate_limiter.md)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/index.md"}
{"id":"7163169874a7297045cc03f4bc04c9b9-3","text":"rt](rate_limiter.md)\n\n## Advanced topics (WIP)\n* [Pingora internals](internals.md)\n* Using BoringSSL\n* User defined configuration\n* Pingora async runtime and threading model\n* Background Service\n* Blocking code in async context\n* Tracing\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/index.md"}
{"id":"682d196e6b413dadacd526fb56411763-0","text":"# Life of a request: pingora-proxy phases and filters\n\n## Intro\nThe pingora-proxy HTTP proxy framework supports highly programmable proxy behaviors. This is done by allowing users to inject custom logic into different phases (stages) in the life of a request.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-1","text":"e life of a request.\n\n## Life of a proxied HTTP request\n1. The life of a proxied HTTP request starts when the proxy reads the request header from the **downstream** (i.e., the client).\n2. Then, the proxy connects to the **upstream** (i.e., the remote server). This step is skipped if there is a previously established [connection to reuse](pooling.md).","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-2","text":" reuse](pooling.md).\n3. The proxy then sends the request header to the upstream.\n4. Once the request header is sent, the proxy enters a duplex mode, which simultaneously proxies:\n    a. upstream response (both header and body) to the downstream, and\n    b. downstream request body to upstream (if any).","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-3","text":"o upstream (if any).\n5. Once the entire request/response finishes, the life of the request is ended. All resources are released. The downstream connections and the upstream connections are recycled to be reused if applicable.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-4","text":"eused if applicable.\n\n## Pingora-proxy phases and filters\nPingora-proxy allows users to insert arbitrary logic into the life of a request.\n```mermaid\n graph TD;\n    start(\"new request\")-->early_request_filter;\n    early_request_filter-->request_filter;\n    request_filter-->upstream_peer;\n\n    upstream_peer-->Connect{{IO: connect to upstream}};","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-5","text":"nnect to upstream}};\n\n    Connect--connection success-->connected_to_upstream;\n    Connect--connection failure-->fail_to_connect;","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-6","text":"e-->fail_to_connect;\n\n    connected_to_upstream-->upstream_request_filter;\n    upstream_request_filter --> request_body_filter;\n    request_body_filter --> SendReq{{IO: send request to upstream}};\n    SendReq-->RecvResp{{IO: read response from upstream}};","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-7","text":"nse from upstream}};\n    RecvResp-->upstream_response_filter-->response_filter-->upstream_response_body_filter-->response_body_filter-->logging-->endreq(\"request done\");","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-8","text":"req(\"request done\");\n\n    fail_to_connect --can retry-->upstream_peer;\n    fail_to_connect --can't retry-->fail_to_proxy--send error response-->logging;\n\n    RecvResp--failure-->IOFailure;\n    SendReq--failure-->IOFailure;\n    error_while_proxy--can retry-->upstream_peer;\n    error_while_proxy--can't retry-->fail_to_proxy;\n\n    request_filter --send response-->logging","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-9","text":"d response-->logging\n\n\n    Error>any response filter error]-->error_while_proxy\n    IOFailure>IO error]-->error_while_proxy\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-10","text":"rror_while_proxy\n```\n\n### General filter usage guidelines\n* Most filters return a [`pingora_error::Result<_>`](errors.md). When the returned value is `Result::Err`, `fail_to_proxy()` will be called and the request will be terminated.\n* Most filters are async functions, which allows other async operations such as IO to be performed within the filters.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-11","text":" within the filters.\n* A per-request `CTX` object can be defined to share states across the filters of the same request. All filters have mutable access to this object.\n* Most filters are optional.\n* The reason both `upstream_response_*_filter()` and `response_*_filter()` exist is for HTTP caching integration reasons (still WIP).","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-12","text":"reasons (still WIP).\n\n\n### `early_request_filter()`\nThis is the first phase of every request.\n\nThis function is similar to `request_filter()` but executes before any other logic, including downstream module logic. The main purpose of this function is to provide finer-grained control of the behavior of the modules.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-13","text":"vior of the modules.\n\n### `request_filter()`\nThis phase is usually for validating request inputs, rate limiting, and initializing context.\n\n### `request_body_filter()`\nThis phase is triggered after a response body is ready to send to upstream. It will be called every time a piece of request body is received.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-14","text":"st body is received.\n\n### `proxy_upstream_filter()`\nThis phase determines if we should continue to the upstream to serve a response. If we short-circuit, a 502 is returned by default, but a different response can be implemented.\n\nThis phase returns a boolean determining if we should continue to the upstream or error.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-15","text":"e upstream or error.\n\n### `upstream_peer()`\nThis phase decides which upstream to connect to (e.g. with DNS lookup and hashing/round-robin), and how to connect to it.\n\nThis phase returns a `Peer` that defines the upstream to connect to. Implementing this phase is **required**.\n\n### `connected_to_upstream()`\nThis phase is executed when upstream is successfully connected.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-16","text":"cessfully connected.\n\nUsually this phase is for logging purposes. Connection info such as RTT and upstream TLS ciphers are reported in this phase.\n\n### `fail_to_connect()`\nThe counterpart of `connected_to_upstream()`. This phase is called if an error is encountered when connecting to upstream.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-17","text":"necting to upstream.\n\nIn this phase users can report the error in Sentry/Prometheus/error log. Users can also decide if the error is retry-able.\n\nIf the error is retry-able, `upstream_peer()` will be called again, in which case the user can decide whether to retry the same upstream or failover to a secondary one.\n\nIf the error is not retry-able, the request will end.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-18","text":"he request will end.\n\n### `upstream_request_filter()`\nThis phase is to modify requests before sending to upstream.\n\n### `upstream_response_filter()/upstream_response_body_filter()/upstream_response_trailer_filter()`\nThis phase is triggered after an upstream response header/body/trailer is received.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-19","text":"trailer is received.\n\nThis phase is to modify or process response headers, body, or trailers before sending to downstream. Note that this phase is called _prior_ to HTTP caching and therefore any changes made here will affect the response stored in the HTTP cache.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-20","text":"d in the HTTP cache.\n\n### `response_filter()/response_body_filter()/response_trailer_filter()`\nThis phase is triggered after a response header/body/trailer is ready to send to downstream.\n\nThis phase is to modify them before sending to downstream.\n\n### `error_while_proxy()`\nThis phase is triggered during proxy errors to upstream, this is after the connection is established.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-21","text":"tion is established.\n\nThis phase may decide to retry a request if the connection was re-used and the HTTP method is idempotent.\n\n### `fail_to_proxy()`\nThis phase is called whenever an error is encounter during any of the phases above.\n\nThis phase is usually for error logging and error reporting to downstream.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-22","text":"rting to downstream.\n\n### `logging()`\nThis is the last phase that runs after the request is finished (or errors) and before any of its resources are released. Every request will end up in this final phase.\n\nThis phase is usually for logging and post request cleanup.\n\n### `request_summary()`\nThis is not a phase, but a commonly used callback.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-23","text":"monly used callback.\n\nEvery error that reaches `fail_to_proxy()` will be automatically logged in the error log. `request_summary()` will be called to dump the info regarding the request when logging the error.\n\nThis callback returns a string which allows users to customize what info to dump in the error log to help track and debug the failures.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-24","text":" debug the failures.\n\n### `suppress_error_log()`\nThis is also not a phase, but another callback.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-25","text":"ut another callback.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-26","text":"t another callback.\n\n`fail_to_proxy()` errors are automatically logged in the error log, but users may not be interested in every error. For example, downstream errors are logged if the client disconnects early, but these errors can become noisy if users are mainly interested in observing upstream issues. This callback can inspect the error and returns true or false","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-27","text":"eturns true or false. If true, the error will not be written to the log.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"682d196e6b413dadacd526fb56411763-28","text":" written to the log.\n\n### Cache filters\n\nTo be documented\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/phase.md"}
{"id":"233289dcc4b28065b4882851f8b374dc-0","text":"# Starting and stopping Pingora server\n\nA pingora server is a regular unprivileged multithreaded process.\n\n## Start\nBy default, the server will run in the foreground.\n\nA Pingora server by default takes the following command-line arguments:","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/start_stop.md"}
{"id":"233289dcc4b28065b4882851f8b374dc-1","text":"mand-line arguments:\n\n| Argument      | Effect        | default|\n| ------------- |-------------| ----|\n| -d, --daemon | Daemonize the server | false |\n| -t, --test | Test the server conf and then exit (WIP) | false |\n| -c, --conf | The path to the configuration file | empty string |\n| -u, --upgrade | This server should gracefully upgrade a running server | false |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/start_stop.md"}
{"id":"233289dcc4b28065b4882851f8b374dc-2","text":"ing server | false |\n\n## Stop\nA Pingora server will listen to the following signals.\n\n### SIGINT: fast shutdown\nUpon receiving SIGINT (ctrl + c), the server will exit immediately with no delay. All unfinished requests will be interrupted. This behavior is usually less preferred because it could break requests.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/start_stop.md"}
{"id":"233289dcc4b28065b4882851f8b374dc-3","text":"ould break requests.\n\n### SIGTERM: graceful shutdown\nUpon receiving SIGTERM, the server will notify all its services to shutdown, wait for some preconfigured time and then exit. This behavior gives requests a grace period to finish.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/start_stop.md"}
{"id":"233289dcc4b28065b4882851f8b374dc-4","text":"ce period to finish.\n\n### SIGQUIT: graceful upgrade\nSimilar to SIGTERM, but the server will also transfer all its listening sockets to a new Pingora server so that there is no downtime during the upgrade. See the [graceful upgrade](graceful.md) section for more details.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/start_stop.md"}
{"id":"85b3bd036f878cba0bd014f6104fd726-0","text":"# Prometheus\n\nPingora has a built-in prometheus HTTP metric server for scraping.\n\n```rust\n    ...\n    let mut prometheus_service_http = Service::prometheus_http_service();\n    prometheus_service_http.add_tcp(\"0.0.0.0:1234\");\n    my_server.add_service(prometheus_service_http);\n    my_server.run_forever();\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/prom.md"}
{"id":"85b3bd036f878cba0bd014f6104fd726-1","text":"r.run_forever();\n```\n\nThe simplest way to use it is to have [static metrics](https://docs.rs/prometheus/latest/prometheus/#static-metrics).\n\n```rust\nstatic MY_COUNTER: Lazy<IntGauge> = Lazy::new(|| {\n    register_int_gauge!(\"my_counter\", \"my counter\").unwrap()\n});\n\n```\n\nThis static metric will automatically appear in the Prometheus metric endpoint.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/prom.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-0","text":"# Handling failures and failover\n\nPingora-proxy allows users to define how to handle failures throughout the life of a proxied request.\n\nWhen a failure happens before the response header is sent downstream, users have a few options:\n1. Send an error page downstream and then give up.\n2. Retry the same upstream again.\n3. Try another upstream if applicable.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-1","text":"tream if applicable.\n\nOtherwise, once the response header is already sent downstream, there is nothing the proxy can do other than logging an error and then giving up on the request.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-2","text":"g up on the request.\n\n\n## Retry / Failover\nIn order to implement retry or failover, `fail_to_connect()` / `error_while_proxy()` needs to mark the error as \"retry-able.\" For failover, `fail_to_connect() / error_while_proxy()` also needs to update the `CTX` to tell `upstream_peer()` not to use the same `Peer` again.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-3","text":"e same `Peer` again.\n\n### Safety","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-4","text":"` again.\n\n### Safety\nIn general, idempotent HTTP requests, e.g., `GET`, are safe to retry. Other requests, e.g., `POST`, are not safe to retry if the requests have already been sent. When `fail_to_connect()` is called, pingora-proxy guarantees that nothing was sent upstream","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-5","text":"ng was sent upstream. Users are not recommended to retry a non-idempotent request after `error_while_proxy()` unless they know the upstream server enough to know whether it is safe.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-6","text":" whether it is safe.\n\n### Example","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-7","text":"s safe.\n\n### Example\nIn the following example we set a `tries` variable on the `CTX` to track how many connection attempts we've made. When setting our peer in `upstream_peer` we check if `tries` is less than one and connect to 192.0.2.1. On connect failure we increment `tries` in `fail_to_connect` and set `e.set_retry(true)` which tells Pingora this is a retryable error","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-8","text":"is a retryable error. On retry, we enter `upstream_peer` again and this time connect to 1.1.1.1. If we're unable to connect to 1.1.1.1 we return a 502 since we only set `e.set_retry(true)` in `fail_to_connect` when `tries` is zero.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-9","text":"hen `tries` is zero.\n\n```Rust\npub struct MyProxy();\n\npub struct MyCtx {\n    tries: usize,\n}\n\n#[async_trait]\nimpl ProxyHttp for MyProxy {\n    type CTX = MyCtx;\n    fn new_ctx(&self) -> Self::CTX {\n        MyCtx { tries: 0 }\n    }","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-10","text":"x { tries: 0 }\n    }\n\n    fn fail_to_connect(\n        &self,\n        _session: &mut Session,\n        _peer: &HttpPeer,\n        ctx: &mut Self::CTX,\n        mut e: Box<Error>,\n    ) -> Box<Error> {\n        if ctx.tries > 0 {\n            return e;\n        }\n        ctx.tries += 1;\n        e.set_retry(true);\n        e\n    }","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-11","text":"ue);\n        e\n    }\n\n    async fn upstream_peer(\n        &self,\n        _session: &mut Session,\n        ctx: &mut Self::CTX,\n    ) -> Result<Box<HttpPeer>> {\n        let addr = if ctx.tries < 1 {\n            (\"192.0.2.1\", 443)\n        } else {\n            (\"1.1.1.1\", 443)\n        };","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"53eac71ce278ce6384f6030de53384d3-12","text":".1\", 443)\n        };\n\n        let mut peer = Box::new(HttpPeer::new(addr, true, \"one.one.one.one\".to_string()));\n        peer.options.connection_timeout = Some(Duration::from_millis(100));\n        Ok(peer)\n    }\n}\n```\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/failover.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-0","text":"# **RateLimiter quickstart**","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-1","text":"Limiter quickstart**\nPingora provides a crate `pingora-limits` which provides a simple and easy to use rate limiter for your application","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-2","text":"for your application. Below is an example of how you can use [`Rate`](https://docs.rs/pingora-limits/latest/pingora_limits/rate/struct.Rate.html) to create an application that uses multiple limiters to restrict the rate at which requests can be made on a per-app basis (determined by a request header).","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-3","text":"y a request header).\n\n## Steps\n1. Add the following dependencies to your `Cargo.toml`:\n   ```toml\n   async-trait=\"0.1\"\n   pingora = { version = \"0.3\", features = [ \"lb\" ] }\n   pingora-limits = \"0.3.0\"\n   once_cell = \"1.19.0\"\n   ```\n2. Declare a global rate limiter map to store the rate limiter for each client. In this example, we use `appid`.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-4","text":"ple, we use `appid`.\n3. Override the `request_filter` method in the `ProxyHttp` trait to implement rate limiting.\n   1. Retrieve the client appid from header.\n   2. Retrieve the current window requests from the rate limiter map. If there is no rate limiter for the client, create a new one and insert it into the map.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-5","text":"ert it into the map.\n   3. If the current window requests exceed the limit, return 429 and set RateLimiter associated headers.\n   4. If the request is not rate limited, return `Ok(false)` to continue the request.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-6","text":"ontinue the request.\n\n## Example\n```rust\nuse async_trait::async_trait;\nuse once_cell::sync::Lazy;\nuse pingora::http::ResponseHeader;\nuse pingora::prelude::*;\nuse pingora_limits::rate::Rate;\nuse std::sync::Arc;\nuse std::time::Duration;","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-7","text":"std::time::Duration;\n\nfn main() {\n    let mut server = Server::new(Some(Opt::default())).unwrap();\n    server.bootstrap();\n    let mut upstreams = LoadBalancer::try_from_iter([\"1.1.1.1:443\", \"1.0.0.1:443\"]).unwrap();\n    // Set health check\n    let hc = TcpHealthCheck::new();\n    upstreams.set_health_check(hc);\n    upstreams.health_check_frequency = Some(Duration::from_secs(1));","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-8","text":"tion::from_secs(1));\n    // Set background service\n    let background = background_service(\"health check\", upstreams);\n    let upstreams = background.task();\n    // Set load balancer\n    let mut lb = http_proxy_service(&server.configuration, LB(upstreams));\n    lb.add_tcp(\"0.0.0.0:6188\");","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-9","text":"tcp(\"0.0.0.0:6188\");\n\n    // let rate = Rate\n    server.add_service(background);\n    server.add_service(lb);\n    server.run_forever();\n}\n\npub struct LB(Arc<LoadBalancer<RoundRobin>>);","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-10","text":"ancer<RoundRobin>>);\n\nimpl LB {\n    pub fn get_request_appid(&self, session: &mut Session) -> Option<String> {\n        match session\n            .req_header()\n            .headers\n            .get(\"appid\")\n            .map(|v| v.to_str())\n        {\n            None => None,\n            Some(v) => match v {\n                Ok(v) => Some(v.to_string()),\n                Err(_) => None,\n            },","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-11","text":"None,\n            },\n        }\n    }\n}","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-12","text":"},\n        }\n    }\n}\n\n// Rate limiter\nstatic RATE_LIMITER: Lazy<Rate> = Lazy::new(|| Rate::new(Duration::from_secs(1)));\n\n// max request per second per client\nstatic MAX_REQ_PER_SEC: isize = 1;\n\n#[async_trait]\nimpl ProxyHttp for LB {\n    type CTX = ();\n\n    fn new_ctx(&self) {}","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-13","text":"fn new_ctx(&self) {}\n\n    async fn upstream_peer(\n        &self,\n        _session: &mut Session,\n        _ctx: &mut Self::CTX,\n    ) -> Result<Box<HttpPeer>> {\n        let upstream = self.0.select(b\"\", 256).unwrap();\n        // Set SNI\n        let peer = Box::new(HttpPeer::new(upstream, true, \"one.one.one.one\".to_string()));\n        Ok(peer)\n    }","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-14","text":"      Ok(peer)\n    }\n\n    async fn upstream_request_filter(\n        &self,\n        _session: &mut Session,\n        upstream_request: &mut RequestHeader,\n        _ctx: &mut Self::CTX,\n    ) -> Result<()>\n    where\n        Self::CTX: Send + Sync,\n    {\n        upstream_request\n            .insert_header(\"Host\", \"one.one.one.one\")\n            .unwrap();\n        Ok(())\n    }","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-15","text":"        Ok(())\n    }\n\n    async fn request_filter(&self, session: &mut Session, _ctx: &mut Self::CTX) -> Result<bool>\n    where\n        Self::CTX: Send + Sync,\n    {\n        let appid = match self.get_request_appid(session) {\n            None => return Ok(false), // no client appid found, skip rate limiting\n            Some(addr) => addr,\n        };","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-16","text":" => addr,\n        };\n\n        // retrieve the current window requests\n        let curr_window_requests = RATE_LIMITER.observe(&appid, 1);\n        if curr_window_requests > MAX_REQ_PER_SEC {\n            // rate limited, return 429\n            let mut header = ResponseHeader::build(429, None).unwrap();\n            header","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-17","text":";\n            header\n                .insert_header(\"X-Rate-Limit-Limit\", MAX_REQ_PER_SEC.to_string())\n                .unwrap();\n            header.insert_header(\"X-Rate-Limit-Remaining\", \"0\").unwrap();\n            header.insert_header(\"X-Rate-Limit-Reset\", \"1\").unwrap();\n            session.set_keepalive(None);\n            session\n                .write_response_header(Box::new(header), true)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-18","text":"::new(header), true)\n                .await?;\n            return Ok(true);\n        }\n        Ok(false)\n    }\n}\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-19","text":"k(false)\n    }\n}\n```\n\n## Testing\nTo use the example above, ","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-20","text":" the example above, \n\n1. Run your program with `cargo run`. \n2. Verify the program is working with a few executions of ` curl localhost:6188 -H \"appid:1\" -v`\n   - The first request should work and any later requests that arrive within 1s of a previous request should fail with: \n     ```\n     *   Trying 127.0.0.1:6188...\n     * Connected to localhost (127.0.0.1) port 6188 (#0)\n     > GET / HTTP/1.1","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-21","text":"    > GET / HTTP/1.1\n     > Host: localhost:6188\n     > User-Agent: curl/7.88.1\n     > Accept: */*\n     > appid:1\n     > \n     < HTTP/1.1 429 Too Many Requests\n     < X-Rate-Limit-Limit: 1\n     < X-Rate-Limit-Remaining: 0\n     < X-Rate-Limit-Reset: 1\n     < Date: Sun, 14 Jul 2024 20:29:02 GMT\n     < Connection: close\n     < \n     * Closing connection 0\n     ```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"2db15cf990be1be0d626c720c45d5691-22","text":"onnection 0\n     ```\n\n## Complete Example\nYou can run the pre-made example code in the [`pingora-proxy` examples folder](https://github.com/cloudflare/pingora/tree/main/pingora-proxy/examples/rate_limiter.rs) with \n\n```\ncargo run --example rate_limiter\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/rate_limiter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-0","text":"# Examples: taking control of the request\n\nIn this section we will go through how to route, modify or reject requests.\n\n## Routing\nAny information from the request can be used to make routing decision. Pingora doesn't impose any constraints on how users could implement their own routing logic.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-1","text":"r own routing logic.\n\nIn the following example, the proxy sends traffic to 1.0.0.1 only when the request path start with `/family/`. All the other requests are routed to 1.1.1.1.\n\n```Rust\npub struct MyGateway;\n\n#[async_trait]\nimpl ProxyHttp for MyGateway {\n    type CTX = ();\n    fn new_ctx(&self) -> Self::CTX {}","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-2","text":"elf) -> Self::CTX {}\n\n    async fn upstream_peer(\n        &self,\n        session: &mut Session,\n        _ctx: &mut Self::CTX,\n    ) -> Result<Box<HttpPeer>> {\n        let addr = if session.req_header().uri.path().starts_with(\"/family/\") {\n            (\"1.0.0.1\", 443)\n        } else {\n            (\"1.1.1.1\", 443)\n        };\n\n        info!(\"connecting to {addr:?}\");","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-3","text":"cting to {addr:?}\");\n\n        let peer = Box::new(HttpPeer::new(addr, true, \"one.one.one.one\".to_string()));\n        Ok(peer)\n    }\n}\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-4","text":"Ok(peer)\n    }\n}\n```\n\n\n## Modifying headers\n\nBoth request and response headers can be added, removed or modified in their corresponding phases. In the following example, we add logic to the `response_filter` phase to update the `Server` header and remove the `alt-svc` header.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-5","text":"he `alt-svc` header.\n\n```Rust\n#[async_trait]\nimpl ProxyHttp for MyGateway {\n    ...\n    async fn response_filter(\n        &self,\n        _session: &mut Session,\n        upstream_response: &mut ResponseHeader,\n        _ctx: &mut Self::CTX,\n    ) -> Result<()>\n    where\n        Self::CTX: Send + Sync,\n    {\n        // replace existing header if any\n        upstream_response","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-6","text":"   upstream_response\n            .insert_header(\"Server\", \"MyGateway\")\n            .unwrap();\n        // because we don't support h3\n        upstream_response.remove_header(\"alt-svc\");","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-7","text":"e_header(\"alt-svc\");\n\n        Ok(())\n    }\n}\n```\n\n## Return Error pages\n\nSometimes instead of proxying the traffic, under certain conditions, such as authentication failures, you might want the proxy to just return an error page.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-8","text":"eturn an error page.\n\n```Rust\nfn check_login(req: &pingora_http::RequestHeader) -> bool {\n    // implement you logic check logic here\n    req.headers.get(\"Authorization\").map(|v| v.as_bytes()) == Some(b\"password\")\n}","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-9","text":" Some(b\"password\")\n}\n\n#[async_trait]\nimpl ProxyHttp for MyGateway {\n    ...\n    async fn request_filter(&self, session: &mut Session, _ctx: &mut Self::CTX) -> Result<bool> {\n        if session.req_header().uri.path().starts_with(\"/login\")\n            && !check_login(session.req_header())\n        {\n            let _ = session.respond_error(403).await;","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-10","text":"nd_error(403).await;\n            // true: tell the proxy that the response is already written\n            return Ok(true);\n        }\n        Ok(false)\n    }\n```\n## Logging","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-11","text":"    }\n```\n## Logging\n\nLogging logic can be added to the `logging` phase of Pingora. The logging phase runs on every request right before Pingora proxy finish processing it. This phase runs for both successful and failed requests.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-12","text":"and failed requests.\n\nIn the example below, we add Prometheus metric and access logging to the proxy. In order for the metrics to be scraped, we also start a Prometheus metric server on a different port.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-13","text":"on a different port.\n\n\n``` Rust\npub struct MyGateway {\n    req_metric: prometheus::IntCounter,\n}","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-14","text":"theus::IntCounter,\n}\n\n#[async_trait]\nimpl ProxyHttp for MyGateway {\n    ...\n    async fn logging(\n        &self,\n        session: &mut Session,\n        _e: Option<&pingora::Error>,\n        ctx: &mut Self::CTX,\n    ) {\n        let response_code = session\n            .response_written()\n            .map_or(0, |resp| resp.status.as_u16());\n        // access log\n        info!(","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-15","text":"s log\n        info!(\n            \"{} response code: {response_code}\",\n            self.request_summary(session, ctx)\n        );","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"5faf25cd6657b88e265b087c600c9d66-16","text":"ion, ctx)\n        );\n\n        self.req_metric.inc();\n    }\n\nfn main() {\n   ...\n    let mut prometheus_service_http =\n        pingora::services::listening::Service::prometheus_http_service();\n    prometheus_service_http.add_tcp(\"127.0.0.1:6192\");\n    my_server.add_service(prometheus_service_http);\n\n    my_server.run_forever();\n}\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/modify_filter.md"}
{"id":"23782723fdf7e90bcd87d2766b6ee747-0","text":"# Connection pooling and reuse\n\nWhen the request to a `Peer` (upstream server) is finished, the connection to that peer is kept alive and added to a connection pool to be _reused_ by subsequent requests. This happens automatically without any special configuration.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/pooling.md"}
{"id":"23782723fdf7e90bcd87d2766b6ee747-1","text":"ecial configuration.\n\nRequests that reuse previously established connections avoid the latency and compute cost of setting up a new connection, improving the Pingora server's overall performance and scalability.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/pooling.md"}
{"id":"23782723fdf7e90bcd87d2766b6ee747-2","text":"nce and scalability.\n\n## Same `Peer`\nOnly the connections to the exact same `Peer` can be reused by a request. For correctness and security reasons, two `Peer`s are the same if and only if all the following attributes are the same\n* IP:port\n* scheme\n* SNI\n* client cert\n* verify cert\n* verify hostname\n* alternative_cn\n* proxy settings","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/pooling.md"}
{"id":"23782723fdf7e90bcd87d2766b6ee747-3","text":"_cn\n* proxy settings\n\n## Disable pooling\nTo disable connection pooling and reuse to a certain `Peer`, just set the `idle_timeout` to 0 seconds to all requests using that `Peer`.\n\n## Failure\nA connection is considered not reusable if errors happen during the request.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/pooling.md"}
{"id":"0658814c4d1327ef4983143dadf6c5ef-0","text":"# Graceful restart and shutdown\n\nGraceful restart, upgrade, and shutdown mechanisms are very commonly used to avoid errors or downtime when releasing new versions of Pingora servers.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/graceful.md"}
{"id":"0658814c4d1327ef4983143dadf6c5ef-1","text":" of Pingora servers.\n\nPingora graceful upgrade mechanism guarantees the following:\n* A request is guaranteed to be handled either by the old server instance or the new one. No request will see connection refused when trying to connect to the server endpoints.\n* A request that can finish within the grace period is guaranteed not to be terminated.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/graceful.md"}
{"id":"0658814c4d1327ef4983143dadf6c5ef-2","text":"ot to be terminated.\n\n## How to graceful upgrade\n### Step 0\nConfigure the upgrade socket. The old and new server need to agree on the same path to this socket. See configuration manual for details.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/graceful.md"}
{"id":"0658814c4d1327ef4983143dadf6c5ef-3","text":" manual for details.\n\n### Step 1\nStart the new instance with the `--upgrade` CLI option. The new instance will not try to listen to the service endpoint right away. It will try to acquire the listening socket from the old instance instead.\n\n### Step 2\nSend SIGQUIT signal to the old instance. The old instance will start to transfer the listening socket to the new instance.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/graceful.md"}
{"id":"0658814c4d1327ef4983143dadf6c5ef-4","text":"to the new instance.\n\nOnce step 2 is successful, the new instance will start to handle new incoming connections right away. Meanwhile, the old instance will enter its graceful shutdown mode. It waits a short period of time (to give the new instance time to initialize and prepare to handle traffic), after which it will not accept any new connections.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/graceful.md"}
{"id":"9aabcfe918593888c630eba1920a18ae-0","text":"# Error logging\n\nPingora libraries are built to expect issues like disconnects, timeouts and invalid inputs from the network. A common way to record these issues are to output them in error log (STDERR or log files).","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/error_log.md"}
{"id":"9aabcfe918593888c630eba1920a18ae-1","text":"TDERR or log files).\n\n## Log level guidelines\nPingora adopts the idea behind [log](https://docs.rs/log/latest/log/). There are five log levels:\n* `error`: This level should be used when the error stops the request from being handled correctly. For example when the server we try to connect to is offline.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/error_log.md"}
{"id":"9aabcfe918593888c630eba1920a18ae-2","text":"nnect to is offline.\n* `warning`: This level should be used when an error occurs but the system recovers from it. For example when the primary DNS timed out but the system is able to query the secondary DNS.\n* `info`: Pingora logs when the server is starting up or shutting down.\n* `debug`: Internal details. This log level is not compiled in `release` builds.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/error_log.md"}
{"id":"9aabcfe918593888c630eba1920a18ae-3","text":"in `release` builds.\n* `trace`: Fine-grained internal details. This log level is not compiled in `release` builds.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/error_log.md"}
{"id":"9aabcfe918593888c630eba1920a18ae-4","text":"in `release` builds.\n\nThe pingora-proxy crate has a well-defined interface to log errors, so that users don't have to manually log common proxy errors. See its guide for more details.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/error_log.md"}
{"id":"0eb12c54cc489c6e4aa510f0c84af307-0","text":"# Handling panics\n\nAny panic that happens to particular requests does not affect other ongoing requests or the server's ability to handle other requests. Sockets acquired by the panicking requests are dropped (closed). The panics will be captured by the tokio runtime and then ignored.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/panic.md"}
{"id":"0eb12c54cc489c6e4aa510f0c84af307-1","text":"me and then ignored.\n\nIn order to monitor the panics, Pingora server has built-in Sentry integration.\n```rust\nmy_server.sentry = Some(\n    sentry::ClientOptions{\n        dsn: \"SENTRY_DSN\".into_dsn().unwrap(),\n        ..Default::default()\n    }\n);\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/panic.md"}
{"id":"0eb12c54cc489c6e4aa510f0c84af307-2","text":"fault()\n    }\n);\n```\n\nEven though a panic is not fatal in Pingora, it is still not the preferred way to handle failures like network timeouts. Panics should be reserved for unexpected logic errors.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/panic.md"}
{"id":"aae5a156ef7b7cd545be2424dd0a09cb-0","text":"# Systemd integration\n\nA Pingora server doesn't depend on systemd but it can easily be made into a systemd service.\n\n```ini\n[Service]\nType=forking\nPIDFile=/run/pingora.pid\nExecStart=/bin/pingora -d -c /etc/pingora.conf\nExecReload=kill -QUIT $MAINPID\nExecReload=/bin/pingora -u -d -c /etc/pingora.conf\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/systemd.md"}
{"id":"aae5a156ef7b7cd545be2424dd0a09cb-1","text":"etc/pingora.conf\n```\n\nThe example systemd setup integrates Pingora's graceful upgrade into systemd. To upgrade the pingora service, simply install a version of the binary and then call `systemctl reload pingora.service`.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/systemd.md"}
{"id":"4cd351a91b6f3108f6a11c6b3d45f65d-0","text":"# Configuration\n\nA Pingora configuration file is a list of Pingora settings in yaml format.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/conf.md"}
{"id":"4cd351a91b6f3108f6a11c6b3d45f65d-1","text":"ings in yaml format.\n\nExample\n```yaml\n---\nversion: 1\nthreads: 2\npid_file: /run/pingora.pid\nupgrade_sock: /tmp/pingora_upgrade.sock\nuser: nobody\ngroup: webusers\n```\n## Settings\n| Key      | meaning        | value type |\n| ------------- |-------------| ----|\n| version | the version of the conf, currently it is a constant `1` | number |\n| pid_file | The path to the pid file | string |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/conf.md"}
{"id":"4cd351a91b6f3108f6a11c6b3d45f65d-2","text":" pid file | string |\n| daemon | whether to run the server in the background | bool |\n| error_log | the path to error log output file. STDERR is used if not set | string |\n| upgrade_sock | the path to the upgrade socket. | string |\n| threads | number of threads per service | number |\n| user | the user the pingora server should be run under after daemonization | string |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/conf.md"}
{"id":"4cd351a91b6f3108f6a11c6b3d45f65d-3","text":"onization | string |\n| group | the group the pingora server should be run under after daemonization | string |\n| client_bind_to_ipv4 | source IPv4 addresses to bind to when connecting to server | list of string |\n| client_bind_to_ipv6 | source IPv6 addresses to bind to when connecting to server| list of string |\n| ca_file | The path to the root CA file | string |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/conf.md"}
{"id":"4cd351a91b6f3108f6a11c6b3d45f65d-4","text":"t CA file | string |\n| work_stealing | Enable work stealing runtime (default true). See Pingora runtime (WIP) section for more info | bool |\n| upstream_keepalive_pool_size | The number of total connections to keep in the connection pool | number |","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/conf.md"}
{"id":"4cd351a91b6f3108f6a11c6b3d45f65d-5","text":"tion pool | number |\n\n## Extension\nAny unknown settings will be ignored. This allows extending the conf file to add and pass user defined settings. See User defined configuration section.\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/user_guide/conf.md"}
{"id":"bed75d981087a9396b5c34cd78faae6a-0","text":"# Pingora User Manual\n\n## Quick Start\nIn this section we show you how to build a bare-bones load balancer.\n\n[Read the quick start here.](quick_start.md)\n\n## User Guide\nCovers how to configure and run Pingora servers, as well as how to build custom HTTP server and proxy logic on top of Pingora's framework.\n\n[Read the user guide here.](user_guide/index.md)\n\n## API Reference\nTBD\n","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/README.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-0","text":"# Quick Start: load balancer\n\n## Introduction\n\nThis quick start shows how to build a bare-bones load balancer using pingora and pingora-proxy.\n\nThe goal of the load balancer is for every incoming HTTP request, select one of the two backends: https://1.1.1.1 and https://1.0.0.1 in a round-robin fashion.\n\n## Build a basic load balancer","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-1","text":" basic load balancer\n\nCreate a new cargo project for our load balancer. Let's call it `load_balancer`\n\n```\ncargo new load_balancer\n```\n\n### Include the Pingora Crate and Basic Dependencies\n\nIn your project's `cargo.toml` file add the following to your dependencies\n```\nasync-trait=\"0.1\"\npingora = { version = \"0.3\", features = [ \"lb\" ] }\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-2","text":"res = [ \"lb\" ] }\n```\n\n### Create a pingora server\nFirst, let's create a pingora server. A pingora `Server` is a process which can host one or many\nservices. The pingora `Server` takes care of configuration and CLI argument parsing, daemonization,\nsignal handling, and graceful restart or shutdown.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-3","text":"restart or shutdown.\n\nThe preferred usage is to initialize the `Server` in the `main()` function and\nuse `run_forever()` to spawn all the runtime threads and block the main thread until the server is\nready to exit.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-4","text":"er is\nready to exit.\n\n\n```rust\nuse async_trait::async_trait;\nuse pingora::prelude::*;\nuse std::sync::Arc;\n\nfn main() {\n    let mut my_server = Server::new(None).unwrap();\n    my_server.bootstrap();\n    my_server.run_forever();\n}\n```\n\nThis will compile and run, but it doesn't do anything interesting.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-5","text":"nything interesting.\n\n### Create a load balancer proxy","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-6","text":" load balancer proxy\nNext let's create a load balancer. Our load balancer holds a static list of upstream IPs. The `pingora-load-balancing` crate already provides the `LoadBalancer` struct with common selection algorithms such as round robin and hashing. So let’s just use it","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-7","text":"So let’s just use it. If the use case requires more sophisticated or customized server selection logic, users can simply implement it themselves in this function.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-8","text":"es in this function.\n\n\n```rust\npub struct LB(Arc<LoadBalancer<RoundRobin>>);\n```\n\nIn order to make the server a proxy, we need to implement the `ProxyHttp` trait for it.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-9","text":"yHttp` trait for it.\n\nAny object that implements the `ProxyHttp` trait essentially defines how a request is handled in\nthe proxy. The only required method in the `ProxyHttp` trait is `upstream_peer()` which returns\nthe address where the request should be proxied to.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-10","text":"hould be proxied to.\n\nIn the body of the `upstream_peer()`, let's use the `select()` method for the `LoadBalancer` to round-robin across the upstream IPs. In this example we use HTTPS to connect to the backends, so we also need to specify to `use_tls` and set the SNI when constructing our [`Peer`](user_guide/peer.md)) object.\n\n```rust\n#[async_trait]\nimpl ProxyHttp for LB {","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-11","text":"l ProxyHttp for LB {\n\n    /// For this small example, we don't need context storage\n    type CTX = ();\n    fn new_ctx(&self) -> () {\n        ()\n    }\n\n    async fn upstream_peer(&self, _session: &mut Session, _ctx: &mut ()) -> Result<Box<HttpPeer>> {\n        let upstream = self.0\n            .select(b\"\", 256) // hash doesn't matter for round robin\n            .unwrap();","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-12","text":"          .unwrap();\n\n        println!(\"upstream peer is: {upstream:?}\");\n\n        // Set SNI to one.one.one.one\n        let peer = Box::new(HttpPeer::new(upstream, true, \"one.one.one.one\".to_string()));\n        Ok(peer)\n    }\n}\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-13","text":"Ok(peer)\n    }\n}\n```\n\nIn order for the 1.1.1.1 backends to accept our requests, a host header must be present. Adding this header\ncan be done by the `upstream_request_filter()` callback which modifies the request header after\nthe connection to the backends are established and before the request header is sent.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-14","text":"uest header is sent.\n\n```rust\nimpl ProxyHttp for LB {\n    // ...\n    async fn upstream_request_filter(\n        &self,\n        _session: &mut Session,\n        upstream_request: &mut RequestHeader,\n        _ctx: &mut Self::CTX,\n    ) -> Result<()> {\n        upstream_request.insert_header(\"Host\", \"one.one.one.one\").unwrap();\n        Ok(())\n    }\n}\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-15","text":"  Ok(())\n    }\n}\n```\n\n\n### Create a pingora-proxy service\nNext, let's create a proxy service that follows the instructions of the load balancer above.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-16","text":"load balancer above.\n\nA pingora `Service` listens to one or multiple (TCP or Unix domain socket) endpoints. When a new connection is established\nthe `Service` hands the connection over to its \"application.\" `pingora-proxy` is such an application\nwhich proxies the HTTP request to the given backend as configured above.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-17","text":"as configured above.\n\nIn the example below, we create a `LB` instance with two backends `1.1.1.1:443` and `1.0.0.1:443`.\nWe put that `LB` instance to a proxy `Service` via the  `http_proxy_service()` call and then tell our\n`Server` to host that proxy `Service`.\n\n```rust\nfn main() {\n    let mut my_server = Server::new(None).unwrap();\n    my_server.bootstrap();","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-18","text":"_server.bootstrap();\n\n    let upstreams =\n        LoadBalancer::try_from_iter([\"1.1.1.1:443\", \"1.0.0.1:443\"]).unwrap();\n\n    let mut lb = http_proxy_service(&my_server.configuration, LB(Arc::new(upstreams)));\n        lb.add_tcp(\"0.0.0.0:6188\");\n\n    my_server.add_service(lb);\n\n    my_server.run_forever();\n}\n```\n\n### Run it","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-19","text":");\n}\n```\n\n### Run it\n\nNow that we have added the load balancer to the service, we can run our new \nproject with \n\n```cargo run```\n\nTo test it, simply send the server a few requests with the command:\n```\ncurl 127.0.0.1:6188 -svo /dev/null\n```\n\nYou can also navigate your browser to [http://localhost:6188](http://localhost:6188)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-20","text":"tp://localhost:6188)\n\nThe following output shows that the load balancer is doing its job to balance across the two backends:\n```\nupstream peer is: Backend { addr: Inet(1.0.0.1:443), weight: 1 }\nupstream peer is: Backend { addr: Inet(1.1.1.1:443), weight: 1 }\nupstream peer is: Backend { addr: Inet(1.0.0.1:443), weight: 1 }\nupstream peer is: Backend { addr: Inet(1.1.1.1:443), weight: 1 }","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-21","text":".1:443), weight: 1 }\nupstream peer is: Backend { addr: Inet(1.0.0.1:443), weight: 1 }\n...\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-22","text":" weight: 1 }\n...\n```\n\nWell done! At this point you have a functional load balancer. It is a _very_ \nbasic load balancer though, so the next section will walk you through how to\nmake it more robust with some built-in pingora tooling.\n\n## Add functionality","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-23","text":"## Add functionality\n\nPingora provides several helpful features that can be enabled and configured \nwith just a few lines of code. These range from simple peer health checks to \nthe ability to seamlessly update running binary with zero service interruptions.\n\n### Peer health checks","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-24","text":"# Peer health checks\n\nTo make our load balancer more reliable, we would like to add some health checks \nto our upstream peers. That way if there is a peer that has gone down, we can \nquickly stop routing our traffic to that peer.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-25","text":"raffic to that peer.\n\nFirst let's see how our simple load balancer behaves when one of the peers is\ndown. To do this, we'll update the list of peers to include a peer that is \nguaranteed to be broken.\n\n```rust\nfn main() {\n    // ...\n    let upstreams =\n        LoadBalancer::try_from_iter([\"1.1.1.1:443\", \"1.0.0.1:443\", \"127.0.0.1:343\"]).unwrap();\n    // ...\n}\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-26","text":"();\n    // ...\n}\n```\n\nNow if we run our load balancer again with `cargo run`, and test it with \n\n```\ncurl 127.0.0.1:6188 -svo /dev/null\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-27","text":"8 -svo /dev/null\n```\n\nWe can see that one in every 3 request fails with `502: Bad Gateway`. This is \nbecause our peer selection is strictly following the `RoundRobin` selection \npattern we gave it with no consideration to whether that peer is healthy. We can\nfix this by adding a basic health check service. ","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-28","text":"alth check service. \n\n```rust\nfn main() {\n    let mut my_server = Server::new(None).unwrap();\n    my_server.bootstrap();\n\n    // Note that upstreams needs to be declared as `mut` now\n    let mut upstreams =\n        LoadBalancer::try_from_iter([\"1.1.1.1:443\", \"1.0.0.1:443\", \"127.0.0.1:343\"]).unwrap();","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-29","text":"0.1:343\"]).unwrap();\n\n    let hc = TcpHealthCheck::new();\n    upstreams.set_health_check(hc);\n    upstreams.health_check_frequency = Some(std::time::Duration::from_secs(1));\n\n    let background = background_service(\"health check\", upstreams);\n    let upstreams = background.task();","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-30","text":"= background.task();\n\n    // `upstreams` no longer need to be wrapped in an arc\n    let mut lb = http_proxy_service(&my_server.configuration, LB(upstreams));\n    lb.add_tcp(\"0.0.0.0:6188\");\n\n    my_server.add_service(background);\n\n    my_server.add_service(lb);\n    my_server.run_forever();\n}\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-31","text":"run_forever();\n}\n```\n\nNow if we again run and test our load balancer, we see that all requests \nsucceed and the broken peer is never used. Based on the configuration we used, \nif that peer were to become healthy again, it would be re-included in the round\nrobin again in within 1 second.\n\n### Command line options","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-32","text":"Command line options\n\nThe pingora `Server` type provides a lot of built-in functionality that we can\ntake advantage of with single-line change. \n\n```rust\nfn main() {\n    let mut my_server = Server::new(Some(Opt::parse_args())).unwrap();\n    ...\n}\n```\n\nWith this change, the command-line arguments passed to our load balancer will be \nconsumed by Pingora. We can test this by running:","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-33","text":"est this by running:\n\n```\ncargo run -- -h\n```\n\nWe should see a help menu with the list of arguments now available to us. We \nwill take advantage of those in the next sections to do more with our load \nbalancer for free\n\n### Running in the background\n\nPassing the parameter `-d` or `--daemon` will tell the program to run in the background.\n\n```\ncargo run -- -d\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-34","text":"\ncargo run -- -d\n```\n\nTo stop this service, you can send `SIGTERM` signal to it for a graceful shutdown, in which the service will stop accepting new request but try to finish all ongoing requests before exiting.\n```\npkill -SIGTERM load_balancer\n```\n (`SIGTERM` is the default signal for `pkill`.)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-35","text":"signal for `pkill`.)\n\n### Configurations\nPingora configuration files help define how to run the service. Here is an \nexample config file that defines how many threads the service can have, the \nlocation of the pid file, the error log file, and the upgrade coordination \nsocket (which we will explain later). Copy the contents below and put them into","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-36","text":"ow and put them into\na file called `conf.yaml` in your `load_balancer` project directory.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-37","text":"` project directory.\n\n```yaml\n---\nversion: 1\nthreads: 2\npid_file: /tmp/load_balancer.pid\nerror_log: /tmp/load_balancer_err.log\nupgrade_sock: /tmp/load_balancer.sock\n```\n\nTo use this conf file:\n```\nRUST_LOG=INFO cargo run -- -c conf.yaml -d\n```\n`RUST_LOG=INFO` is here so that the service actually populate the error log.\n\nNow you can find the pid of the service.\n```\n cat /tmp/load_balancer.pid\n```","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-38","text":"oad_balancer.pid\n```\n\n### Gracefully upgrade the service\n(Linux only)\n\nLet's say we changed the code of the load balancer and recompiled the binary. Now we want to upgrade the service running in the background to this newer version.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-39","text":" this newer version.\n\nIf we simply stop the old service, then start the new one, some request arriving in between could be lost. Fortunately, Pingora provides a graceful way to upgrade the service.\n\nThis is done by, first, send `SIGQUIT` signal to the running server, and then start the new server with the parameter `-u` \\ `--upgrade`.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-40","text":" `-u` \\ `--upgrade`.\n\n```\npkill -SIGQUIT load_balancer &&\\\nRUST_LOG=INFO cargo run -- -c conf.yaml -d -u\n```\n\nIn this process, The old running server will wait and hand over its listening sockets to the new server. Then the old server runs until all its ongoing requests finish.\n\nFrom a client's perspective, the service is always running because the listening socket is never closed.","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
{"id":"4aa3b49ef69bc0f1d8d2c03547ec5d0d-41","text":"ket is never closed.\n\n## Full examples\n\nThe full code for this example is available in this repository under\n\n[pingora-proxy/examples/load_balancer.rs](../pingora-proxy/examples/load_balancer.rs)\n\nOther examples that you may find helpful are also available here\n\n[pingora-proxy/examples/](../pingora-proxy/examples/)\n[pingora/examples](../pingora/examples/)","source":"/Users/fyyx/Documents/rust_projects/pingora/docs/quick_start.md"}
